From df1f8abf169cafbed1f09b8315a76491698ce057 Mon Sep 17 00:00:00 2001
From: Jean-Philippe Brucker <jean-philippe@linaro.org>
Date: Thu, 17 Feb 2022 16:37:10 +0000
Subject: [PATCH 65/97] iommu/arm-smmu-v3-kvm: Add IOMMU ops

Support attaching identity domains to devices. The attach request is
translated into a hypercall to enable stage-2 translation. The device
can then access all of host memory, but not that of hypervisor or
guests.

Signed-off-by: Jean-Philippe Brucker <jean-philippe@linaro.org>
---
 .../iommu/arm/arm-smmu-v3/arm-smmu-v3-kvm.c   | 123 ++++++++++++++++++
 1 file changed, 123 insertions(+)

diff --git a/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3-kvm.c b/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3-kvm.c
index b89de58a8f1d..8ce3e9c44fdf 100644
--- a/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3-kvm.c
+++ b/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3-kvm.c
@@ -6,8 +6,10 @@
  */
 #include <asm/kvm_mmu.h>
 #include <linux/of_platform.h>
+#include <linux/pci.h>
 
 #include <kvm/arm_smmu_v3.h>
+#include <asm/kvm_host.h>
 
 #include "arm-smmu-v3.h"
 
@@ -24,10 +26,126 @@ struct host_arm_smmu_device {
 	u32				gbpa;
 };
 
+struct kvm_arm_smmu_master {
+	struct arm_smmu_device		*smmu;
+	struct device			*dev;
+};
+
 static bool kvm_arm_smmu_matched;
 
 static LIST_HEAD(smmus);
 
+static int kvm_arm_smmu_def_domain_type(struct device *dev)
+{
+	return IOMMU_DOMAIN_IDENTITY;
+}
+
+static struct platform_driver kvm_arm_smmu_driver;
+
+static struct arm_smmu_device *
+kvm_arm_smmu_get_by_fwnode(struct fwnode_handle *fwnode)
+{
+	struct device *dev;
+
+	dev = driver_find_device_by_fwnode(&kvm_arm_smmu_driver.driver, fwnode);
+	put_device(dev);
+	return dev ? dev_get_drvdata(dev) : NULL;
+}
+
+static struct iommu_ops kvm_arm_smmu_ops;
+
+static struct iommu_device *kvm_arm_smmu_probe_device(struct device *dev)
+{
+	struct arm_smmu_device *smmu;
+	struct kvm_arm_smmu_master *master;
+	struct iommu_fwspec *fwspec = dev_iommu_fwspec_get(dev);
+
+	if (!fwspec || fwspec->ops != &kvm_arm_smmu_ops)
+		return ERR_PTR(-ENODEV);
+
+	if (WARN_ON_ONCE(dev_iommu_priv_get(dev)))
+		return ERR_PTR(-EBUSY);
+
+	smmu = kvm_arm_smmu_get_by_fwnode(fwspec->iommu_fwnode);
+	if (!smmu)
+		return ERR_PTR(-ENODEV);
+
+	master = kzalloc(sizeof(*master), GFP_KERNEL);
+	if (!master)
+		return ERR_PTR(-ENOMEM);
+
+	master->dev = dev;
+	master->smmu = smmu;
+	dev_iommu_priv_set(dev, master);
+
+	return &smmu->iommu;
+}
+
+static void kvm_arm_smmu_release_device(struct device *dev)
+{
+	struct kvm_arm_smmu_master *master = dev_iommu_priv_get(dev);
+
+	kfree(master);
+	iommu_fwspec_free(dev);
+}
+
+static struct iommu_domain *kvm_arm_smmu_domain_alloc(unsigned type)
+{
+	if (type != IOMMU_DOMAIN_IDENTITY)
+		return NULL;
+
+	return kzalloc(sizeof(struct iommu_domain), GFP_KERNEL);
+}
+
+static void kvm_arm_smmu_domain_free(struct iommu_domain *domain)
+{
+	kfree(domain);
+}
+
+static int kvm_arm_smmu_attach_dev(struct iommu_domain *domain,
+				   struct device *dev)
+{
+	int i, ret;
+	struct arm_smmu_device *smmu;
+	struct host_arm_smmu_device *host_smmu;
+	struct iommu_fwspec *fwspec = dev_iommu_fwspec_get(dev);
+	struct kvm_arm_smmu_master *master = dev_iommu_priv_get(dev);
+
+	if (!master)
+		return -ENODEV;
+
+	smmu = master->smmu;
+	host_smmu = container_of(smmu, struct host_arm_smmu_device, smmu);
+
+	/*
+	 * Request enablement of stage-2 translation to the hypervisor
+	 */
+	for (i = 0; i < fwspec->num_ids; i++) {
+		int sid = fwspec->ids[i];
+
+		ret = kvm_call_hyp_nvhe(__pkvm_dev_set_owner,
+					host_smmu->mmio_addr, sid);
+		if (ret) {
+			dev_err(smmu->dev, "cannot set owner of SID %d: %d\n",
+				sid, ret);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static struct iommu_ops kvm_arm_smmu_ops = {
+	.def_domain_type	= kvm_arm_smmu_def_domain_type,
+	.device_group		= arm_smmu_device_group,
+	.of_xlate		= arm_smmu_of_xlate,
+	.probe_device		= kvm_arm_smmu_probe_device,
+	.release_device		= kvm_arm_smmu_release_device,
+	.domain_alloc		= kvm_arm_smmu_domain_alloc,
+	.domain_free		= kvm_arm_smmu_domain_free,
+	.attach_dev		= kvm_arm_smmu_attach_dev,
+	.owner			= THIS_MODULE,
+};
+
 static bool kvm_arm_smmu_validate_features(struct arm_smmu_device *smmu)
 {
 	unsigned long vmid_bits;
@@ -270,6 +388,10 @@ static int kvm_arm_smmu_probe(struct platform_device *pdev)
 	if (ret)
 		return ret;
 
+	ret = arm_smmu_register_iommu(smmu, &kvm_arm_smmu_ops, ioaddr);
+	if (ret)
+		return ret;
+
 	platform_set_drvdata(pdev, host_smmu);
 
 	hyp_smmu->hyp.mmio_addr = ioaddr;
@@ -290,6 +412,7 @@ static int kvm_arm_smmu_remove(struct platform_device *pdev)
 	 * There was an error during hypervisor setup. The hyp driver may
 	 * have already enabled the device, so disable it.
 	 */
+	arm_smmu_unregister_iommu(smmu);
 	arm_smmu_device_disable(smmu);
 	arm_smmu_update_gbpa(smmu, host_smmu->gbpa, GBPA_ABORT);
 	return 0;
-- 
2.34.1

