From e84daca5f8aae923296cefc8652948595c45acdb Mon Sep 17 00:00:00 2001
From: Jean-Philippe Brucker <jean-philippe@linaro.org>
Date: Tue, 22 Feb 2022 15:26:13 +0000
Subject: [PATCH 93/97] DEBUG: KVM: arm64: pkvm: Dump memory mappings

Display state of memory after the hypervisor is set up. So we know which
memory to prod when testing IOMMU things:

pKVM: * 0x40000000 - 0x40ebffff (0xec0000) host
pKVM: * 0x40ec0000 - 0x40ed6fff (0x17000) hyp
pKVM: * 0x40ed7000 - 0x40edffff (0x9000) host
pKVM: * 0x40ee0000 - 0x4176dfff (0x88e000) hyp-host
pKVM: * 0x4176e000 - 0x41772fff (0x5000) hyp
pKVM: * 0x41773000 - 0x41fc4fff (0x852000) host

$ awk -n '{ if ($7 ~ "host") print "dmate-peek", $3, $5 - $3 + 1, "#", $7 }' /tmp/mem

dmate-peek 0x40000000 15466496 # host
dmate-peek 0x40ed7000 36864 # host
dmate-peek 0x40ee0000 8970240 # hyp-host
dmate-peek 0x41773000 8724480 # host

Hash all host memory with the dmate

Signed-off-by: Jean-Philippe Brucker <jean-philippe@linaro.org>
---
 arch/arm64/include/asm/kvm_asm.h   |  1 +
 arch/arm64/kvm/arm.c               |  2 +
 arch/arm64/kvm/hyp/nvhe/hyp-main.c |  8 +++
 arch/arm64/kvm/hyp/nvhe/setup.c    | 95 ++++++++++++++++++++++++++++++
 4 files changed, 106 insertions(+)

diff --git a/arch/arm64/include/asm/kvm_asm.h b/arch/arm64/include/asm/kvm_asm.h
index 1813487f1877..fb6a0d97748c 100644
--- a/arch/arm64/include/asm/kvm_asm.h
+++ b/arch/arm64/include/asm/kvm_asm.h
@@ -86,6 +86,7 @@ enum __kvm_host_smccc_func {
 	__KVM_HOST_SMCCC_FUNC___pkvm_iommu_pm_notify,
 	__KVM_HOST_SMCCC_FUNC___pkvm_iommu_finalize,
 	__KVM_HOST_SMCCC_FUNC___pkvm_dev_set_owner,
+	__KVM_HOST_SMCCC_FUNC___pkvm_dump_mem,
 };
 
 #define DECLARE_KVM_VHE_SYM(sym)	extern char sym[]
diff --git a/arch/arm64/kvm/arm.c b/arch/arm64/kvm/arm.c
index 4eee9bdaaa01..321a607c9ac1 100644
--- a/arch/arm64/kvm/arm.c
+++ b/arch/arm64/kvm/arm.c
@@ -205,6 +205,8 @@ void kvm_arch_destroy_vm(struct kvm *kvm)
 	atomic_set(&kvm->online_vcpus, 0);
 
 	kvm_unshare_hyp(kvm, kvm + 1);
+
+	kvm_call_hyp_nvhe(__pkvm_dump_mem);
 }
 
 static int kvm_check_extension(struct kvm *kvm, long ext)
diff --git a/arch/arm64/kvm/hyp/nvhe/hyp-main.c b/arch/arm64/kvm/hyp/nvhe/hyp-main.c
index abe3536dc1a9..795c77529e48 100644
--- a/arch/arm64/kvm/hyp/nvhe/hyp-main.c
+++ b/arch/arm64/kvm/hyp/nvhe/hyp-main.c
@@ -1074,6 +1074,13 @@ static void handle___pkvm_dev_set_owner(struct kvm_cpu_context *host_ctxt)
 	cpu_reg(host_ctxt, 1) = __pkvm_dev_set_owner(iommu, epid);
 }
 
+int pkvm_dump_mem(void);
+
+static void handle___pkvm_dump_mem(struct kvm_cpu_context *host_ctxt)
+{
+	pkvm_dump_mem();
+}
+
 typedef void (*hcall_t)(struct kvm_cpu_context *);
 
 #define HANDLE_FUNC(x)	[__KVM_HOST_SMCCC_FUNC_##x] = (hcall_t)handle_##x
@@ -1113,6 +1120,7 @@ static const hcall_t host_hcall[] = {
 	HANDLE_FUNC(__pkvm_iommu_pm_notify),
 	HANDLE_FUNC(__pkvm_iommu_finalize),
 	HANDLE_FUNC(__pkvm_dev_set_owner),
+	HANDLE_FUNC(__pkvm_dump_mem),
 };
 
 static void handle_host_hcall(struct kvm_cpu_context *host_ctxt)
diff --git a/arch/arm64/kvm/hyp/nvhe/setup.c b/arch/arm64/kvm/hyp/nvhe/setup.c
index 8d8253bd5415..c1d3a367675f 100644
--- a/arch/arm64/kvm/hyp/nvhe/setup.c
+++ b/arch/arm64/kvm/hyp/nvhe/setup.c
@@ -186,6 +186,51 @@ static void hpool_put_page(void *addr)
 	hyp_put_page(&hpool, addr);
 }
 
+struct mapping_dump {
+	u64			start;
+	u64			end;
+	enum pkvm_page_state	state;
+};
+
+static const char *state_to_str(enum pkvm_page_state state)
+{
+	switch (state) {
+	case PKVM_PAGE_OWNED:		return "hyp";
+	case PKVM_PAGE_SHARED_OWNED:	return "hyp-host";
+	case PKVM_PAGE_SHARED_BORROWED:	return "host-hyp";
+	case PKVM_NOPAGE:		return "host";
+	default:			return "???";
+	}
+}
+
+/* Print ranges of mappings */
+static void pkvm_dump_mapping(struct mapping_dump *dump, u64 start, u64 size,
+			      enum pkvm_page_state state)
+{
+	u64 end = start + size - 1;
+
+	if (!dump->start) {
+		dump->start = start;
+		dump->end = end;
+		dump->state = state;
+		return;
+	}
+
+	/* merge contiguous range */
+	if (dump->end + 1 == start &&
+	    dump->state == state) {
+		dump->end = end;
+		return;
+	}
+
+	pkvm_debug("* 0x%llx - 0x%llx (0x%llx) %s\n", dump->start, dump->end,
+		   dump->end - dump->start + 1, state_to_str(dump->state));
+
+	dump->start = start;
+	dump->end = end;
+	dump->state = state;
+}
+
 static int fix_host_ownership_walker(u64 addr, u64 end, u32 level,
 				     kvm_pte_t *ptep,
 				     enum kvm_pgtable_walk_flags flag,
@@ -197,9 +242,11 @@ static int fix_host_ownership_walker(u64 addr, u64 end, u32 level,
 	phys_addr_t phys;
 
 	if (!kvm_pte_valid(pte)) {
+		size_t size = kvm_granule_size(level);
 		if (flag != KVM_PGTABLE_WALK_LEAF)
 			return 0;
 
+		pkvm_dump_mapping(arg, __hyp_pa(addr), size, PKVM_NOPAGE);
 		return host_stage2_finalize_idmap(addr, level);
 	}
 
@@ -215,6 +262,7 @@ static int fix_host_ownership_walker(u64 addr, u64 end, u32 level,
 	 * configured in the hypervisor stage-1.
 	 */
 	state = pkvm_getstate(kvm_pgtable_hyp_pte_prot(pte));
+	pkvm_dump_mapping(arg, phys, PAGE_SIZE, state);
 	switch (state) {
 	case PKVM_PAGE_OWNED:
 		return host_stage2_set_owner_locked(phys, PAGE_SIZE, pkvm_hyp_id);
@@ -252,9 +300,11 @@ static int fix_hyp_pgtable_refcnt_walker(u64 addr, u64 end, u32 level,
 
 static int fix_host_ownership(void)
 {
+	struct mapping_dump dump = { .state = PKVM_NOPAGE };
 	struct kvm_pgtable_walker walker = {
 		.cb	= fix_host_ownership_walker,
 		.flags	= KVM_PGTABLE_WALK_LEAF,
+		.arg	= &dump,
 	};
 	int i, ret;
 
@@ -262,7 +312,10 @@ static int fix_host_ownership(void)
 		struct memblock_region *reg = &hyp_memory[i];
 		u64 start = (u64)hyp_phys_to_virt(reg->base);
 
+		pkvm_debug("Memory: 0x%llx - 0x%llx\n", reg->base,
+			   reg->base + reg->size - 1);
 		ret = kvm_pgtable_walk(&pkvm_pgtable, start, reg->size, &walker);
+		pkvm_dump_mapping(&dump, 0, 0, __PKVM_PAGE_RESERVED);
 		if (ret)
 			return ret;
 	}
@@ -289,6 +342,48 @@ void __iomem *pkvm_create_hyp_device_mapping(u64 base, u64 size)
 	return virt;
 }
 
+static int pkvm_dump_pte(u64 addr, u64 end, u32 level, kvm_pte_t *ptep,
+			 enum kvm_pgtable_walk_flags flag, void * const arg)
+{
+	kvm_pte_t pte = *ptep;
+	enum pkvm_page_state state;
+	size_t size = kvm_granule_size(level);
+
+	if (!kvm_pte_valid(pte)) {
+		pkvm_dump_mapping(arg, __hyp_pa(addr), size, PKVM_NOPAGE);
+		return 0;
+	}
+
+	state = pkvm_getstate(kvm_pgtable_hyp_pte_prot(pte));
+	pkvm_dump_mapping(arg, kvm_pte_to_phys(pte), size, state);
+	return 0;
+}
+
+int pkvm_dump_mem(void)
+{
+	struct mapping_dump dump = { .state = PKVM_NOPAGE };
+	struct kvm_pgtable_walker walker = {
+		.cb	= pkvm_dump_pte,
+		.flags	= KVM_PGTABLE_WALK_LEAF,
+		.arg	= &dump,
+	};
+	int i, ret;
+
+	hyp_spin_lock(&pkvm_pgd_lock);
+	for (i = 0; i < hyp_memblock_nr; i++) {
+		struct memblock_region *reg = &hyp_memory[i];
+		u64 start = (u64)hyp_phys_to_virt(reg->base);
+
+		ret = kvm_pgtable_walk(&pkvm_pgtable, start, reg->size, &walker);
+		pkvm_dump_mapping(&dump, 0, 0, __PKVM_PAGE_RESERVED);
+		if (ret)
+			break;
+	}
+	hyp_spin_unlock(&pkvm_pgd_lock);
+
+	return ret;
+}
+
 static int fix_hyp_pgtable_refcnt(void)
 {
 	struct kvm_pgtable_walker walker = {
-- 
2.34.1

