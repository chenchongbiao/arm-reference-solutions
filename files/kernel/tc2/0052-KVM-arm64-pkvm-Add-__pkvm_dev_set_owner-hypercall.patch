From 808f3f86834aded34b829dadf6695932ac9d1f45 Mon Sep 17 00:00:00 2001
From: Jean-Philippe Brucker <jean-philippe@linaro.org>
Date: Thu, 17 Feb 2022 16:17:31 +0000
Subject: [PATCH 52/97] KVM: arm64: pkvm: Add __pkvm_dev_set_owner() hypercall

Update stage-2 IOMMU translation for a device. For the moment, this
means enabling stage-2 for the host and only that. The two parameters
are the IOMMU ID (the base MMIO address on SMMUv3) and an endpoint ID
(the stream ID on SMMUv3).

Later we could pass a VMID, to hand a device over to a guest. The host
would initially own the device, then call this to change the stage-2
configuration. The guest would need to call this again to hand the
device back to the host.

We could also pass a stage-1 configuration along this this call, or
separately. That will also require an invalidation hypercall since the
hypervisor owns the only command queue.

Signed-off-by: Jean-Philippe Brucker <jean-philippe@linaro.org>
---
 arch/arm64/include/asm/kvm_asm.h   | 1 +
 arch/arm64/include/asm/kvm_hyp.h   | 2 ++
 arch/arm64/kvm/hyp/nvhe/hyp-main.c | 9 +++++++++
 arch/arm64/kvm/hyp/nvhe/pkvm.c     | 9 +++++++++
 4 files changed, 21 insertions(+)

diff --git a/arch/arm64/include/asm/kvm_asm.h b/arch/arm64/include/asm/kvm_asm.h
index 671a89670373..0af1d076021d 100644
--- a/arch/arm64/include/asm/kvm_asm.h
+++ b/arch/arm64/include/asm/kvm_asm.h
@@ -84,6 +84,7 @@ enum __kvm_host_smccc_func {
 	__KVM_HOST_SMCCC_FUNC___pkvm_iommu_register,
 	__KVM_HOST_SMCCC_FUNC___pkvm_iommu_pm_notify,
 	__KVM_HOST_SMCCC_FUNC___pkvm_iommu_finalize,
+	__KVM_HOST_SMCCC_FUNC___pkvm_dev_set_owner,
 };
 
 #define DECLARE_KVM_VHE_SYM(sym)	extern char sym[]
diff --git a/arch/arm64/include/asm/kvm_hyp.h b/arch/arm64/include/asm/kvm_hyp.h
index cc251c5e356b..b348ed5e5463 100644
--- a/arch/arm64/include/asm/kvm_hyp.h
+++ b/arch/arm64/include/asm/kvm_hyp.h
@@ -113,6 +113,7 @@ int __pkvm_init(phys_addr_t phys, unsigned long size, unsigned long nr_cpus,
 		unsigned long *per_cpu_base, u32 hyp_va_bits,
 		enum kvm_iommu_driver iommu_driver);
 void __noreturn __host_enter(struct kvm_cpu_context *host_ctxt);
+int __pkvm_dev_set_owner(u64 iommu, unsigned int epid);
 #endif
 
 extern u64 kvm_nvhe_sym(id_aa64pfr0_el1_sys_val);
@@ -128,6 +129,7 @@ extern unsigned long kvm_nvhe_sym(__icache_flags);
 extern bool kvm_nvhe_sym(smccc_trng_available);
 struct kvm_iommu_ops {
 	int (*init)(void);
+	int (*dev_set_owner)(u64 iommu, unsigned int epid);
 	int (*tlb_flush_vmid)(struct kvm_s2_mmu *mmu);
 	int (*tlb_flush_vmid_ipa)(struct kvm_s2_mmu *mmu, phys_addr_t ipa,
 								int level);
diff --git a/arch/arm64/kvm/hyp/nvhe/hyp-main.c b/arch/arm64/kvm/hyp/nvhe/hyp-main.c
index 5e127f0609b5..eb5d81f1653e 100644
--- a/arch/arm64/kvm/hyp/nvhe/hyp-main.c
+++ b/arch/arm64/kvm/hyp/nvhe/hyp-main.c
@@ -1053,6 +1053,14 @@ static void handle___pkvm_iommu_finalize(struct kvm_cpu_context *host_ctxt)
 	cpu_reg(host_ctxt, 1) = __pkvm_iommu_finalize();
 }
 
+static void handle___pkvm_dev_set_owner(struct kvm_cpu_context *host_ctxt)
+{
+	DECLARE_REG(u64, iommu, host_ctxt, 1);
+	DECLARE_REG(unsigned int, epid, host_ctxt, 2);
+
+	cpu_reg(host_ctxt, 1) = __pkvm_dev_set_owner(iommu, epid);
+}
+
 typedef void (*hcall_t)(struct kvm_cpu_context *);
 
 #define HANDLE_FUNC(x)	[__KVM_HOST_SMCCC_FUNC_##x] = (hcall_t)handle_##x
@@ -1090,6 +1098,7 @@ static const hcall_t host_hcall[] = {
 	HANDLE_FUNC(__pkvm_iommu_register),
 	HANDLE_FUNC(__pkvm_iommu_pm_notify),
 	HANDLE_FUNC(__pkvm_iommu_finalize),
+	HANDLE_FUNC(__pkvm_dev_set_owner),
 };
 
 static void handle_host_hcall(struct kvm_cpu_context *host_ctxt)
diff --git a/arch/arm64/kvm/hyp/nvhe/pkvm.c b/arch/arm64/kvm/hyp/nvhe/pkvm.c
index 452a787b43e8..80d58cb1f499 100644
--- a/arch/arm64/kvm/hyp/nvhe/pkvm.c
+++ b/arch/arm64/kvm/hyp/nvhe/pkvm.c
@@ -7,6 +7,7 @@
 #include <asm/kvm_arm.h>
 #include <asm/kvm_asm.h>
 #include <asm/kvm_host.h>
+#include <asm/kvm_hyp.h>
 #include <asm/kvm_mmu.h>
 #include <asm/memory.h>
 
@@ -207,6 +208,14 @@ static void pkvm_vcpu_init_traps(struct kvm_vcpu *vcpu)
 	pvm_init_traps_aa64mmfr1(vcpu);
 }
 
+int __pkvm_dev_set_owner(u64 iommu, unsigned int epid)
+{
+	if (kvm_iommu_ops.dev_set_owner)
+		return kvm_iommu_ops.dev_set_owner(iommu, epid);
+
+	return -ENODEV;
+}
+
 /*
  * Start the shadow table handle at the offset defined instead of at 0.
  * Mainly for sanity checking and debugging.
-- 
2.34.1

