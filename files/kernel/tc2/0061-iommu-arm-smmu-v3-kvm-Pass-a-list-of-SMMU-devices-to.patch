From b2bc74dea41bb7a594b128d4a5348e3709087faa Mon Sep 17 00:00:00 2001
From: Jean-Philippe Brucker <jean-philippe@linaro.org>
Date: Wed, 9 Feb 2022 19:51:51 +0000
Subject: [PATCH 61/97] iommu/arm-smmu-v3-kvm: Pass a list of SMMU devices to
 the hypervisor

Build a list of devices and donate the page to the hypervisor. At this
point the host is trusted and this would be a good opportunity to
provide more information about the system. For example, which devices
are owned by the host (perhaps via the VMID and SW bits in the stream
table).

Signed-off-by: Jean-Philippe Brucker <jean-philippe@linaro.org>
---
 .../iommu/arm/arm-smmu-v3/arm-smmu-v3-kvm.c   | 91 ++++++++++++++++++-
 1 file changed, 89 insertions(+), 2 deletions(-)

diff --git a/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3-kvm.c b/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3-kvm.c
index b670e4a02501..c977a908633d 100644
--- a/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3-kvm.c
+++ b/drivers/iommu/arm/arm-smmu-v3/arm-smmu-v3-kvm.c
@@ -4,16 +4,83 @@
  *
  * Copyright (C) 2022 Linaro Ltd.
  */
+#include <asm/kvm_mmu.h>
 #include <linux/of_platform.h>
 
 #include <kvm/arm_smmu_v3.h>
 
+#include "arm-smmu-v3.h"
+
+struct hyp_arm_smmu_device {
+	/* Parameters passed to the hypervisor */
+	struct hyp_arm_smmu_v3_device	hyp;
+	struct list_head		list;
+	struct device			*dev;
+};
+
+struct host_arm_smmu_device {
+	struct arm_smmu_device		smmu;
+	u64				mmio_addr;
+};
+
 static bool kvm_arm_smmu_matched;
 
+static LIST_HEAD(smmus);
+
 static int kvm_arm_smmu_probe(struct platform_device *pdev)
 {
+	int ret;
+	size_t size;
+	phys_addr_t ioaddr;
+	struct resource *res;
+	struct arm_smmu_device *smmu;
+	struct device *dev = &pdev->dev;
+	struct hyp_arm_smmu_device *hyp_smmu;
+	struct host_arm_smmu_device *host_smmu;
+
 	kvm_arm_smmu_matched = true;
-	return -ENOSYS;
+
+	/* Temporary struct containing the hypervisor parameters */
+	hyp_smmu = devm_kzalloc(dev, sizeof(*hyp_smmu), GFP_KERNEL);
+	if (!hyp_smmu)
+		return -ENOMEM;
+
+	host_smmu = devm_kzalloc(dev, sizeof(*host_smmu), GFP_KERNEL);
+	if (!host_smmu)
+		return -ENOMEM;
+
+	hyp_smmu->dev = dev;
+	smmu = &host_smmu->smmu;
+	smmu->dev = dev;
+
+	if (!dev->of_node || arm_smmu_device_dt_probe(pdev, smmu))
+		return -ENODEV;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	size = resource_size(res);
+	if (size < SZ_128K) {
+		dev_err(dev, "unsupported MMIO region size (%pr)\n", res);
+		return -EINVAL;
+	}
+	ioaddr = res->start;
+
+	smmu->base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(smmu->base))
+		return PTR_ERR(smmu->base);
+
+	ret = arm_smmu_device_hw_probe(smmu);
+	if (ret)
+		return ret;
+
+	platform_set_drvdata(pdev, host_smmu);
+
+	hyp_smmu->hyp.mmio_addr = ioaddr;
+	host_smmu->mmio_addr = ioaddr;
+	hyp_smmu->hyp.mmio_size = size;
+	list_add(&hyp_smmu->list, &smmus);
+	kvm_hyp_arm_smmu_v3_nr_devices++;
+
+	return 0;
 }
 
 static int kvm_arm_smmu_remove(struct platform_device *pdev)
@@ -44,6 +111,10 @@ static struct platform_driver kvm_arm_smmu_driver = {
 int kvm_arm_smmu_v3_init(void)
 {
 	int ret;
+	int order;
+	int i = 0;
+	struct hyp_arm_smmu_device *hyp_smmu, *next;
+	struct hyp_arm_smmu_v3_device *hyp_smmus;
 
 	ret = platform_driver_probe(&kvm_arm_smmu_driver, kvm_arm_smmu_probe);
 	if (ret == -ENODEV && kvm_arm_smmu_matched) {
@@ -52,9 +123,25 @@ int kvm_arm_smmu_v3_init(void)
 		 * DMA isolation is broken.
 		 */
 		return -EUNATCH;
+	} else if (ret) {
+		return ret;
+	}
+
+	/* Copy list to hypervisor */
+	order = get_order(kvm_hyp_arm_smmu_v3_nr_devices * sizeof(*hyp_smmus));
+	hyp_smmus = (void *)__get_free_pages(GFP_KERNEL, order);
+	if (!hyp_smmus)
+		return -ENOMEM;
+
+	list_for_each_entry_safe(hyp_smmu, next, &smmus, list) {
+		hyp_smmus[i++] = hyp_smmu->hyp;
+		list_del(&hyp_smmu->list);
+		devm_kfree(hyp_smmu->dev, hyp_smmu);
 	}
+	WARN_ON(i != kvm_hyp_arm_smmu_v3_nr_devices);
+	kvm_hyp_arm_smmu_v3_devices = kern_hyp_va(hyp_smmus);
 
-	return ret;
+	return 0;
 }
 
 void kvm_arm_smmu_v3_remove(void)
-- 
2.34.1

