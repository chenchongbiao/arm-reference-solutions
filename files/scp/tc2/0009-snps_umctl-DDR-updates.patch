From 6e1aea74110b523ca65d0fffef03c386d09e6f5e Mon Sep 17 00:00:00 2001
From: Usama Arif <usama.arif@arm.com>
Date: Wed, 3 Nov 2021 13:46:19 +0000
Subject: [PATCH 09/18] snps_umctl: DDR updates

This includes read/write performance improvements as well as
DDR programming for access to 16GB DRAM.

Signed-off-by: Usama Arif <usama.arif@arm.com>
---
 .../include/DWC_ddrctl_lpddr5_init_mem.h      | 437 +++++++++++++++++-
 .../include/DWC_ddrctl_lpddr5_init_regs.h     |  75 +--
 module/snps_umctl/include/snps_defines.h      |  56 ++-
 3 files changed, 517 insertions(+), 51 deletions(-)

diff --git a/module/snps_umctl/include/DWC_ddrctl_lpddr5_init_mem.h b/module/snps_umctl/include/DWC_ddrctl_lpddr5_init_mem.h
index bac19f88..f34de59f 100644
--- a/module/snps_umctl/include/DWC_ddrctl_lpddr5_init_mem.h
+++ b/module/snps_umctl/include/DWC_ddrctl_lpddr5_init_mem.h
@@ -6,6 +6,16 @@
 MEM_RW(DMC_BASE, 0x010208)  = 0x00000001; //RFSHCTL0
 MEM_RW(DMC_BASE, 0x010180)  = 0x00020200; //PWRCTL
 
+#ifndef DMC_BYPASS_PHY_INIT
+  // Set SWCTL.sw_done to 0
+  MEM_RW(DMC_BASE, 0x010c80)  = 0x00000000; //SWCTL
+#ifdef SNPS_VIP_FW
+// Phy and Memory initialization
+
+// Disable auto-refreshes, self-refresh, powerdown and assertion of dfi_dram_clk_disable by setting RFSHCTL0.dis_auto_refresh = 1, PWRCTL.powerdown_en = 0 and PWRCTL.selfref_en = 0 PWRCTL.en_dfi_dram_clk_disable = 0
+MEM_RW(DMC_BASE, 0x010208)  = 0x00000001; //RFSHCTL0
+MEM_RW(DMC_BASE, 0x010180)  = 0x00020200; //PWRCTL
+
 #ifndef DMC_BYPASS_PHY_INIT
   // Set SWCTL.sw_done to 0
   MEM_RW(DMC_BASE, 0x010c80)  = 0x00000000; //SWCTL
@@ -25,11 +35,11 @@ MEM_RW(DMC_BASE, 0x010180)  = 0x00020200; //PWRCTL
 //  while ((MEM_RW(DMC_BASE, 0x18)&0x1)  ==1 );  // MRSTAT - wait busy
 //
 //  // Configure PHY
-////  MEM_RW(PHY_BASE,DMC620_PHY_INIT_COMPLETE)   = 0x00000001; //0x00   
+////  MEM_RW(PHY_BASE,DMC620_PHY_INIT_COMPLETE)   = 0x00000001; //0x00
 //  MEM_RW(PHY_BASE,DMC620_PHY_READ_DELAY)      = 0x00000002; //0x08
 //  MEM_RW(PHY_BASE,DMC620_PHY_CAPTURE_MASK)    = 0x0000001f; //0x0C
 //  MEM_RW(PHY_BASE,DMC620_PHY_T_CONTROL_DELAY) = 0x00000000; //0x14
-//  MEM_RW(PHY_BASE,DMC620_PHY_WR_LATENCY)      = 0x01000000; //0x18   
+//  MEM_RW(PHY_BASE,DMC620_PHY_WR_LATENCY)      = 0x01000000; //0x18
 //  MEM_RW(PHY_BASE,DMC620_PHY_RDDATA_EN)       = 0x00001a00; //0x1C
 //  MEM_RW(PHY_BASE,DMC620_PHY_RD_LATENCY)      = 0x00000016; //0x20
 //  MEM_RW(PHY_BASE,DMC620_PHY_CLP_ACK)         = 0x00641300; //0x30
@@ -37,7 +47,396 @@ MEM_RW(DMC_BASE, 0x010180)  = 0x00020200; //PWRCTL
 //  MEM_RW(PHY_BASE,DMC620_PHY_DELAY_SEL)       = 0x0000000A; //0x820
 ////  MEM_RW(PHY_BASE,DMC620_PHY_REF_EN)          = 0x00000000; //0x824
 //  MEM_RW(PHY_BASE,DMC620_PHY_T_CTRL_UPD_MIN)  = 0x00000000; //0x828
-  
+
+//  while ((MEM_RW(DMC_BASE, 0x4)&0x1) != 1 );  // STAT - wait until normal
+
+//
+  // Set SWCTL.sw_done to 0
+  MEM_RW(DMC_BASE, 0x010c80)  = 0x00000000; //SWCTL
+
+  // Set DFIMISC.dfi_init_start to 1
+  MEM_RW(DMC_BASE, 0x010510)  = 0x00000024; //DFIMISC
+
+  // Set SWCTL.sw_done to 1 (Require polling SWSTAT.sw_done_ack after setting SWCTL.sw_done to 1)
+  MEM_RW(DMC_BASE, 0x010c80)  = 0x00000001; //SWCTL
+  while ((MEM_RW(DMC_BASE, 0x010c84)&0x1)  ==0 ); //SWSTAT
+
+  // Poll DFISTAT.dfi_init_complete=1
+  while ((MEM_RW(DMC_BASE, 0x010514)&0x1)  ==0 ); //DFISTAT
+
+  // Set SWCTL.sw_done to 0
+  MEM_RW(DMC_BASE, 0x010c80)  = 0x00000000; //SWCTL
+
+  // Set DFIMISC.dfi_init_start to 0
+  MEM_RW(DMC_BASE, 0x010510)  = 0x00000004; //DFIMISC
+
+  // The following registers may need to be updated after training has completed:
+  // RANKTMG0.diff_rank_wr_gap
+  // RANKTMG0.diff_rank_rd_gap
+  // DRAMSET1TMG2.rd2wr
+  // DRAMSET1TMG2.wr2rd
+
+  // Set DFIMISC.dfi_init_complete_en to 1
+  MEM_RW(DMC_BASE, 0x010510)  = 0x00000005; //DFIMISC
+
+  // Set PWRCTL.selfref_sw to 0
+  MEM_RW(DMC_BASE, 0x010180)  = 0x00020200; //PWRCTL
+
+  // Set SWCTL.sw_done to 1 (Require polling SWSTAT.sw_done_ack after setting SWCTL.sw_done to 1
+  MEM_RW(DMC_BASE, 0x010c80)  = 0x00000001; //SWCTL
+  while ((MEM_RW(DMC_BASE, 0x010c84)&0x1)  ==0 ); //SWSTAT
+#else
+  //##########################################################
+  // REVISIT [kispet01 @2020-03-02] This option is not yet tested. Remove this comment after completing the check
+  c_print_str("Warning: Bypassing PHY init sequence, this option is not tested and may not work as expected.\n");
+  //##########################################################
+  printf("Bypassed PHY initilization for DMC%0d\n",index);
+#endif
+
+// Wait for DWC_ddrctl to move to normal operating mode by monitoring STAT.operating_mode signal
+while ((MEM_RW(DMC_BASE, 0x010014)&0x7)  !=1 ); //STAT
+
+// Revert back the below registers to the original values if desired
+// RFSHCTL0.dis_auto_refresh = 0, PWRCTL.powerdown_en = 0 and PWRCTL.selfref_en = 0 PWRTL.en_dfi_dram_clk_disable = 0
+MEM_RW(DMC_BASE, 0x010208)  = 0x00000000; //RFSHCTL0 - RFSHCTL0.dis_auto_refresh = 0
+
+// Note: Skipping frontdoor MR writes by default to reduce simulation time
+#ifdef DMC_SDRAM_MR_WRITES_EN
+// Initiate Mode Register Writes from the controller for SDRAM Memory
+// Software sequence for Mode register writes is as below:
+// 1. Poll MRSTAT.mr_wr_busy until it is 0. This checks that there is no outstanding MR transaction. No
+// writes must be performed to MRCTRL0 and MRCTRL1 if MRSTAT.mr_wr_busy = 1.
+// 2. Write the MRCTRL0.mr_type, MRCTRL0.mr_addr, MRCTRL0.mr_rank and (for MRWs)
+// MRCTRL1.mr_data to define the MR transaction.
+// 3. In a separate APB transaction, write the MRCTRL0.mr_wr to 1. This bit is self-clearing, and triggers the
+// MR transaction. The DDRCTL then asserts the MRSTAT.mr_wr_busy while it performs the MR transaction
+// to SDRAM, and no further accesses can be initiated until it is de-asserted.
+
+//MR18, Addr = 'h12, Data = 'h0, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001200; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR18, Addr = 'h12, Data = 'h0, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001200; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR1, Addr = 'h1, Data = 'hb0, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x000001b0; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR1, Addr = 'h1, Data = 'hb0, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x000001b0; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR2, Addr = 'h2, Data = 'hbb, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x000002bb; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR2, Addr = 'h2, Data = 'hbb, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x000002bb; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR3, Addr = 'h3, Data = 'h26, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00000326; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR3, Addr = 'h3, Data = 'h26, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00000326; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR10, Addr = 'ha, Data = 'h58, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00000a58; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR10, Addr = 'ha, Data = 'h58, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00000a58; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR11, Addr = 'hb, Data = 'h44, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00000b44; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR11, Addr = 'hb, Data = 'h44, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00000b44; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR12, Addr = 'hc, Data = 'h2d, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00000c2d; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR12, Addr = 'hc, Data = 'h2d, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00000c2d; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR13, Addr = 'hd, Data = 'h21, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+//MEM_RW(DMC_BASE, 0x010084)  = 0x00000d21; //MRCTRL1 - Program MR Address and MR WData
+// Enabling DM for Masked Writes
+MEM_RW(DMC_BASE, 0x010084)  = 0x00000d01; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR13, Addr = 'hd, Data = 'h21, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+//MEM_RW(DMC_BASE, 0x010084)  = 0x00000d21; //MRCTRL1 - Program MR Address and MR WData
+// Enabling DM for Masked Writes
+MEM_RW(DMC_BASE, 0x010084)  = 0x00000d01; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+// Note: Removing MR14, MR15 register writes to avoid tVREF related errors from VIP
+// Need to check with IP team to see if there is a way to control this timing
+////MR14, Addr = 'he, Data = 'h15, Rank 0
+//while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+//MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+//MEM_RW(DMC_BASE, 0x010084)  = 0x00000e15; //MRCTRL1 - Program MR Address and MR WData
+//MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+//
+////MR14, Addr = 'he, Data = 'h15, Rank 1
+//while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+//MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+//MEM_RW(DMC_BASE, 0x010084)  = 0x00000e15; //MRCTRL1 - Program MR Address and MR WData
+//MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+//
+////MR15, Addr = 'hf, Data = 'h62, Rank 0
+//while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+//MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+//MEM_RW(DMC_BASE, 0x010084)  = 0x00000f62; //MRCTRL1 - Program MR Address and MR WData
+//MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+//
+////MR15, Addr = 'hf, Data = 'h62, Rank 1
+//while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+//MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+//MEM_RW(DMC_BASE, 0x010084)  = 0x00000f62; //MRCTRL1 - Program MR Address and MR WData
+//MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR16, Addr = 'h10, Data = 'h0, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001000; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR16, Addr = 'h10, Data = 'h0, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001000; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR17, Addr = 'h11, Data = 'h1d, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x0000111d; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR17, Addr = 'h11, Data = 'h1d, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x0000111d; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR19, Addr = 'h13, Data = 'h0, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001300; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR19, Addr = 'h13, Data = 'h0, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001300; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR20, Addr = 'h14, Data = 'h2, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001402; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR20, Addr = 'h14, Data = 'h2, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001402; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR22, Addr = 'h16, Data = 'h0, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001600; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR22, Addr = 'h16, Data = 'h0, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001600; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR23, Addr = 'h17, Data = 'h0, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001700; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR23, Addr = 'h17, Data = 'h0, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001700; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR25, Addr = 'h19, Data = 'h0, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001900; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR25, Addr = 'h19, Data = 'h0, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001900; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR28, Addr = 'h1c, Data = 'h8, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001c08; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR28, Addr = 'h1c, Data = 'h8, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001c08; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR37, Addr = 'h25, Data = 'h40, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00002540; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR37, Addr = 'h25, Data = 'h40, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00002540; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR40, Addr = 'h28, Data = 'h40, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00002840; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR40, Addr = 'h28, Data = 'h40, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00002840; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//Poll MRSTAT.mr_wr_busy until it is 0. This checks that there is no outstanding MR transaction
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+
+#endif // #ifndef DMC_SDRAM_MR_WRITES_EN
+#else
+#include <phy_registers.h>
+#include <snps_defines.h>
+  // Initialize the PHY Registers
+  MEM_RW(PHY_BASE,PHY_INIT_COMPLETE)   = 0x00000001; //0x00
+  MEM_RW(PHY_BASE, PHY_READ_DELAY)     = 0x00000001; //0x08
+  MEM_RW(PHY_BASE, PHY_CAPTURE_MASK)   = 0x00000003; //0x0C
+  MEM_RW(PHY_BASE, PHY_T_CTRL_DELAY)   = 0x0a000000; //0x14
+  MEM_RW(PHY_BASE, PHY_WR_LATENCY)     = 0x01000033; //0x18   // mask offset = 0 data offset =1
+  MEM_RW(PHY_BASE, PHY_RDDATA_EN)      = 0x00002400; //0x1C
+  MEM_RW(PHY_BASE, PHY_RD_LATENCY)     = 0x00000024; //0x20
+  MEM_RW(PHY_BASE, PHY_LP_ACK)         = 0x00030000; //0x30
+  MEM_RW(PHY_BASE, PHY_WR_PREMBL)      = 0x00000002; //0x58
+  MEM_RW(PHY_BASE, PHY_DELAY_SEL)      = 0x0000000d; //0x820
+  MEM_RW(PHY_BASE, PHY_REF_EN)         = 0x00000000; //0x824
+  MEM_RW(PHY_BASE, PHY_T_CTRL_UPD_MIN) = 0x00000000; //0x828
+
+  while ((MEM_RW(DMC_BASE, 0x10014))  !=1 ) ;  // STAT - wait until normal
+
+#if DMC_WCK_ALWAYS_ON
+  //MEM_RW(DMC_BASE, 0x10180) = (MEM_RW(DMC_BASE, 0x10180)|(0x1<<11)); // PWRCTL - selfref_sw=1
+  MEM_RW(DMC_BASE, 0x10180) = (0x1<<11); // PWRCTL - selfref_sw=1
+  while (((MEM_RW(DMC_BASE, 0x10014)) & 0x00000037) !=0x23 ) ; // STAT - wait until STAT.operating_mode=3b011 and STAT.selfref_type=2b10.
+  MEM_RW(DMC_BASE, 0x10c80) = 0x00000000; // SWCTL -sw_done=0 Enable writes to quasi-dynamic registers outside reset.
+  MEM_RW(DMC_BASE, 0x10010) = 0x00000001; // MSTR4 - CH0 WCK Always on Mode Enable
+  //MEM_RW(DMC_BASE, 0x11010) = 0x00000001; // MSTR4 - CH1 WCK Always on Mode Enable
+  MEM_RW(DMC_BASE, 0x10c80) = 0x00000001; // SWCTL - sw_done =1 Enable writes to quasi-dynamic registers outside reset.
+  while ((MEM_RW(DMC_BASE, 0x10c84)) != 0x00000001); // SWSTAT-sw_done_ack=1 propagtes to ack
+  MEM_RW(DMC_BASE, 0x10180) = (0x0<<11); // PWRCTL - selfref_sw=1
+  //((MEM_RW(DMC_BASE, 0x10180)) | (0x0<<11)); // PWRCTL - selfref_sw=0
+  while (((MEM_RW(DMC_BASE, 0x10014)) & 0x00000007) !=0x1 ) ; // STAT - wait until STAT.operating_mode=3b011 and STAT.selfref_type=2b10.
+  //while ((MEM_RW(DMC_BASE, 0x10014))  !=1 ) ;  // STAT - wait until normal
+#endif
+
+//MRSTAT //MR2 WL =16 RL=17
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000030; //MRCTRL0 - Program the Rank#
+#if DMC_WCK_ALWAYS_ON
+    MEM_RW(DMC_BASE, 0x010084)  = 0x0000026b; //MRCTRL1 - Program MR Address and MR WData
+#else
+    MEM_RW(DMC_BASE, 0x010084)  = 0x0000029b; //MRCTRL1 - Program MR Address and MR WData
+#endif
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000030; //MRCTRL0 - Trigger MR Write from the controller
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 );
+//
+#endif
+
+
+  // Set DFIMISC.dfi_init_complete_en to 0
+  MEM_RW(DMC_BASE, 0x010510)  = 0x00000004; //DFIMISC
+
+  // Set SWCTL.sw_done to 1 (Require polling SWSTAT.sw_done_ack after setting SWCTL.sw_done to 1)
+  MEM_RW(DMC_BASE, 0x010c80)  = 0x00000001; //SWCTL
+  while ((MEM_RW(DMC_BASE, 0x010c84)&0x1)  ==0 ); //SWSTAT
+
+  // PHY initialization.
+  // Start PHY initialization and training by accessing relevant PUB registers
+  // Not required in simulation now as we are using PHY VIP model
+  // For PHY models with configuration interface, do the PHY initilization here
+
+//  while ((MEM_RW(DMC_BASE, 0x18)&0x1)  ==1 );  // MRSTAT - wait busy
+//
+//  // Configure PHY
+////  MEM_RW(PHY_BASE,DMC620_PHY_INIT_COMPLETE)   = 0x00000001; //0x00
+//  MEM_RW(PHY_BASE,DMC620_PHY_READ_DELAY)      = 0x00000002; //0x08
+//  MEM_RW(PHY_BASE,DMC620_PHY_CAPTURE_MASK)    = 0x0000001f; //0x0C
+//  MEM_RW(PHY_BASE,DMC620_PHY_T_CONTROL_DELAY) = 0x00000000; //0x14
+//  MEM_RW(PHY_BASE,DMC620_PHY_WR_LATENCY)      = 0x01000000; //0x18
+//  MEM_RW(PHY_BASE,DMC620_PHY_RDDATA_EN)       = 0x00001a00; //0x1C
+//  MEM_RW(PHY_BASE,DMC620_PHY_RD_LATENCY)      = 0x00000016; //0x20
+//  MEM_RW(PHY_BASE,DMC620_PHY_CLP_ACK)         = 0x00641300; //0x30
+//  MEM_RW(PHY_BASE,0x04C)                      = 0x00000002; //0x4c PHY500_DFI_WR_PREMBL (0x58 DMC620_PHY_WR_PREMBL)
+//  MEM_RW(PHY_BASE,DMC620_PHY_DELAY_SEL)       = 0x0000000A; //0x820
+////  MEM_RW(PHY_BASE,DMC620_PHY_REF_EN)          = 0x00000000; //0x824
+//  MEM_RW(PHY_BASE,DMC620_PHY_T_CTRL_UPD_MIN)  = 0x00000000; //0x828
+
 //  while ((MEM_RW(DMC_BASE, 0x4)&0x1) != 1 );  // STAT - wait until normal
 
 //
@@ -190,7 +589,7 @@ MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the
 while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
 MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
 //MEM_RW(DMC_BASE, 0x010084)  = 0x00000d21; //MRCTRL1 - Program MR Address and MR WData
-// Enabling DM for Masked Writes 
+// Enabling DM for Masked Writes
 MEM_RW(DMC_BASE, 0x010084)  = 0x00000d01; //MRCTRL1 - Program MR Address and MR WData
 MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
 
@@ -198,12 +597,12 @@ MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the
 while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
 MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
 //MEM_RW(DMC_BASE, 0x010084)  = 0x00000d21; //MRCTRL1 - Program MR Address and MR WData
-// Enabling DM for Masked Writes 
+// Enabling DM for Masked Writes
 MEM_RW(DMC_BASE, 0x010084)  = 0x00000d01; //MRCTRL1 - Program MR Address and MR WData
 MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
 
 // Note: Removing MR14, MR15 register writes to avoid tVREF related errors from VIP
-// Need to check with IP team to see if there is a way to control this timing 
+// Need to check with IP team to see if there is a way to control this timing
 ////MR14, Addr = 'he, Data = 'h15, Rank 0
 //while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
 //MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
@@ -356,13 +755,13 @@ while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
 #include <phy_registers.h>
 #include <snps_defines.h>
   // Initialize the PHY Registers
-  MEM_RW(PHY_BASE,PHY_INIT_COMPLETE)   = 0x00000001; //0x00   
-  MEM_RW(PHY_BASE, PHY_READ_DELAY)     = 0x00000001; //0x08   
-  MEM_RW(PHY_BASE, PHY_CAPTURE_MASK)   = 0x00000003; //0x0C   
-  MEM_RW(PHY_BASE, PHY_T_CTRL_DELAY)   = 0x0a000000; //0x14	 
-  MEM_RW(PHY_BASE, PHY_WR_LATENCY)     = 0x01000033; //0x18	  // mask offset = 0 data offset =1 
-  MEM_RW(PHY_BASE, PHY_RDDATA_EN)      = 0x00002400; //0x1C	  
-  MEM_RW(PHY_BASE, PHY_RD_LATENCY)     = 0x00000024; //0x20			   		   
+  MEM_RW(PHY_BASE,PHY_INIT_COMPLETE)   = 0x00000001; //0x00
+  MEM_RW(PHY_BASE, PHY_READ_DELAY)     = 0x00000001; //0x08
+  MEM_RW(PHY_BASE, PHY_CAPTURE_MASK)   = 0x00000003; //0x0C
+  MEM_RW(PHY_BASE, PHY_T_CTRL_DELAY)   = 0x0a000000; //0x14
+  MEM_RW(PHY_BASE, PHY_WR_LATENCY)     = 0x01000033; //0x18	  // mask offset = 0 data offset =1
+  MEM_RW(PHY_BASE, PHY_RDDATA_EN)      = 0x00002400; //0x1C
+  MEM_RW(PHY_BASE, PHY_RD_LATENCY)     = 0x00000024; //0x20
   MEM_RW(PHY_BASE, PHY_LP_ACK)         = 0x00030000; //0x30
   MEM_RW(PHY_BASE, PHY_WR_PREMBL)      = 0x00000002; //0x58
   MEM_RW(PHY_BASE, PHY_DELAY_SEL)      = 0x0000000d; //0x820
@@ -372,16 +771,16 @@ while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
   while ((MEM_RW(DMC_BASE, 0x10014))  !=1 ) ;  // STAT - wait until normal
 
 #if DMC_WCK_ALWAYS_ON
-  //MEM_RW(DMC_BASE, 0x10180) = (MEM_RW(DMC_BASE, 0x10180)|(0x1<<11)); // PWRCTL - selfref_sw=1 
-  MEM_RW(DMC_BASE, 0x10180) = (0x1<<11); // PWRCTL - selfref_sw=1 
+  //MEM_RW(DMC_BASE, 0x10180) = (MEM_RW(DMC_BASE, 0x10180)|(0x1<<11)); // PWRCTL - selfref_sw=1
+  MEM_RW(DMC_BASE, 0x10180) = (0x1<<11); // PWRCTL - selfref_sw=1
   while (((MEM_RW(DMC_BASE, 0x10014)) & 0x00000037) !=0x23 ) ; // STAT - wait until STAT.operating_mode=3b011 and STAT.selfref_type=2b10.
   MEM_RW(DMC_BASE, 0x10c80) = 0x00000000; // SWCTL -sw_done=0 Enable writes to quasi-dynamic registers outside reset.
-  MEM_RW(DMC_BASE, 0x10010) = 0x00000001; // MSTR4 - CH0 WCK Always on Mode Enable 
-  //MEM_RW(DMC_BASE, 0x11010) = 0x00000001; // MSTR4 - CH1 WCK Always on Mode Enable 
+  MEM_RW(DMC_BASE, 0x10010) = 0x00000001; // MSTR4 - CH0 WCK Always on Mode Enable
+  //MEM_RW(DMC_BASE, 0x11010) = 0x00000001; // MSTR4 - CH1 WCK Always on Mode Enable
   MEM_RW(DMC_BASE, 0x10c80) = 0x00000001; // SWCTL - sw_done =1 Enable writes to quasi-dynamic registers outside reset.
   while ((MEM_RW(DMC_BASE, 0x10c84)) != 0x00000001); // SWSTAT-sw_done_ack=1 propagtes to ack
-  MEM_RW(DMC_BASE, 0x10180) = (0x0<<11); // PWRCTL - selfref_sw=1 
-  //((MEM_RW(DMC_BASE, 0x10180)) | (0x0<<11)); // PWRCTL - selfref_sw=0 
+  MEM_RW(DMC_BASE, 0x10180) = (0x0<<11); // PWRCTL - selfref_sw=1
+  //((MEM_RW(DMC_BASE, 0x10180)) | (0x0<<11)); // PWRCTL - selfref_sw=0
   while (((MEM_RW(DMC_BASE, 0x10014)) & 0x00000007) !=0x1 ) ; // STAT - wait until STAT.operating_mode=3b011 and STAT.selfref_type=2b10.
   //while ((MEM_RW(DMC_BASE, 0x10014))  !=1 ) ;  // STAT - wait until normal
 #endif
diff --git a/module/snps_umctl/include/DWC_ddrctl_lpddr5_init_regs.h b/module/snps_umctl/include/DWC_ddrctl_lpddr5_init_regs.h
index 1c9d5701..79a309d5 100644
--- a/module/snps_umctl/include/DWC_ddrctl_lpddr5_init_regs.h
+++ b/module/snps_umctl/include/DWC_ddrctl_lpddr5_init_regs.h
@@ -13,7 +13,7 @@ MEM_RW(DMC_BASE, 0x010308)  = 0x00000000; //DQSOSCCFG0 // kispet01: Do we need d
 MEM_RW(DMC_BASE, 0x010380)  = 0xc000201c; //SCHED0 - opt_vprw_sch=1, dis_speculative_act=1, lpr_num_entries=0x20, opt_wrcam_fill_level=1, rdwr_switch_policy_sel=1, pageclose=1
 MEM_RW(DMC_BASE, 0x010384)  = (UMCTL2_DELAY_SWITCH_WRITE << 12); //SCHED1
 MEM_RW(DMC_BASE, 0x01038c)  = (UMCTL2_RD_PGHIT_NUM_THRESH << 24) | (UMCTL2_WR_PGHIT_NUM_THRESH << 16) |
-      	      	      	      (UMCTL2_WRCAM_HIGHTHRESH << 8)     | UMCTL2_WRCAM_LOWTHRESH;
+                              (UMCTL2_WRCAM_HIGHTHRESH << 8)     | UMCTL2_WRCAM_LOWTHRESH;
 MEM_RW(DMC_BASE, 0x010390)  = (UMCTL2_WR_ACT_GAP << 8)           | UMCTL2_RD_ACT_GAP;
 MEM_RW(DMC_BASE, 0x010c80)  = 0x00000001; // SWCTL - Enable writes to quasi-dynamic registers outside reset.
 MEM_RW(DMC_BASE, 0x010c94)  = 0x00000001; // DBICTL //Enabling DM for Masked Writes
@@ -32,20 +32,20 @@ MEM_RW(DMC_BASE, 0x010c94)  = 0x00000001; // DBICTL //Enabling DM for Masked Wri
 
 MEM_RW(DMC_BASE, 0x010d04)  = 0x00010000; //INITTMG1 - Number of cycles for SDRAM reset, dram_rstn_x1024=0x1
 
-// System Address to SDRAM Address mapping 
+// System Address to SDRAM Address mapping
 // Memory configuraton - 8GB (4DFI X 2GB)
 // 2GB per DFI, 2GB = 2Ranks X 1GB, 1GB = 8Gb (x16,4B/4BG mode,10columns,15rows -> 32MbX16DQX4BGX4B)
 // x reperesents the bits that gets removed or are dont care in each stage
 // ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
-// AXI(40Bits) - System Address            | 39 | 38 | 37 | 36 | 35 | 34 | 33 | 32 | 31 | 30 | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |   
+// AXI(40Bits) - System Address            | 39 | 38 | 37 | 36 | 35 | 34 | 33 | 32 | 31 | 30 | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |
 // ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
 // AXI(33Bits) - 8GB (4DFI X 2GB)          | x  | x  | x  | x  | x  | x  | x  | 32 | 31 | 30 | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |
 // ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
-// AXI(31Bits) - 2GB per DFI (2ranksX1GB)  | x  | x  | x  | x  | x  | x  | x  | 32 | 31 | 30 | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 |  x |  x |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |  Addr[9:8] removed to account for channel striping by interconnect  
+// AXI(31Bits) - 2GB per DFI (2ranksX1GB)  | x  | x  | x  | x  | x  | x  | x  | 32 | 31 | 30 | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 |  x |  x |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |  Addr[9:8] removed to account for channel striping by interconnect
 // ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
 // AXI(31Bits) -                           | x  | x  | x  | x  | x  | x  | x  | 30 | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  x |  x |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |
 // ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
-// AXI(30Bits) - post SDRAM beat alignment | x  | x  | x  | x  | x  | x  | x  | 32 | 31 | 30 | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 |  x |  x |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  x |   
+// AXI(30Bits) - post SDRAM beat alignment | x  | x  | x  | x  | x  | x  | x  | 32 | 31 | 30 | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 |  x |  x |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  x |
 // ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
 // HIF(30Bits) -                           | x  | x  | x  | x  | x  | x  | x  | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  7 |  x |  x |  6 |  5 |  4 |  3 |  2 |  1 |  0 | x  |  LSB bit removed for SDRAM Beat size (2Bytes) alignment
 // ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
@@ -58,10 +58,10 @@ MEM_RW(DMC_BASE, 0x010d04)  = 0x00010000; //INITTMG1 - Number of cycles for SDRA
 // Below registers are used to map the HIF address to SDRAM address
 MEM_RW(DMC_BASE, 0x030004)  = 0x3f3f1f08; //ADDRMAP1  (addrmap_cs_b3_0)         ->  addrmap_cs_b3 = 0x3f(unused), addrmap_cs_b2 = 0x3f(unused), addrmap_cs_b1 = 0x3f(unused), addrmap_cs_b0 = (14[HIF] - 6[base]) = 0x8
 MEM_RW(DMC_BASE, 0x03000c)  = 0x3f3f0707; //ADDRMAP3  (addrmap_bank_b2_0)       ->  addrmap_bank_b2 = 0x3f(unused), addrmap_bank_b1 = (11[HIF] - 4[base]) = 0x07, addrmap_bank_b0 = (10[HIF] - 3[base]) = 0x07
-MEM_RW(DMC_BASE, 0x030010)  = 0x003f0909; //ADDRMAP4  (addrmap_bank_bg_b2_0)    ->  addrmap_bank_bg_b2 = unused, addrmap_bank_bg_b1 = (13[HIF] - 4[base]) = 0x09, addrmap_bank_bg_b0 = (12[HIF] - 3[base]) = 0x09 
+MEM_RW(DMC_BASE, 0x030010)  = 0x003f0909; //ADDRMAP4  (addrmap_bank_bg_b2_0)    ->  addrmap_bank_bg_b2 = unused, addrmap_bank_bg_b1 = (13[HIF] - 4[base]) = 0x09, addrmap_bank_bg_b0 = (12[HIF] - 3[base]) = 0x09
 MEM_RW(DMC_BASE, 0x030014)  = 0x1f000000; //ADDRMAP5  (addrmap_col_b10_7)       ->  addrmap_col_b10 = 0x1f(unused), addrmap_col_b9 = (9[HIF] - 9[base]) = 0x00, addrmap_col_b8 = (8[HIF] - 8[base]) = 0x00, addrmap_col_b7 = (7[HIF] - 7[base]) = 0x00
 MEM_RW(DMC_BASE, 0x030018)  = 0x00000000; //ADDRMAP6  (addrmap_col_b6_3)        ->  addrmap_col_b6 = (6[HIF] - 6[base]) = 0x00, addrmap_col_b5 = (5[HIF] - 5[base]) = 0x00, addrmap_col_b4 = (5[HIF] - 5[base]) = 0x00, addrmap_col_b4 = (4[HIF] - 4[base]) = 0x00
-MEM_RW(DMC_BASE, 0x03001c)  = 0x1f1f1f09; //ADDRMAP7  (addrmap_row_b17_14)      ->  addrmap_row_b17 = 0x1f(unused), addrmap_row_b16 = 0x1f(unused), addrmap_row_b15 = 0x1f(unused), addrmap_row_b14 = (29[HIF] - 20[base]) = 0x09  
+MEM_RW(DMC_BASE, 0x03001c)  = 0x1f1f1f09; //ADDRMAP7  (addrmap_row_b17_14)      ->  addrmap_row_b17 = 0x1f(unused), addrmap_row_b16 = 0x1f(unused), addrmap_row_b15 = 0x1f(unused), addrmap_row_b14 = (29[HIF] - 20[base]) = 0x09
 MEM_RW(DMC_BASE, 0x030020)  = 0x09090909; //ADDRMAP8  (addrmap_row_b13_10)      ->  addrmap_row_b13 = (28[HIF] - 19[base]) = 0x09, addrmap_row_b12 = (27[HIF] - 18[base]) = 0x09, addrmap_row_b11 = (26[HIF] - 17[base]) = 0x09, addrmap_row_b10 = (25[HIF] - 16[base]) = 0x09
 MEM_RW(DMC_BASE, 0x030024)  = 0x09090909; //ADDRMAP9  (addrmap_row_b9_6)        ->  addrmap_row_b9 = (24[HIF] - 15[base]) = 0x09, addrmap_row_b8 = (23[HIF] - 14[base]) = 0x09, addrmap_row_b7 = (22[HIF] - 13[base]) = 0x09, addrmap_row_b6 = (21[HIF] - 12[base]) = 0x09
 MEM_RW(DMC_BASE, 0x030028)  = 0x09090909; //ADDRMAP10 (addrmap_row_b5_2)        ->  addrmap_row_b5 = (20[HIF] - 11[base]) = 0x09, addrmap_row_b4 = (19[HIF] - 10[base]) = 0x09, addrmap_row_b3 = (18[HIF] - 9[base]) = 0x09, addrmap_row_b2 = (17[HIF] - 8[base]) = 0x09
@@ -76,7 +76,7 @@ MEM_RW(DMC_BASE, 0x020098)  = 0x061f00fc; //PCFGQOS1
 MEM_RW(DMC_BASE, 0x02009c)  = 0x01010e0b; //PCFGWQOS0
 MEM_RW(DMC_BASE, 0x0200a0)  = 0x05540678; //PCFGWQOS1
 
-// Note: Carry forward from lpddr4, Need to revisit this. 
+// Note: Carry forward from lpddr4, Need to revisit this.
 // ARM Standard address map passthrough
 MEM_RW(DMC_BASE, 0x020114)  = 0x00000000; //PSTAT
 MEM_RW(DMC_BASE, 0x021004)  = 0x00006000; //PCFGR
@@ -133,56 +133,69 @@ MEM_RW(DMC_BASE, 0x021090)  = 0x00000001; //PCTRL - Enable AXI Port 1
 #else
 #include <phy_registers.h>
 #include <snps_defines.h>
+
+
+// COMMENT THIS OUT IF YOU DON'T WANT THE BONUS PERF STUFF************************************************
+#define UMCTL5_SCHEDTMG0                   0x00c00
+#define UMCTL5_PERFHPR1                    0x00c80
+#define UMCTL5_PERFLPR1                    0x00c84
+#define UMCTL5_PERFWR1                     0x00c88
+// COMMENT THIS OUT IF YOU DON'T WANT THE BONUS PERF STUFF************************************************
+ MEM_RW(DMC_BASE, UMCTL5_PERFHPR1)  = (UMCTL_HPR_XACT_RUN_LENGTH << 24) | (UMCTL_HPR_STARVE);
+ MEM_RW(DMC_BASE, UMCTL5_PERFLPR1)  = (UMCTL_LPR_XACT_RUN_LENGTH << 24) | (UMCTL_LPR_STARVE);
+ MEM_RW(DMC_BASE, UMCTL5_PERFWR1)  = (UMCTL_WR_XACT_RUN_LENGTH  << 24) | (UMCTL_WR_STARVE);
+// COMMENT THIS OUT IF YOU DON'T WANT THE BONUS PERF STUFF************************************************
+
   MEM_RW(DMC_BASE, 0x10000) = 0x03080008; // MSTR0 - x16 device/LPDDR5/2Rank/BL16
   MEM_RW(DMC_BASE, 0x10200) = 0x00000100; // RFSHMOD0  - refresh burst x8
   MEM_RW(DMC_BASE, 0x10280) = 0x80000000; // ZQCTL0    - disable zq
-  MEM_RW(DMC_BASE, 0x10288) = 0x00000001; // ZQCTL2    - 
-  MEM_RW(DMC_BASE, 0x10380) = (1<<31)  | (1<<16) | ( UMCTL_LPR_NUM_ENTRIES << 8) | (UMCTL_OPT_WRCAM_FILL_LEVEL << 4) | 
-      	      	      	      (UMCTL_ENHANCED_RW << 3) | ((UMCTL_PC_TIMER!=-1)?(1<<2):0)  | 0x1; // SCHED0  
-  MEM_RW(DMC_BASE, 0x10384) = (UMCTL_PAGE_HIT_LIMIT_RD << 28) | (UMCTL_PAGE_HIT_LIMIT_WR << 24) | 
-      	      	      	      (UMCTL_WINDOW_LIMIT_RD << 20) | (UMCTL_WINDOW_LIMIT_WR << 16) | 
-			      (UMCTL_DELAY_SWITCH_WRITE << 12); // SCHED1
-  MEM_RW(DMC_BASE, 0x1038C) = (UMCTL_RD_PGHIT_NUM_THRESH << 24) | (UMCTL_WR_PGHIT_NUM_THRESH << 16) | 
-      	      	      	    (UMCTL_WRCAM_HIGHTHRESH << 8) | UMCTL_WRCAM_LOWTHRESH; //0x4040208; // SCHED3   - wrcam_highthresh=2 wrcam_lowthresh=32
+  MEM_RW(DMC_BASE, 0x10288) = 0x00000001; // ZQCTL2    -
+  MEM_RW(DMC_BASE, 0x10380) = (1<<31)  | (1<<16) | ( UMCTL_LPR_NUM_ENTRIES << 8) | (UMCTL_OPT_WRCAM_FILL_LEVEL << 4) |
+                              (UMCTL_ENHANCED_RW << 3) | ((UMCTL_PC_TIMER!=-1)?(1<<2):0)  | 0x1; // SCHED0
+  MEM_RW(DMC_BASE, 0x10384) = (UMCTL_PAGE_HIT_LIMIT_RD << 28) | (UMCTL_PAGE_HIT_LIMIT_WR << 24) |
+                              (UMCTL_WINDOW_LIMIT_RD << 20) | (UMCTL_WINDOW_LIMIT_WR << 16) |
+            (UMCTL_DELAY_SWITCH_WRITE << 12); // SCHED1
+  MEM_RW(DMC_BASE, 0x1038C) = (UMCTL_RD_PGHIT_NUM_THRESH << 24) | (UMCTL_WR_PGHIT_NUM_THRESH << 16) |
+                            (UMCTL_WRCAM_HIGHTHRESH << 8) | UMCTL_WRCAM_LOWTHRESH; //0x4040208; // SCHED3   - wrcam_highthresh=2 wrcam_lowthresh=32
 MEM_RW(DMC_BASE, 0x10390) = (8<<24) | (0x40<<16) | (UMCTL_WR_ACT_GAP << 8)           | UMCTL_RD_ACT_GAP; // SCHED4   - wr_page_exp=8 rd_pageexp=64 wractgap=0 rdactgap=0
 
   MEM_RW(DMC_BASE, 0xc00) = (UMCTL_RDWR_IDLE_GAP << 8) |((UMCTL_PC_TIMER!=-1)? UMCTL_PC_TIMER:0); //0x83c0810 // SCHEDTMG0
   MEM_RW(DMC_BASE, 0x10c90) = 0x0000f00f; // RANKCTL   - maxwr = f maxrd = f
-  MEM_RW(DMC_BASE, 0x10d00) = 0x00000000; // INITTMG0 - [0] - 1 pre/post =0 
+  MEM_RW(DMC_BASE, 0x10d00) = 0x00000000; // INITTMG0 - [0] - 1 pre/post =0
   MEM_RW(DMC_BASE, 0x00d00) = 0x00000001; // TMGCFG - [0] - Freq ratio 4
   MEM_RW(DMC_BASE, 0x10508) = 0xc0000000; // DFIUPD0   - dis_auto_ctrlup
   MEM_RW(DMC_BASE, 0x00600) = 0x82100186; // RFSHSET1TMG0 - t_refi_x1_sel = 1 refresh_margin=2 refresh_to_x1_x32=16 t_refi_x1_x32=390
   MEM_RW(DMC_BASE, 0x00604) = 0x00000070; // RFSHSET1TMG1 - t_rfc_min = 112
-  MEM_RW(DMC_BASE, 0x00608) = 0x06480000; // RFSHSET1TMG2 - t_pbr2act = 6 t_pbr2pbr = 72 
+  MEM_RW(DMC_BASE, 0x00608) = 0x06480000; // RFSHSET1TMG2 - t_pbr2act = 6 t_pbr2pbr = 72
 
 //#if DMC_BANK_STRIPE == 32
-//  MEM_RW(DMC_BASE, 0x30018) = 0x02020200; // ADDRMAP6 - addrmap_col_b[6:3]   = 1 + 0 + 2  + [6:3]   = [9:7,4]  
-//  MEM_RW(DMC_BASE, 0x30014) = 0x1f020202; // ADDRMAP5 - addrmap_col_b[10:7]  = 1 + 0 + 2  + [9:7]   = [12:10]  
+//  MEM_RW(DMC_BASE, 0x30018) = 0x02020200; // ADDRMAP6 - addrmap_col_b[6:3]   = 1 + 0 + 2  + [6:3]   = [9:7,4]
+//  MEM_RW(DMC_BASE, 0x30014) = 0x1f020202; // ADDRMAP5 - addrmap_col_b[10:7]  = 1 + 0 + 2  + [9:7]   = [12:10]
 //  MEM_RW(DMC_BASE, 0x30010) = 0x003f0101; // ADDRMAP4 - addrmap_bg_b[2:0]    = 1 + 3 + 1  + [1:0]   = [6:5]
 //  MEM_RW(DMC_BASE, 0x3000C) = 0x003f0909; // ADDRMAP3 - addrmap_bank_b[2:0]  = 1 + 3 + 9  + [1:0]   = [14:13]
 //#else
-//  MEM_RW(DMC_BASE, 0x30018) = 0x00000000; // ADDRMAP6 - addrmap_col_b[6:3]   = 1 + 0 + 0  + [6:3]   = [7:4]  
-//  MEM_RW(DMC_BASE, 0x30014) = 0x1f000000; // ADDRMAP5 - addrmap_col_b[10:7]  = 1 + 0 + 0  + [9:7]   = [10:8]  
+//  MEM_RW(DMC_BASE, 0x30018) = 0x00000000; // ADDRMAP6 - addrmap_col_b[6:3]   = 1 + 0 + 0  + [6:3]   = [7:4]
+//  MEM_RW(DMC_BASE, 0x30014) = 0x1f000000; // ADDRMAP5 - addrmap_col_b[10:7]  = 1 + 0 + 0  + [9:7]   = [10:8]
 //  MEM_RW(DMC_BASE, 0x30010) = 0x003f0707; // ADDRMAP4 - addrmap_bg_b[2:0]    = 1 + 3 + 7  + [1:0]   = [12:11]
 //  MEM_RW(DMC_BASE, 0x3000C) = 0x003f0909; // ADDRMAP3 - addrmap_bank_b[2:0]  = 1 + 3 + 9  + [1:0]   = [14:13]
 //#endif
 //  // RCB SDRAM address map =  log2(DATA_WIDTH) + base + offset
-//  MEM_RW(DMC_BASE, 0x30004) = 0x3f3f1f08; // ADDRMAP1 - addrmap_cs_b0	     = 1 + 6 + 8  + [0]     = [15]
+//  MEM_RW(DMC_BASE, 0x30004) = 0x3f3f1f08; // ADDRMAP1 - addrmap_cs_b0      = 1 + 6 + 8  + [0]     = [15]
 //  MEM_RW(DMC_BASE, 0x3002C) = 0x00000909; // ADDRMAP11- addrmap_row_b[1:0]   = 1 + 6 + 9  + [1:0]   = [17:16]
 //  MEM_RW(DMC_BASE, 0x30028) = 0x09090909; // ADDRMAP10- addrmap_row_b[5:2]   = 1 + 6 + 9  + [5:2]   = [21:18]
 //  MEM_RW(DMC_BASE, 0x30024) = 0x09090909; // ADDRMAP9 - addrmap_row_b[9:6]   = 1 + 6 + 9  + [9:6]   = [25:22]
 //#if DMC_ROW_BITS+11 == 11
 //  MEM_RW(DMC_BASE, 0x30020) = 0x1f1f1f09; // ADDRMAP8 - addrmap_row_b[13:10] = 1 + 6 + 9  + [10]    = [26]
-//  MEM_RW(DMC_BASE, 0x3001C) = 0x1f1f1f1f; // ADDRMAP7 - addrmap_row_b[17:14] = 1 + 6 + 9  +         = 
+//  MEM_RW(DMC_BASE, 0x3001C) = 0x1f1f1f1f; // ADDRMAP7 - addrmap_row_b[17:14] = 1 + 6 + 9  +         =
 //#elif DMC_ROW_BITS+11 == 12
 //  MEM_RW(DMC_BASE, 0x30020) = 0x1f1f0909; // ADDRMAP8 - addrmap_row_b[13:10] = 1 + 6 + 9  + [11:10] = [27:26]
-//  MEM_RW(DMC_BASE, 0x3001C) = 0x1f1f1f1f; // ADDRMAP7 - addrmap_row_b[17:14] = 1 + 6 + 9  +         = 
+//  MEM_RW(DMC_BASE, 0x3001C) = 0x1f1f1f1f; // ADDRMAP7 - addrmap_row_b[17:14] = 1 + 6 + 9  +         =
 //#elif DMC_ROW_BITS+11 == 13
 //  MEM_RW(DMC_BASE, 0x30020) = 0x1f090909; // ADDRMAP8 - addrmap_row_b[13:10] = 1 + 6 + 9  + [12:10] = [28:26]
-//  MEM_RW(DMC_BASE, 0x3001C) = 0x1f1f1f1f; // ADDRMAP7 - addrmap_row_b[17:14] = 1 + 6 + 9  +          = 
+//  MEM_RW(DMC_BASE, 0x3001C) = 0x1f1f1f1f; // ADDRMAP7 - addrmap_row_b[17:14] = 1 + 6 + 9  +          =
 //#elif DMC_ROW_BITS+11 == 14
 //  MEM_RW(DMC_BASE, 0x30020) = 0x09090909; // ADDRMAP8 - addrmap_row_b[13:10] = 1 + 6 + 9  + [13:10] = [29:26]
-//  MEM_RW(DMC_BASE, 0x3001C) = 0x1f1f1f1f; // ADDRMAP7 - addrmap_row_b[17:14] = 1 + 6 + 9  +         = 
+//  MEM_RW(DMC_BASE, 0x3001C) = 0x1f1f1f1f; // ADDRMAP7 - addrmap_row_b[17:14] = 1 + 6 + 9  +         =
 //#elif DMC_ROW_BITS+11 == 15
 //  MEM_RW(DMC_BASE, 0x30020) = 0x09090909; // ADDRMAP8 - addrmap_row_b[13:10] = 1 + 6 + 9  + [13:10] = [29:26]
 //  MEM_RW(DMC_BASE, 0x3001C) = 0x1f1f1f09; // ADDRMAP7 - addrmap_row_b[17:14] = 1 + 6 + 9  + [14]    = [30]
@@ -190,16 +203,16 @@ MEM_RW(DMC_BASE, 0x10390) = (8<<24) | (0x40<<16) | (UMCTL_WR_ACT_GAP << 8)
 //  MEM_RW(DMC_BASE, 0x30020) = 0x09090909; // ADDRMAP8 - addrmap_row_b[13:10] = 1 + 6 + 9  + [13:10] = [29:26]
 //  MEM_RW(DMC_BASE, 0x3001C) = 0x1f1f0909; // ADDRMAP7 - addrmap_row_b[17:14] = 1 + 6 + 9  + [15:14] = [31:30]
 //#endif
-  
+
 // Below registers are used to map the HIF address to SDRAM address
 MEM_RW(DMC_BASE, 0x030004)  = 0x3f3f3f08; //ADDRMAP1  (addrmap_cs_b3_0)         ->  addrmap_cs_b3 = 0x3f(unused), addrmap_cs_b2 = 0x3f(unused), addrmap_cs_b1 = 0x3f(unused), addrmap_cs_b0 = (14[HIF] - 6[base]) = 0x8
 //MEM_RW(DMC_BASE, 0x03000c)  = 0x3f3f0707; //ADDRMAP3  (addrmap_bank_b2_0)       ->  addrmap_bank_b2 = 0x3f(unused), addrmap_bank_b1 = (11[HIF] - 4[base]) = 0x07, addrmap_bank_b0 = (10[HIF] - 3[base]) = 0x07
-//MEM_RW(DMC_BASE, 0x030010)  = 0x003f0909; //ADDRMAP4  (addrmap_bank_bg_b2_0)    ->  addrmap_bank_bg_b2 = unused, addrmap_bank_bg_b1 = (13[HIF] - 4[base]) = 0x09, addrmap_bank_bg_b0 = (12[HIF] - 3[base]) = 0x09 
+//MEM_RW(DMC_BASE, 0x030010)  = 0x003f0909; //ADDRMAP4  (addrmap_bank_bg_b2_0)    ->  addrmap_bank_bg_b2 = unused, addrmap_bank_bg_b1 = (13[HIF] - 4[base]) = 0x09, addrmap_bank_bg_b0 = (12[HIF] - 3[base]) = 0x09
 MEM_RW(DMC_BASE, 0x03000c)  = 0x003f0909; //ADDRMAP3  (addrmap_bank_b2_0)       ->  addrmap_bank_b2 = 0x3f(unused), addrmap_bank_b1 = (13[HIF] - 4[base]) = 0x09, addrmap_bank_b0 = (12[HIF] - 3[base]) = 0x09
 MEM_RW(DMC_BASE, 0x030010)  = 0x003f0707; //ADDRMAP4  (addrmap_bank_bg_b2_0)    ->  addrmap_bank_bg_b2 = unused, addrmap_bank_bg_b1 = (11[HIF] - 4[base]) = 0x07, addrmap_bank_bg_b0 = (10[HIF] - 3[base]) = 0x07
 MEM_RW(DMC_BASE, 0x030014)  = 0x1f000000; //ADDRMAP5  (addrmap_col_b10_7)       ->  addrmap_col_b10 = 0x1f(unused), addrmap_col_b9 = (9[HIF] - 9[base]) = 0x00, addrmap_col_b8 = (8[HIF] - 8[base]) = 0x00, addrmap_col_b7 = (7[HIF] - 7[base]) = 0x00
 MEM_RW(DMC_BASE, 0x030018)  = 0x00000000; //ADDRMAP6  (addrmap_col_b6_3)        ->  addrmap_col_b6 = (6[HIF] - 6[base]) = 0x00, addrmap_col_b5 = (5[HIF] - 5[base]) = 0x00, addrmap_col_b4 = (5[HIF] - 5[base]) = 0x00, addrmap_col_b4 = (4[HIF] - 4[base]) = 0x00
-MEM_RW(DMC_BASE, 0x03001c)  = 0x1f1f1f09; //ADDRMAP7  (addrmap_row_b17_14)      ->  addrmap_row_b17 = 0x1f(unused), addrmap_row_b16 = 0x1f(unused), addrmap_row_b15 = 0x1f(unused), addrmap_row_b14 = (29[HIF] - 20[base]) = 0x09  
+MEM_RW(DMC_BASE, 0x03001c)  = 0x1f1f0909; //ADDRMAP7  (addrmap_row_b17_14)      ->  addrmap_row_b17 = 0x1f(unused), addrmap_row_b16 = 0x1f(unused), addrmap_row_b15 = 0x1f(unused), addrmap_row_b14 = (29[HIF] - 20[base]) = 0x09
 MEM_RW(DMC_BASE, 0x030020)  = 0x09090909; //ADDRMAP8  (addrmap_row_b13_10)      ->  addrmap_row_b13 = (28[HIF] - 19[base]) = 0x09, addrmap_row_b12 = (27[HIF] - 18[base]) = 0x09, addrmap_row_b11 = (26[HIF] - 17[base]) = 0x09, addrmap_row_b10 = (25[HIF] - 16[base]) = 0x09
 MEM_RW(DMC_BASE, 0x030024)  = 0x09090909; //ADDRMAP9  (addrmap_row_b9_6)        ->  addrmap_row_b9 = (24[HIF] - 15[base]) = 0x09, addrmap_row_b8 = (23[HIF] - 14[base]) = 0x09, addrmap_row_b7 = (22[HIF] - 13[base]) = 0x09, addrmap_row_b6 = (21[HIF] - 12[base]) = 0x09
 MEM_RW(DMC_BASE, 0x030028)  = 0x09090909; //ADDRMAP10 (addrmap_row_b5_2)        ->  addrmap_row_b5 = (20[HIF] - 11[base]) = 0x09, addrmap_row_b4 = (19[HIF] - 10[base]) = 0x09, addrmap_row_b3 = (18[HIF] - 9[base]) = 0x09, addrmap_row_b2 = (17[HIF] - 8[base]) = 0x09
@@ -257,7 +270,7 @@ MEM_RW(DMC_BASE, 0x00594)  = 0x04100006; //DFITMG5
   MEM_RW(DMC_BASE, 0x200a0+0x1000*1)  = UMCTL_VP_WTIMEOUT;  // WQOS region2>0 region1>0
   MEM_RW(DMC_BASE, 0x20004+0x1000*0)  = 0x000143ff;  // RQOS region2>d region1>8
   MEM_RW(DMC_BASE, 0x20004+0x1000*1)  = 0x000153ff;  // RQOS region2>d region1>8
-#endif  
+#endif
   // Enable AXI Ports
   MEM_RW(DMC_BASE, 0x20090+0x1000*0)  = 0x000000001;  // PCTRL_0 - [0] - 1 AXI PORT enable
   MEM_RW(DMC_BASE, 0x20090+0x1000*1)  = 0x000000001;  // PCTRL_0 - [0] - 1 AXI PORT enable
diff --git a/module/snps_umctl/include/snps_defines.h b/module/snps_umctl/include/snps_defines.h
index 43ac5b52..c2fec991 100644
--- a/module/snps_umctl/include/snps_defines.h
+++ b/module/snps_umctl/include/snps_defines.h
@@ -1,9 +1,37 @@
 
-#ifndef LPDDR5
+#ifdef SNPS_VIP_FW
 
 #ifndef UMCTL2_DEFINES_H
 #define UMCTL2_DEFINES_H
 
+
+#ifndef UMCTL_HPR_STARVE
+#define UMCTL_HPR_STARVE 0x1 // reset value
+#endif
+
+#ifndef UMCTL_HPR_XACT_RUN_LENGTH
+#define UMCTL_HPR_XACT_RUN_LENGTH 0xf // reset value
+#endif
+
+//PERFLPR1
+#ifndef UMCTL_LPR_STARVE
+#define UMCTL_LPR_STARVE 0x1ff // reset value
+#endif
+
+#ifndef UMCTL_LPR_XACT_RUN_LENGTH
+#define UMCTL_LPR_XACT_RUN_LENGTH 0x40 // reset value
+#endif
+
+//PERFWR1
+#ifndef UMCTL_WR_STARVE
+#define UMCTL_WR_STARVE 0x3ff // reset value
+#endif
+
+#ifndef UMCTL_WR_XACT_RUN_LENGTH
+#define UMCTL_WR_XACT_RUN_LENGTH 0x10 // reset value
+#endif
+
+
 #ifndef UMCTL2_RDWR_IDLE_GAP
 #define UMCTL2_RDWR_IDLE_GAP 0
 #endif
@@ -117,6 +145,32 @@
 #define UMCTL_PC_TIMER 0x20
 #endif
 
+#ifndef UMCTL_HPR_STARVE
+#define UMCTL_HPR_STARVE 0x1 // reset value
+#endif
+
+#ifndef UMCTL_HPR_XACT_RUN_LENGTH
+#define UMCTL_HPR_XACT_RUN_LENGTH 0xf // reset value
+#endif
+
+//PERFLPR1
+#ifndef UMCTL_LPR_STARVE
+#define UMCTL_LPR_STARVE 0x1ff // reset value
+#endif
+
+#ifndef UMCTL_LPR_XACT_RUN_LENGTH
+#define UMCTL_LPR_XACT_RUN_LENGTH 0x40 // reset value
+#endif
+
+//PERFWR1
+#ifndef UMCTL_WR_STARVE
+#define UMCTL_WR_STARVE 0x3ff // reset value
+#endif
+
+#ifndef UMCTL_WR_XACT_RUN_LENGTH
+#define UMCTL_WR_XACT_RUN_LENGTH 0x10 // reset value
+#endif
+
 #ifndef UMCTL_FORCE_LOW_PRI
 #define UMCTL_FORCE_LOW_PRI 1
 #endif
-- 
2.25.1

