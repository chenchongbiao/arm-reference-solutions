From facca2708c038659220d7f89de700027c1266db3 Mon Sep 17 00:00:00 2001
From: Ben Horgan <ben.horgan@arm.com>
Date: Tue, 20 Sep 2022 10:42:08 +0100
Subject: [PATCH 12/18] tc2 fpga: ddr update

Change-Id: I3fadd2fb9f760ae600c35d59ce60a4b70503ca59
Signed-off-by: Ben Horgan <ben.horgan@arm.com>
---
 module/snps_umctl/CMakeLists.txt              |  17 +
 module/snps_umctl/Module.cmake                |   9 +
 .../include/DWC_ddrctl_lpddr5_init_mem.h      | 577 ++++--------------
 .../include/DWC_ddrctl_lpddr5_init_regs.h     | 456 ++++++--------
 module/snps_umctl/include/snps_defines.h      | 214 ++-----
 module/snps_umctl/include/test_defs.h         |  50 +-
 module/snps_umctl/include/umctl5_registers.h  | 335 ++++++++++
 module/snps_umctl/src/mod_snps_umctl.c        |  59 +-
 product/tc2/include/scp_css_mmap.h            |  13 +
 9 files changed, 825 insertions(+), 905 deletions(-)
 create mode 100644 module/snps_umctl/CMakeLists.txt
 create mode 100644 module/snps_umctl/Module.cmake
 create mode 100644 module/snps_umctl/include/umctl5_registers.h
 create mode 100644 product/tc2/include/scp_css_mmap.h

diff --git a/module/snps_umctl/CMakeLists.txt b/module/snps_umctl/CMakeLists.txt
new file mode 100644
index 00000000..d94c13cc
--- /dev/null
+++ b/module/snps_umctl/CMakeLists.txt
@@ -0,0 +1,17 @@
+#
+# Arm SCP/MCP Software
+# Copyright (c) 2022, Arm Limited and Contributors. All rights reserved.
+#
+# SPDX-License-Identifier: BSD-3-Clause
+#
+
+add_library(${SCP_MODULE_TARGET} SCP_MODULE)
+
+target_include_directories(${SCP_MODULE_TARGET}
+                           PUBLIC "${CMAKE_CURRENT_SOURCE_DIR}/include")
+
+target_sources(${SCP_MODULE_TARGET}
+               PRIVATE "${CMAKE_CURRENT_SOURCE_DIR}/src/mod_snps_umctl.c")
+
+target_link_libraries(${SCP_MODULE_TARGET} PRIVATE module-clock)
+
diff --git a/module/snps_umctl/Module.cmake b/module/snps_umctl/Module.cmake
new file mode 100644
index 00000000..24518037
--- /dev/null
+++ b/module/snps_umctl/Module.cmake
@@ -0,0 +1,9 @@
+#
+# Arm SCP/MCP Software
+# Copyright (c) 2022, Arm Limited and Contributors. All rights reserved.
+#
+# SPDX-License-Identifier: BSD-3-Clause
+#
+
+set(SCP_MODULE "snps-umctl")
+set(SCP_MODULE_TARGET "module-snps-umctl")
diff --git a/module/snps_umctl/include/DWC_ddrctl_lpddr5_init_mem.h b/module/snps_umctl/include/DWC_ddrctl_lpddr5_init_mem.h
index f34de59f..73f682e1 100644
--- a/module/snps_umctl/include/DWC_ddrctl_lpddr5_init_mem.h
+++ b/module/snps_umctl/include/DWC_ddrctl_lpddr5_init_mem.h
@@ -1,14 +1,3 @@
-
-#ifdef SNPS_VIP_FW
-// Phy and Memory initialization
-
-// Disable auto-refreshes, self-refresh, powerdown and assertion of dfi_dram_clk_disable by setting RFSHCTL0.dis_auto_refresh = 1, PWRCTL.powerdown_en = 0 and PWRCTL.selfref_en = 0 PWRCTL.en_dfi_dram_clk_disable = 0
-MEM_RW(DMC_BASE, 0x010208)  = 0x00000001; //RFSHCTL0
-MEM_RW(DMC_BASE, 0x010180)  = 0x00020200; //PWRCTL
-
-#ifndef DMC_BYPASS_PHY_INIT
-  // Set SWCTL.sw_done to 0
-  MEM_RW(DMC_BASE, 0x010c80)  = 0x00000000; //SWCTL
 #ifdef SNPS_VIP_FW
 // Phy and Memory initialization
 
@@ -27,30 +16,6 @@ MEM_RW(DMC_BASE, 0x010180)  = 0x00020200; //PWRCTL
   MEM_RW(DMC_BASE, 0x010c80)  = 0x00000001; //SWCTL
   while ((MEM_RW(DMC_BASE, 0x010c84)&0x1)  ==0 ); //SWSTAT
 
-  // PHY initialization.
-  // Start PHY initialization and training by accessing relevant PUB registers
-  // Not required in simulation now as we are using PHY VIP model
-  // For PHY models with configuration interface, do the PHY initilization here
-
-//  while ((MEM_RW(DMC_BASE, 0x18)&0x1)  ==1 );  // MRSTAT - wait busy
-//
-//  // Configure PHY
-////  MEM_RW(PHY_BASE,DMC620_PHY_INIT_COMPLETE)   = 0x00000001; //0x00
-//  MEM_RW(PHY_BASE,DMC620_PHY_READ_DELAY)      = 0x00000002; //0x08
-//  MEM_RW(PHY_BASE,DMC620_PHY_CAPTURE_MASK)    = 0x0000001f; //0x0C
-//  MEM_RW(PHY_BASE,DMC620_PHY_T_CONTROL_DELAY) = 0x00000000; //0x14
-//  MEM_RW(PHY_BASE,DMC620_PHY_WR_LATENCY)      = 0x01000000; //0x18
-//  MEM_RW(PHY_BASE,DMC620_PHY_RDDATA_EN)       = 0x00001a00; //0x1C
-//  MEM_RW(PHY_BASE,DMC620_PHY_RD_LATENCY)      = 0x00000016; //0x20
-//  MEM_RW(PHY_BASE,DMC620_PHY_CLP_ACK)         = 0x00641300; //0x30
-//  MEM_RW(PHY_BASE,0x04C)                      = 0x00000002; //0x4c PHY500_DFI_WR_PREMBL (0x58 DMC620_PHY_WR_PREMBL)
-//  MEM_RW(PHY_BASE,DMC620_PHY_DELAY_SEL)       = 0x0000000A; //0x820
-////  MEM_RW(PHY_BASE,DMC620_PHY_REF_EN)          = 0x00000000; //0x824
-//  MEM_RW(PHY_BASE,DMC620_PHY_T_CTRL_UPD_MIN)  = 0x00000000; //0x828
-
-//  while ((MEM_RW(DMC_BASE, 0x4)&0x1) != 1 );  // STAT - wait until normal
-
-//
   // Set SWCTL.sw_done to 0
   MEM_RW(DMC_BASE, 0x010c80)  = 0x00000000; //SWCTL
 
@@ -85,9 +50,10 @@ MEM_RW(DMC_BASE, 0x010180)  = 0x00020200; //PWRCTL
   // Set SWCTL.sw_done to 1 (Require polling SWSTAT.sw_done_ack after setting SWCTL.sw_done to 1
   MEM_RW(DMC_BASE, 0x010c80)  = 0x00000001; //SWCTL
   while ((MEM_RW(DMC_BASE, 0x010c84)&0x1)  ==0 ); //SWSTAT
+
 #else
   //##########################################################
-  // REVISIT [kispet01 @2020-03-02] This option is not yet tested. Remove this comment after completing the check
+  // This option is not tested, and hence may not work. 
   c_print_str("Warning: Bypassing PHY init sequence, this option is not tested and may not work as expected.\n");
   //##########################################################
   printf("Bypassed PHY initilization for DMC%0d\n",index);
@@ -115,49 +81,49 @@ MEM_RW(DMC_BASE, 0x010208)  = 0x00000000; //RFSHCTL0 - RFSHCTL0.dis_auto_refresh
 //MR18, Addr = 'h12, Data = 'h0, Rank 0
 while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
 MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00001200; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001210; //MRCTRL1 - Program MR Address and MR WData
 MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
 
 //MR18, Addr = 'h12, Data = 'h0, Rank 1
 while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
 MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00001200; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001210; //MRCTRL1 - Program MR Address and MR WData
 MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
 
-//MR1, Addr = 'h1, Data = 'hb0, Rank 0
+//MR1, Addr = 'h1, Data = 'h90, Rank 0 (WL=9)
 while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
 MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
 MEM_RW(DMC_BASE, 0x010084)  = 0x000001b0; //MRCTRL1 - Program MR Address and MR WData
 MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
 
-//MR1, Addr = 'h1, Data = 'hb0, Rank 1
+//MR1, Addr = 'h1, Data = 'h90, Rank 1 (WL=9)
 while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
 MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
 MEM_RW(DMC_BASE, 0x010084)  = 0x000001b0; //MRCTRL1 - Program MR Address and MR WData
 MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
 
-//MR2, Addr = 'h2, Data = 'hbb, Rank 0
+//MR2, Addr = 'h2, Data = 'hbb, Rank 0 (RL=17)
 while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
 MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x000002bb; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010084)  = 0x0000020b; //MRCTRL1 - Program MR Address and MR WData
 MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
 
-//MR2, Addr = 'h2, Data = 'hbb, Rank 1
+//MR2, Addr = 'h2, Data = 'hbb, Rank 1 (RL=17)
 while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
 MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x000002bb; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010084)  = 0x0000020b; //MRCTRL1 - Program MR Address and MR WData
 MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
 
 //MR3, Addr = 'h3, Data = 'h26, Rank 0
 while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
 MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00000326; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010084)  = 0x00000306; //MRCTRL1 - Program MR Address and MR WData
 MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
 
 //MR3, Addr = 'h3, Data = 'h26, Rank 1
 while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
 MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00000326; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010084)  = 0x00000306; //MRCTRL1 - Program MR Address and MR WData
 MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
 
 //MR10, Addr = 'ha, Data = 'h58, Rank 0
@@ -200,7 +166,7 @@ MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the
 while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
 MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
 //MEM_RW(DMC_BASE, 0x010084)  = 0x00000d21; //MRCTRL1 - Program MR Address and MR WData
-// Enabling DM for Masked Writes
+// Enabling DM for Masked Writes 
 MEM_RW(DMC_BASE, 0x010084)  = 0x00000d01; //MRCTRL1 - Program MR Address and MR WData
 MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
 
@@ -208,12 +174,12 @@ MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the
 while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
 MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
 //MEM_RW(DMC_BASE, 0x010084)  = 0x00000d21; //MRCTRL1 - Program MR Address and MR WData
-// Enabling DM for Masked Writes
+// Enabling DM for Masked Writes 
 MEM_RW(DMC_BASE, 0x010084)  = 0x00000d01; //MRCTRL1 - Program MR Address and MR WData
 MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
 
 // Note: Removing MR14, MR15 register writes to avoid tVREF related errors from VIP
-// Need to check with IP team to see if there is a way to control this timing
+// Need to check with IP team to see if there is a way to control this timing 
 ////MR14, Addr = 'he, Data = 'h15, Rank 0
 //while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
 //MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
@@ -358,441 +324,120 @@ MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
 MEM_RW(DMC_BASE, 0x010084)  = 0x00002840; //MRCTRL1 - Program MR Address and MR WData
 MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
 
+//Poll MRSTAT.mr_wr_busy until it is 0. This checks that there is no outstanding MR transaction
 //Poll MRSTAT.mr_wr_busy until it is 0. This checks that there is no outstanding MR transaction
 while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
 
 #endif // #ifndef DMC_SDRAM_MR_WRITES_EN
-#else
+#else //!SNPS_VIP_FW
+#ifdef SYSTEM_PIK_DMC_DATA_RESET_OFFSET
 #include <phy_registers.h>
-#include <snps_defines.h>
-  // Initialize the PHY Registers
-  MEM_RW(PHY_BASE,PHY_INIT_COMPLETE)   = 0x00000001; //0x00
-  MEM_RW(PHY_BASE, PHY_READ_DELAY)     = 0x00000001; //0x08
-  MEM_RW(PHY_BASE, PHY_CAPTURE_MASK)   = 0x00000003; //0x0C
-  MEM_RW(PHY_BASE, PHY_T_CTRL_DELAY)   = 0x0a000000; //0x14
-  MEM_RW(PHY_BASE, PHY_WR_LATENCY)     = 0x01000033; //0x18   // mask offset = 0 data offset =1
-  MEM_RW(PHY_BASE, PHY_RDDATA_EN)      = 0x00002400; //0x1C
-  MEM_RW(PHY_BASE, PHY_RD_LATENCY)     = 0x00000024; //0x20
-  MEM_RW(PHY_BASE, PHY_LP_ACK)         = 0x00030000; //0x30
-  MEM_RW(PHY_BASE, PHY_WR_PREMBL)      = 0x00000002; //0x58
-  MEM_RW(PHY_BASE, PHY_DELAY_SEL)      = 0x0000000d; //0x820
-  MEM_RW(PHY_BASE, PHY_REF_EN)         = 0x00000000; //0x824
-  MEM_RW(PHY_BASE, PHY_T_CTRL_UPD_MIN) = 0x00000000; //0x828
 
-  while ((MEM_RW(DMC_BASE, 0x10014))  !=1 ) ;  // STAT - wait until normal
 
-#if DMC_WCK_ALWAYS_ON
-  //MEM_RW(DMC_BASE, 0x10180) = (MEM_RW(DMC_BASE, 0x10180)|(0x1<<11)); // PWRCTL - selfref_sw=1
-  MEM_RW(DMC_BASE, 0x10180) = (0x1<<11); // PWRCTL - selfref_sw=1
-  while (((MEM_RW(DMC_BASE, 0x10014)) & 0x00000037) !=0x23 ) ; // STAT - wait until STAT.operating_mode=3b011 and STAT.selfref_type=2b10.
+    // Set PWRCTL.selfref_sw to 0
+  MEM_RW(DMC_BASE, 0x010180)  = 0x00000000; //PWRCTL
   MEM_RW(DMC_BASE, 0x10c80) = 0x00000000; // SWCTL -sw_done=0 Enable writes to quasi-dynamic registers outside reset.
-  MEM_RW(DMC_BASE, 0x10010) = 0x00000001; // MSTR4 - CH0 WCK Always on Mode Enable
-  //MEM_RW(DMC_BASE, 0x11010) = 0x00000001; // MSTR4 - CH1 WCK Always on Mode Enable
+  MEM_RW(DMC_BASE, 0x10510) = 0x00000011; // DFIMISC -- sorting the undocumented reset signal that exists in 1.21 version of the controller
   MEM_RW(DMC_BASE, 0x10c80) = 0x00000001; // SWCTL - sw_done =1 Enable writes to quasi-dynamic registers outside reset.
-  while ((MEM_RW(DMC_BASE, 0x10c84)) != 0x00000001); // SWSTAT-sw_done_ack=1 propagtes to ack
-  MEM_RW(DMC_BASE, 0x10180) = (0x0<<11); // PWRCTL - selfref_sw=1
-  //((MEM_RW(DMC_BASE, 0x10180)) | (0x0<<11)); // PWRCTL - selfref_sw=0
-  while (((MEM_RW(DMC_BASE, 0x10014)) & 0x00000007) !=0x1 ) ; // STAT - wait until STAT.operating_mode=3b011 and STAT.selfref_type=2b10.
-  //while ((MEM_RW(DMC_BASE, 0x10014))  !=1 ) ;  // STAT - wait until normal
-#endif
-
-//MRSTAT //MR2 WL =16 RL=17
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000030; //MRCTRL0 - Program the Rank#
-#if DMC_WCK_ALWAYS_ON
-    MEM_RW(DMC_BASE, 0x010084)  = 0x0000026b; //MRCTRL1 - Program MR Address and MR WData
-#else
-    MEM_RW(DMC_BASE, 0x010084)  = 0x0000029b; //MRCTRL1 - Program MR Address and MR WData
-#endif
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000030; //MRCTRL0 - Trigger MR Write from the controller
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 );
-//
-#endif
-
-
-  // Set DFIMISC.dfi_init_complete_en to 0
-  MEM_RW(DMC_BASE, 0x010510)  = 0x00000004; //DFIMISC
-
-  // Set SWCTL.sw_done to 1 (Require polling SWSTAT.sw_done_ack after setting SWCTL.sw_done to 1)
-  MEM_RW(DMC_BASE, 0x010c80)  = 0x00000001; //SWCTL
-  while ((MEM_RW(DMC_BASE, 0x010c84)&0x1)  ==0 ); //SWSTAT
-
-  // PHY initialization.
-  // Start PHY initialization and training by accessing relevant PUB registers
-  // Not required in simulation now as we are using PHY VIP model
-  // For PHY models with configuration interface, do the PHY initilization here
-
-//  while ((MEM_RW(DMC_BASE, 0x18)&0x1)  ==1 );  // MRSTAT - wait busy
-//
-//  // Configure PHY
-////  MEM_RW(PHY_BASE,DMC620_PHY_INIT_COMPLETE)   = 0x00000001; //0x00
-//  MEM_RW(PHY_BASE,DMC620_PHY_READ_DELAY)      = 0x00000002; //0x08
-//  MEM_RW(PHY_BASE,DMC620_PHY_CAPTURE_MASK)    = 0x0000001f; //0x0C
-//  MEM_RW(PHY_BASE,DMC620_PHY_T_CONTROL_DELAY) = 0x00000000; //0x14
-//  MEM_RW(PHY_BASE,DMC620_PHY_WR_LATENCY)      = 0x01000000; //0x18
-//  MEM_RW(PHY_BASE,DMC620_PHY_RDDATA_EN)       = 0x00001a00; //0x1C
-//  MEM_RW(PHY_BASE,DMC620_PHY_RD_LATENCY)      = 0x00000016; //0x20
-//  MEM_RW(PHY_BASE,DMC620_PHY_CLP_ACK)         = 0x00641300; //0x30
-//  MEM_RW(PHY_BASE,0x04C)                      = 0x00000002; //0x4c PHY500_DFI_WR_PREMBL (0x58 DMC620_PHY_WR_PREMBL)
-//  MEM_RW(PHY_BASE,DMC620_PHY_DELAY_SEL)       = 0x0000000A; //0x820
-////  MEM_RW(PHY_BASE,DMC620_PHY_REF_EN)          = 0x00000000; //0x824
-//  MEM_RW(PHY_BASE,DMC620_PHY_T_CTRL_UPD_MIN)  = 0x00000000; //0x828
-
-//  while ((MEM_RW(DMC_BASE, 0x4)&0x1) != 1 );  // STAT - wait until normal
-
-//
-  // Set SWCTL.sw_done to 0
-  MEM_RW(DMC_BASE, 0x010c80)  = 0x00000000; //SWCTL
-
-  // Set DFIMISC.dfi_init_start to 1
-  MEM_RW(DMC_BASE, 0x010510)  = 0x00000024; //DFIMISC
-
-  // Set SWCTL.sw_done to 1 (Require polling SWSTAT.sw_done_ack after setting SWCTL.sw_done to 1)
-  MEM_RW(DMC_BASE, 0x010c80)  = 0x00000001; //SWCTL
-  while ((MEM_RW(DMC_BASE, 0x010c84)&0x1)  ==0 ); //SWSTAT
-
-  // Poll DFISTAT.dfi_init_complete=1
-  while ((MEM_RW(DMC_BASE, 0x010514)&0x1)  ==0 ); //DFISTAT
-
-  // Set SWCTL.sw_done to 0
-  MEM_RW(DMC_BASE, 0x010c80)  = 0x00000000; //SWCTL
-
-  // Set DFIMISC.dfi_init_start to 0
-  MEM_RW(DMC_BASE, 0x010510)  = 0x00000004; //DFIMISC
-
-  // The following registers may need to be updated after training has completed:
-  // RANKTMG0.diff_rank_wr_gap
-  // RANKTMG0.diff_rank_rd_gap
-  // DRAMSET1TMG2.rd2wr
-  // DRAMSET1TMG2.wr2rd
-
-  // Set DFIMISC.dfi_init_complete_en to 1
-  MEM_RW(DMC_BASE, 0x010510)  = 0x00000005; //DFIMISC
-
-  // Set PWRCTL.selfref_sw to 0
-  MEM_RW(DMC_BASE, 0x010180)  = 0x00020200; //PWRCTL
-
-  // Set SWCTL.sw_done to 1 (Require polling SWSTAT.sw_done_ack after setting SWCTL.sw_done to 1
-  MEM_RW(DMC_BASE, 0x010c80)  = 0x00000001; //SWCTL
-  while ((MEM_RW(DMC_BASE, 0x010c84)&0x1)  ==0 ); //SWSTAT
-#else
-  //##########################################################
-  // REVISIT [kispet01 @2020-03-02] This option is not yet tested. Remove this comment after completing the check
-  c_print_str("Warning: Bypassing PHY init sequence, this option is not tested and may not work as expected.\n");
-  //##########################################################
-  printf("Bypassed PHY initilization for DMC%0d\n",index);
-#endif
-
-// Wait for DWC_ddrctl to move to normal operating mode by monitoring STAT.operating_mode signal
-while ((MEM_RW(DMC_BASE, 0x010014)&0x7)  !=1 ); //STAT
-
-// Revert back the below registers to the original values if desired
-// RFSHCTL0.dis_auto_refresh = 0, PWRCTL.powerdown_en = 0 and PWRCTL.selfref_en = 0 PWRTL.en_dfi_dram_clk_disable = 0
-MEM_RW(DMC_BASE, 0x010208)  = 0x00000000; //RFSHCTL0 - RFSHCTL0.dis_auto_refresh = 0
-
-// Note: Skipping frontdoor MR writes by default to reduce simulation time
-#ifdef DMC_SDRAM_MR_WRITES_EN
-// Initiate Mode Register Writes from the controller for SDRAM Memory
-// Software sequence for Mode register writes is as below:
-// 1. Poll MRSTAT.mr_wr_busy until it is 0. This checks that there is no outstanding MR transaction. No
-// writes must be performed to MRCTRL0 and MRCTRL1 if MRSTAT.mr_wr_busy = 1.
-// 2. Write the MRCTRL0.mr_type, MRCTRL0.mr_addr, MRCTRL0.mr_rank and (for MRWs)
-// MRCTRL1.mr_data to define the MR transaction.
-// 3. In a separate APB transaction, write the MRCTRL0.mr_wr to 1. This bit is self-clearing, and triggers the
-// MR transaction. The DDRCTL then asserts the MRSTAT.mr_wr_busy while it performs the MR transaction
-// to SDRAM, and no further accesses can be initiated until it is de-asserted.
-
-//MR18, Addr = 'h12, Data = 'h0, Rank 0
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00001200; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR18, Addr = 'h12, Data = 'h0, Rank 1
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00001200; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR1, Addr = 'h1, Data = 'hb0, Rank 0
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x000001b0; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR1, Addr = 'h1, Data = 'hb0, Rank 1
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x000001b0; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR2, Addr = 'h2, Data = 'hbb, Rank 0
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x000002bb; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR2, Addr = 'h2, Data = 'hbb, Rank 1
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x000002bb; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR3, Addr = 'h3, Data = 'h26, Rank 0
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00000326; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR3, Addr = 'h3, Data = 'h26, Rank 1
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00000326; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR10, Addr = 'ha, Data = 'h58, Rank 0
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00000a58; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR10, Addr = 'ha, Data = 'h58, Rank 1
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00000a58; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR11, Addr = 'hb, Data = 'h44, Rank 0
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00000b44; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR11, Addr = 'hb, Data = 'h44, Rank 1
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00000b44; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR12, Addr = 'hc, Data = 'h2d, Rank 0
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00000c2d; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR12, Addr = 'hc, Data = 'h2d, Rank 1
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00000c2d; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR13, Addr = 'hd, Data = 'h21, Rank 0
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
-//MEM_RW(DMC_BASE, 0x010084)  = 0x00000d21; //MRCTRL1 - Program MR Address and MR WData
-// Enabling DM for Masked Writes
-MEM_RW(DMC_BASE, 0x010084)  = 0x00000d01; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR13, Addr = 'hd, Data = 'h21, Rank 1
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
-//MEM_RW(DMC_BASE, 0x010084)  = 0x00000d21; //MRCTRL1 - Program MR Address and MR WData
-// Enabling DM for Masked Writes
-MEM_RW(DMC_BASE, 0x010084)  = 0x00000d01; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
-
-// Note: Removing MR14, MR15 register writes to avoid tVREF related errors from VIP
-// Need to check with IP team to see if there is a way to control this timing
-////MR14, Addr = 'he, Data = 'h15, Rank 0
-//while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-//MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
-//MEM_RW(DMC_BASE, 0x010084)  = 0x00000e15; //MRCTRL1 - Program MR Address and MR WData
-//MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
-//
-////MR14, Addr = 'he, Data = 'h15, Rank 1
-//while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-//MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
-//MEM_RW(DMC_BASE, 0x010084)  = 0x00000e15; //MRCTRL1 - Program MR Address and MR WData
-//MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
-//
-////MR15, Addr = 'hf, Data = 'h62, Rank 0
-//while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-//MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
-//MEM_RW(DMC_BASE, 0x010084)  = 0x00000f62; //MRCTRL1 - Program MR Address and MR WData
-//MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
-//
-////MR15, Addr = 'hf, Data = 'h62, Rank 1
-//while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-//MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
-//MEM_RW(DMC_BASE, 0x010084)  = 0x00000f62; //MRCTRL1 - Program MR Address and MR WData
-//MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR16, Addr = 'h10, Data = 'h0, Rank 0
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00001000; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR16, Addr = 'h10, Data = 'h0, Rank 1
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00001000; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR17, Addr = 'h11, Data = 'h1d, Rank 0
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x0000111d; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR17, Addr = 'h11, Data = 'h1d, Rank 1
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x0000111d; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR19, Addr = 'h13, Data = 'h0, Rank 0
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00001300; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR19, Addr = 'h13, Data = 'h0, Rank 1
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00001300; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR20, Addr = 'h14, Data = 'h2, Rank 0
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00001402; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR20, Addr = 'h14, Data = 'h2, Rank 1
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00001402; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR22, Addr = 'h16, Data = 'h0, Rank 0
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00001600; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR22, Addr = 'h16, Data = 'h0, Rank 1
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00001600; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR23, Addr = 'h17, Data = 'h0, Rank 0
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00001700; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR23, Addr = 'h17, Data = 'h0, Rank 1
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00001700; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR25, Addr = 'h19, Data = 'h0, Rank 0
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00001900; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR25, Addr = 'h19, Data = 'h0, Rank 1
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00001900; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR28, Addr = 'h1c, Data = 'h8, Rank 0
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00001c08; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR28, Addr = 'h1c, Data = 'h8, Rank 1
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00001c08; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR37, Addr = 'h25, Data = 'h40, Rank 0
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00002540; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR37, Addr = 'h25, Data = 'h40, Rank 1
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00002540; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR40, Addr = 'h28, Data = 'h40, Rank 0
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00002840; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
-
-//MR40, Addr = 'h28, Data = 'h40, Rank 1
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
-MEM_RW(DMC_BASE, 0x010084)  = 0x00002840; //MRCTRL1 - Program MR Address and MR WData
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
-
-//Poll MRSTAT.mr_wr_busy until it is 0. This checks that there is no outstanding MR transaction
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
-
-#endif // #ifndef DMC_SDRAM_MR_WRITES_EN
-#else
-#include <phy_registers.h>
-#include <snps_defines.h>
+    
   // Initialize the PHY Registers
-  MEM_RW(PHY_BASE,PHY_INIT_COMPLETE)   = 0x00000001; //0x00
-  MEM_RW(PHY_BASE, PHY_READ_DELAY)     = 0x00000001; //0x08
-  MEM_RW(PHY_BASE, PHY_CAPTURE_MASK)   = 0x00000003; //0x0C
-  MEM_RW(PHY_BASE, PHY_T_CTRL_DELAY)   = 0x0a000000; //0x14
-  MEM_RW(PHY_BASE, PHY_WR_LATENCY)     = 0x01000033; //0x18	  // mask offset = 0 data offset =1
-  MEM_RW(PHY_BASE, PHY_RDDATA_EN)      = 0x00002400; //0x1C
-  MEM_RW(PHY_BASE, PHY_RD_LATENCY)     = 0x00000024; //0x20
-  MEM_RW(PHY_BASE, PHY_LP_ACK)         = 0x00030000; //0x30
-  MEM_RW(PHY_BASE, PHY_WR_PREMBL)      = 0x00000002; //0x58
-  MEM_RW(PHY_BASE, PHY_DELAY_SEL)      = 0x0000000d; //0x820
-  MEM_RW(PHY_BASE, PHY_REF_EN)	       = 0x00000000; //0x824
-  MEM_RW(PHY_BASE, PHY_T_CTRL_UPD_MIN) = 0x00000000; //0x828
-
+MEM_RW(PHY_BASE,PHY_INIT_COMPLETE)   = 0x00000001; //0x00
+MEM_RW(PHY_BASE, PHY_READ_DELAY)     = 0x00000001; //0x08
+MEM_RW(PHY_BASE, PHY_CAPTURE_MASK)   = 0x00000003; //0x0C
+MEM_RW(PHY_BASE, PHY_T_CTRL_DELAY)   = 0x0a000000; //0x14
+MEM_RW(PHY_BASE, PHY_WR_LATENCY)     = 0x01000033; //0x18	  // mask offset = 0 data offset =1
+MEM_RW(PHY_BASE, PHY_RDDATA_EN)      = 0x00002400; //0x1C
+MEM_RW(PHY_BASE, PHY_RD_LATENCY)     = 0x00000024; //0x20
+MEM_RW(PHY_BASE, PHY_LP_ACK)         = 0x00030000; //0x30
+MEM_RW(PHY_BASE, PHY_WR_PREMBL)      = 0x00000002; //0x58
+MEM_RW(PHY_BASE, PHY_DELAY_SEL)      = 0x0000000d; //0x820
+MEM_RW(PHY_BASE, PHY_REF_EN)	       = 0x00000000; //0x824
+MEM_RW(PHY_BASE, PHY_T_CTRL_UPD_MIN) = 0x00000000; //0x828
   while ((MEM_RW(DMC_BASE, 0x10014))  !=1 ) ;  // STAT - wait until normal
 
-#if DMC_WCK_ALWAYS_ON
-  //MEM_RW(DMC_BASE, 0x10180) = (MEM_RW(DMC_BASE, 0x10180)|(0x1<<11)); // PWRCTL - selfref_sw=1
-  MEM_RW(DMC_BASE, 0x10180) = (0x1<<11); // PWRCTL - selfref_sw=1
+  ////MRSTAT //MR2 WL =16 RL=17
+  //MEM_RW(DMC_BASE, 0x010080)  = 0x00000030; //MRCTRL0 - Program the Rank#
+  //MEM_RW(DMC_BASE, 0x010084)  = 0x0000020b; //MRCTRL1 - Program MR Address and MR WData
+  //MEM_RW(DMC_BASE, 0x010080)  = 0x80000030; //MRCTRL0 - Trigger MR Write from the controller
+  
+  
+  
+  #if DMC_WCK_ALWAYS_ON
+  //MEM_RW(DMC_BASE, 0x10180) = (MEM_RW(DMC_BASE, 0x10180)|(0x1<<11)); // PWRCTL - selfref_sw=1 
+  MEM_RW(DMC_BASE, 0x10180) = (0x1<<11); // PWRCTL - selfref_sw=1 
   while (((MEM_RW(DMC_BASE, 0x10014)) & 0x00000037) !=0x23 ) ; // STAT - wait until STAT.operating_mode=3b011 and STAT.selfref_type=2b10.
   MEM_RW(DMC_BASE, 0x10c80) = 0x00000000; // SWCTL -sw_done=0 Enable writes to quasi-dynamic registers outside reset.
-  MEM_RW(DMC_BASE, 0x10010) = 0x00000001; // MSTR4 - CH0 WCK Always on Mode Enable
-  //MEM_RW(DMC_BASE, 0x11010) = 0x00000001; // MSTR4 - CH1 WCK Always on Mode Enable
+  MEM_RW(DMC_BASE, 0x10010) = 0x00000001; // MSTR4 - CH0 WCK Always on Mode Enable 
+  //MEM_RW(DMC_BASE, 0x11010) = 0x00000001; // MSTR4 - CH1 WCK Always on Mode Enable 
   MEM_RW(DMC_BASE, 0x10c80) = 0x00000001; // SWCTL - sw_done =1 Enable writes to quasi-dynamic registers outside reset.
   while ((MEM_RW(DMC_BASE, 0x10c84)) != 0x00000001); // SWSTAT-sw_done_ack=1 propagtes to ack
-  MEM_RW(DMC_BASE, 0x10180) = (0x0<<11); // PWRCTL - selfref_sw=1
-  //((MEM_RW(DMC_BASE, 0x10180)) | (0x0<<11)); // PWRCTL - selfref_sw=0
+  MEM_RW(DMC_BASE, 0x10180) = (0x0<<11); // PWRCTL - selfref_sw=1 
+  //((MEM_RW(DMC_BASE, 0x10180)) | (0x0<<11)); // PWRCTL - selfref_sw=0 
   while (((MEM_RW(DMC_BASE, 0x10014)) & 0x00000007) !=0x1 ) ; // STAT - wait until STAT.operating_mode=3b011 and STAT.selfref_type=2b10.
   //while ((MEM_RW(DMC_BASE, 0x10014))  !=1 ) ;  // STAT - wait until normal
-#endif
+  #endif
+
+  
+    
+  #if DMC_WCK_ALWAYS_ON
+  
+  // MR1 WL=12
+  MEM_RW(DMC_BASE, UMCTL5_MRCTRL0) = 0x00000030; // MRCTRL0 - Program the Rank#
+  MEM_RW(DMC_BASE, UMCTL5_MRCTRL1) = 0x00000180; // Program MR Address and MR WData
+  MEM_RW(DMC_BASE, UMCTL5_MRCTRL0) = 0x80000030; // MRCTRL0 - Trigger MR Write from the controller
+  // MR2 RL=23
+  MEM_RW(DMC_BASE, UMCTL5_MRCTRL0) = 0x00000030; // MRCTRL0 - Program the Rank#
+  MEM_RW(DMC_BASE, UMCTL5_MRCTRL1) = 0x0000020d; // Program MR Address and MR RData
+  MEM_RW(DMC_BASE, UMCTL5_MRCTRL0) = 0x80000030; // MRCTRL0 - Trigger MR Write from the controller  
+  
+    #else  
+    
+  // MR1 WL=22
+  MEM_RW(DMC_BASE, UMCTL5_MRCTRL0) = 0x00000030; // MRCTRL0 - Program the Rank#
+  MEM_RW(DMC_BASE, UMCTL5_MRCTRL1) = 0x000001d0; // Program MR Address and MR WData
+  MEM_RW(DMC_BASE, UMCTL5_MRCTRL0) = 0x80000030; // MRCTRL0 - Trigger MR Write from the controller
+  // MR2 RL=23
+  MEM_RW(DMC_BASE, UMCTL5_MRCTRL0) = 0x00000030; // MRCTRL0 - Program the Rank#
+  MEM_RW(DMC_BASE, UMCTL5_MRCTRL1) = 0x0000020d; // Program MR Address and MR RData
+  MEM_RW(DMC_BASE, UMCTL5_MRCTRL0) = 0x80000030; // MRCTRL0 - Trigger MR Write from the controller  
+  
+  #endif
+  
+    
+  
+  
+  while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 );
+  // Writing twice because of our stupid model
+  
+  #if DMC_WCK_ALWAYS_ON
+  
+  // MR1 WL=12
+  MEM_RW(DMC_BASE, UMCTL5_MRCTRL0) = 0x00000030; // MRCTRL0 - Program the Rank#
+  MEM_RW(DMC_BASE, UMCTL5_MRCTRL1) = 0x00000180; // Program MR Address and MR WData
+  MEM_RW(DMC_BASE, UMCTL5_MRCTRL0) = 0x80000030; // MRCTRL0 - Trigger MR Write from the controller
+  // MR2 RL=23
+  MEM_RW(DMC_BASE, UMCTL5_MRCTRL0) = 0x00000030; // MRCTRL0 - Program the Rank#
+  MEM_RW(DMC_BASE, UMCTL5_MRCTRL1) = 0x0000020d; // Program MR Address and MR RData
+  MEM_RW(DMC_BASE, UMCTL5_MRCTRL0) = 0x80000030; // MRCTRL0 - Trigger MR Write from the controller  
+  
+    #else  
+    
+  // MR1 WL=22
+  MEM_RW(DMC_BASE, UMCTL5_MRCTRL0) = 0x00000030; // MRCTRL0 - Program the Rank#
+  MEM_RW(DMC_BASE, UMCTL5_MRCTRL1) = 0x000001d0; // Program MR Address and MR WData
+  MEM_RW(DMC_BASE, UMCTL5_MRCTRL0) = 0x80000030; // MRCTRL0 - Trigger MR Write from the controller
+  // MR2 RL=23
+  MEM_RW(DMC_BASE, UMCTL5_MRCTRL0) = 0x00000030; // MRCTRL0 - Program the Rank#
+  MEM_RW(DMC_BASE, UMCTL5_MRCTRL1) = 0x0000020d; // Program MR Address and MR RData
+  MEM_RW(DMC_BASE, UMCTL5_MRCTRL0) = 0x80000030; // MRCTRL0 - Trigger MR Write from the controller  
+  
+  #endif
+  
+    
+  
+  
+  while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 );
+  //
 
-//MRSTAT //MR2 WL =16 RL=17
-MEM_RW(DMC_BASE, 0x010080)  = 0x00000030; //MRCTRL0 - Program the Rank#
-#if DMC_WCK_ALWAYS_ON
-    MEM_RW(DMC_BASE, 0x010084)  = 0x0000026b; //MRCTRL1 - Program MR Address and MR WData
-#else
-    MEM_RW(DMC_BASE, 0x010084)  = 0x0000029b; //MRCTRL1 - Program MR Address and MR WData
 #endif
-MEM_RW(DMC_BASE, 0x010080)  = 0x80000030; //MRCTRL0 - Trigger MR Write from the controller
-while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 );
-//
 #endif
diff --git a/module/snps_umctl/include/DWC_ddrctl_lpddr5_init_regs.h b/module/snps_umctl/include/DWC_ddrctl_lpddr5_init_regs.h
index 79a309d5..39f67b2b 100644
--- a/module/snps_umctl/include/DWC_ddrctl_lpddr5_init_regs.h
+++ b/module/snps_umctl/include/DWC_ddrctl_lpddr5_init_regs.h
@@ -1,279 +1,211 @@
-#ifdef SNPS_VIP_FW
-
-// Configure the DWC_ddrctl controller registers
-// Intital version of the initialization sequence
-// Note: Below Register values are extracted from the RAL Model log of Synopsys DMC OOB Testbench
-
-MEM_RW(DMC_BASE, 0x010000)  = 0x03080008; //MSTR0 - LPDDR5/2-Rank/BL16
-MEM_RW(DMC_BASE, 0x010184)  = 0x00000002; //HWLPCTL - Use default settings for Power
-MEM_RW(DMC_BASE, 0x010200)  = 0x00000107; //RFSHMOD0
-MEM_RW(DMC_BASE, 0x010280)  = 0x80000000; //ZQCTL0 - dis_auto_zq=0x1
-MEM_RW(DMC_BASE, 0x010300)  = 0x00400040; //DQSOSCRUNTIME
-MEM_RW(DMC_BASE, 0x010308)  = 0x00000000; //DQSOSCCFG0 // kispet01: Do we need dis_dqsosc_srx=1? : Disable issuing DQSOSC command seq
-MEM_RW(DMC_BASE, 0x010380)  = 0xc000201c; //SCHED0 - opt_vprw_sch=1, dis_speculative_act=1, lpr_num_entries=0x20, opt_wrcam_fill_level=1, rdwr_switch_policy_sel=1, pageclose=1
-MEM_RW(DMC_BASE, 0x010384)  = (UMCTL2_DELAY_SWITCH_WRITE << 12); //SCHED1
-MEM_RW(DMC_BASE, 0x01038c)  = (UMCTL2_RD_PGHIT_NUM_THRESH << 24) | (UMCTL2_WR_PGHIT_NUM_THRESH << 16) |
-                              (UMCTL2_WRCAM_HIGHTHRESH << 8)     | UMCTL2_WRCAM_LOWTHRESH;
-MEM_RW(DMC_BASE, 0x010390)  = (UMCTL2_WR_ACT_GAP << 8)           | UMCTL2_RD_ACT_GAP;
-MEM_RW(DMC_BASE, 0x010c80)  = 0x00000001; // SWCTL - Enable writes to quasi-dynamic registers outside reset.
-MEM_RW(DMC_BASE, 0x010c94)  = 0x00000001; // DBICTL //Enabling DM for Masked Writes
-
-#ifdef DMC_DISABLE_DRAM_INIT
+#include <phy_registers.h>
+#include <snps_defines.h>
+#include <umctl5_registers.h>
+#define fill_word(a,b,c,d) ((a<<24) | (b<<16) | (c<<8) | (d<<0))
+
+// Code copied from fw_umctl5.c SAM env
+
+  MEM_RW(DMC_BASE, UMCTL5_PERFHPR1)  = (UMCTL_HPR_XACT_RUN_LENGTH << 24) | (UMCTL_HPR_STARVE); 
+  MEM_RW(DMC_BASE, UMCTL5_PERFLPR1)  = (UMCTL_LPR_XACT_RUN_LENGTH << 24) | (UMCTL_LPR_STARVE); 
+  MEM_RW(DMC_BASE, UMCTL5_PERFWR1)  = (UMCTL_WR_XACT_RUN_LENGTH  << 24) | (UMCTL_WR_STARVE);
+ 
+  MEM_RW(DMC_BASE, UMCTL5_PCFGQOS0)  = 0x02000e00;  // RQOS region2>d region1>8
+  MEM_RW(DMC_BASE, UMCTL5_PCFGQOS1)  = 0x03ff03ff;  // RQOS region2>d region1>8
+  MEM_RW(DMC_BASE, UMCTL5_PCFGWQOS0) = 0x00000d08;  // WQOS region2>d region1>8
+  MEM_RW(DMC_BASE, UMCTL5_PCFGWQOS1) = 0x03ff03ff;  // WQOS region2>d region1>8
+
+
+
+  MEM_RW(DMC_BASE, UMCTL5_SCHED0) = (UMCTL_OPT_VPRW_SCH << 31)  | ( UMCTL_LPR_NUM_ENTRIES << 8) | (UMCTL_OPT_WRCAM_FILL_LEVEL << 4) | 
+      	      	      	            (1 << 3) | ((UMCTL_PC_TIMER!=-1)?(1<<2):0)  | 0x1;  
+  MEM_RW(DMC_BASE, UMCTL5_SCHED1) = (UMCTL_PAGE_HIT_LIMIT_RD << 28) | (UMCTL_PAGE_HIT_LIMIT_WR << 24) | (UMCTL_WINDOW_LIMIT_RD << 20) |
+      	      	      	      	    (UMCTL_WINDOW_LIMIT_WR << 16) | (UMCTL_DELAY_SWITCH_WRITE << 12);
+  MEM_RW(DMC_BASE, UMCTL5_SCHED3) = (UMCTL_RD_PGHIT_NUM_THRESH << 24) | (UMCTL_WR_PGHIT_NUM_THRESH << 16) | 
+      	      	      	      	    (UMCTL_WRCAM_HIGHTHRESH << 8) | UMCTL_WRCAM_LOWTHRESH;  
+  MEM_RW(DMC_BASE, UMCTL5_SCHED4) = (8<<24) | (0x40<<16) | (UMCTL_WR_ACT_GAP << 8) | UMCTL_RD_ACT_GAP;
+  MEM_RW(DMC_BASE, UMCTL5_SCHEDTMG0) = (UMCTL_RDWR_IDLE_GAP << 8) |((UMCTL_PC_TIMER!=-1)? UMCTL_PC_TIMER:0);
+  MEM_RW(DMC_BASE, UMCTL5_RANKCTL) = 0x0000000f | (UMCTL_MAX_RANK_WR << 12);
+
+  MEM_RW(DMC_BASE, UMCTL5_MSTR0) = 0x03080808;                      // x16 device/LPDDR5/LPDDR5X/2Rank/BL16
+#if DMC_WCK_ALWAYS_ON
+#ifdef SNPS_VIP_FW // Note: For SAM ENV, WCK ALWAYS ON is not enabled in DMC, This needs to be investigated
+  MEM_RW(DMC_BASE, UMCTL5_MSTR4) = 0x00000001; // CH0 WCK Always on Mode Enable
+#endif
+#endif
+  MEM_RW(DMC_BASE, UMCTL5_RFSHMOD0) = 0x00000100;                   // refresh burst x8
+  MEM_RW(DMC_BASE, UMCTL5_ZQCTL0) = 0x80000000;                     // disable zq
+  MEM_RW(DMC_BASE, UMCTL5_ZQCTL2) = 0x00000001;
+  MEM_RW(DMC_BASE, UMCTL5_RANKCTL) = 0x0000f00f;                    // maxwr = f maxrd = f
+#ifndef SNPS_VIP_FW
+  MEM_RW(DMC_BASE, UMCTL5_INITTMG0) = 0x00000000;                   // [0] - 1 pre/post = 0
+#else // !SNPS_VIP_FW
+#ifdef DMC_DISABLE_DRAM_INIT // Synopsys VIP memory subsystem doesnt work properly with the above setting
   // Let PHY perform the SDRAM initialization sequence
-  MEM_RW(DMC_BASE, 0x010d00)  = 0x40020005; //INITTMG0 -skip_dram_init = 2'b01 -> Skip DRAM initialization and start in normal operating mode
-#else
-  //##########################################################
-  // REVISIT [kispet01 @2020-03-02] This option is not yet tested. Remove this comment after completing the check
+  MEM_RW(DMC_BASE, UMCTL5_INITTMG0)  = 0x40020005; //skip_dram_init = 2'b01 -> Skip DRAM initialization and start in normal operating mode
+#else // !DMC_DISABLE_DRAM_INIT
+  // WARNING!!! DMC performs memory initialization/training - untested feature
   c_print_str("Warning: Performing SDRAM init from Controller, this option is not tested and may not work as expected.");
-  //##########################################################
-  // DMC performs memory initialization/training
-  MEM_RW(DMC_BASE, 0x010d00)  = 0x00020005; //INITTMG0
-#endif
+  MEM_RW(DMC_BASE, UMCTL5_INITTMG0)  = 0x00020005;
+#endif // DMC_DISABLE_DRAM_INIT
+#endif //SNPS_VIP_FW
+  MEM_RW(DMC_BASE, UMCTL5_TMGCFG) = 0x00000001;                     // [0] - Freq ratio 4
+  MEM_RW(DMC_BASE, UMCTL5_DFIUPD0) = 0xc0000000;                    // dis_auto_ctrlup
+  MEM_RW(DMC_BASE, UMCTL5_RFSHSET1TMG0) = 0x82100186;               // t_refi_x1_sel = 1 refresh_margin = 2 refresh_to_x1_x32 = 16 t_refi_x1_x32 = 390
+  MEM_RW(DMC_BASE, UMCTL5_RFSHSET1TMG1) = 0x00000070;               // t_rfc_min = 112
+  MEM_RW(DMC_BASE, UMCTL5_RFSHSET1TMG2) = 0x06480000;               // t_pbr2act = 6 t_pbr2pbr = 72
 
-MEM_RW(DMC_BASE, 0x010d04)  = 0x00010000; //INITTMG1 - Number of cycles for SDRAM reset, dram_rstn_x1024=0x1
 
-// System Address to SDRAM Address mapping
-// Memory configuraton - 8GB (4DFI X 2GB)
-// 2GB per DFI, 2GB = 2Ranks X 1GB, 1GB = 8Gb (x16,4B/4BG mode,10columns,15rows -> 32MbX16DQX4BGX4B)
-// x reperesents the bits that gets removed or are dont care in each stage
-// ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
-// AXI(40Bits) - System Address            | 39 | 38 | 37 | 36 | 35 | 34 | 33 | 32 | 31 | 30 | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |
-// ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
-// AXI(33Bits) - 8GB (4DFI X 2GB)          | x  | x  | x  | x  | x  | x  | x  | 32 | 31 | 30 | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |
-// ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
-// AXI(31Bits) - 2GB per DFI (2ranksX1GB)  | x  | x  | x  | x  | x  | x  | x  | 32 | 31 | 30 | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 |  x |  x |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |  Addr[9:8] removed to account for channel striping by interconnect
-// ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
-// AXI(31Bits) -                           | x  | x  | x  | x  | x  | x  | x  | 30 | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  x |  x |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |
-// ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
-// AXI(30Bits) - post SDRAM beat alignment | x  | x  | x  | x  | x  | x  | x  | 32 | 31 | 30 | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 |  x |  x |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  x |
-// ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
-// HIF(30Bits) -                           | x  | x  | x  | x  | x  | x  | x  | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  7 |  x |  x |  6 |  5 |  4 |  3 |  2 |  1 |  0 | x  |  LSB bit removed for SDRAM Beat size (2Bytes) alignment
-// ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
-// SDRAM(30Bits) -                         | x  | x  | x  | x  | x  | x  | x  | r14| r13| r12| r11| r10| r9 | r8 | r7 | r6 | r5 | r4 | r3 | r2 | r1 | r0 | cs | bg1| bg0| b1 | b0 | c9 | c8 | c7 |  x |  x | c6 | c5 | c4 | c3 | c2 | c1 | c0 | x  |
-// ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
-// SDRAM(30Bits) -                         | x  | x  | x  | x  | x  | x  | x  | x  | x  | r14| r13| r12| r11| r10| r9 | r8 | r7 | r6 | r5 | r4 | r3 | r2 | r1 | r0 | cs | bg1| bg0| b1 | b0 | c9 | c8 | c7 | c6 | c5 | c4 | c3 | c2 | c1 | c0 | x  |
-// ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
-// AXI(40Bits) - System Address            | 0  | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 |
-// ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
-// Below registers are used to map the HIF address to SDRAM address
-MEM_RW(DMC_BASE, 0x030004)  = 0x3f3f1f08; //ADDRMAP1  (addrmap_cs_b3_0)         ->  addrmap_cs_b3 = 0x3f(unused), addrmap_cs_b2 = 0x3f(unused), addrmap_cs_b1 = 0x3f(unused), addrmap_cs_b0 = (14[HIF] - 6[base]) = 0x8
-MEM_RW(DMC_BASE, 0x03000c)  = 0x3f3f0707; //ADDRMAP3  (addrmap_bank_b2_0)       ->  addrmap_bank_b2 = 0x3f(unused), addrmap_bank_b1 = (11[HIF] - 4[base]) = 0x07, addrmap_bank_b0 = (10[HIF] - 3[base]) = 0x07
-MEM_RW(DMC_BASE, 0x030010)  = 0x003f0909; //ADDRMAP4  (addrmap_bank_bg_b2_0)    ->  addrmap_bank_bg_b2 = unused, addrmap_bank_bg_b1 = (13[HIF] - 4[base]) = 0x09, addrmap_bank_bg_b0 = (12[HIF] - 3[base]) = 0x09
-MEM_RW(DMC_BASE, 0x030014)  = 0x1f000000; //ADDRMAP5  (addrmap_col_b10_7)       ->  addrmap_col_b10 = 0x1f(unused), addrmap_col_b9 = (9[HIF] - 9[base]) = 0x00, addrmap_col_b8 = (8[HIF] - 8[base]) = 0x00, addrmap_col_b7 = (7[HIF] - 7[base]) = 0x00
-MEM_RW(DMC_BASE, 0x030018)  = 0x00000000; //ADDRMAP6  (addrmap_col_b6_3)        ->  addrmap_col_b6 = (6[HIF] - 6[base]) = 0x00, addrmap_col_b5 = (5[HIF] - 5[base]) = 0x00, addrmap_col_b4 = (5[HIF] - 5[base]) = 0x00, addrmap_col_b4 = (4[HIF] - 4[base]) = 0x00
-MEM_RW(DMC_BASE, 0x03001c)  = 0x1f1f1f09; //ADDRMAP7  (addrmap_row_b17_14)      ->  addrmap_row_b17 = 0x1f(unused), addrmap_row_b16 = 0x1f(unused), addrmap_row_b15 = 0x1f(unused), addrmap_row_b14 = (29[HIF] - 20[base]) = 0x09
-MEM_RW(DMC_BASE, 0x030020)  = 0x09090909; //ADDRMAP8  (addrmap_row_b13_10)      ->  addrmap_row_b13 = (28[HIF] - 19[base]) = 0x09, addrmap_row_b12 = (27[HIF] - 18[base]) = 0x09, addrmap_row_b11 = (26[HIF] - 17[base]) = 0x09, addrmap_row_b10 = (25[HIF] - 16[base]) = 0x09
-MEM_RW(DMC_BASE, 0x030024)  = 0x09090909; //ADDRMAP9  (addrmap_row_b9_6)        ->  addrmap_row_b9 = (24[HIF] - 15[base]) = 0x09, addrmap_row_b8 = (23[HIF] - 14[base]) = 0x09, addrmap_row_b7 = (22[HIF] - 13[base]) = 0x09, addrmap_row_b6 = (21[HIF] - 12[base]) = 0x09
-MEM_RW(DMC_BASE, 0x030028)  = 0x09090909; //ADDRMAP10 (addrmap_row_b5_2)        ->  addrmap_row_b5 = (20[HIF] - 11[base]) = 0x09, addrmap_row_b4 = (19[HIF] - 10[base]) = 0x09, addrmap_row_b3 = (18[HIF] - 9[base]) = 0x09, addrmap_row_b2 = (17[HIF] - 8[base]) = 0x09
-MEM_RW(DMC_BASE, 0x03002c)  = 0x00000909; //ADDRMAP11 (addrmap_row_b1_0)        ->  addrmap_row_b1 = (16[HIF] - 7[base]) = 0x09,addrmap_row_b0 = (15[HIF] - 6[base]) = 0x09
-MEM_RW(DMC_BASE, 0x030030)  = 0x00000000; //ADDRMAP12 (nonbinary_device_density)->  3'b000: All addresses are valid
+  
+// 4 DMC standard t2 addrmap offsets
+//MEM_RW(DMC_BASE, UMCTL5_ADDRMAP1) = fill_word(63,63,63,10); ; // addrmap_cs_b0    = 2 + 6 + 10 + [0]    = [18]
+//MEM_RW(DMC_BASE, UMCTL5_ADDRMAP3) = fill_word(0,63,11,11); // addrmap_bank_b[1:0]  = 2 + 3 + 11 + [1:0]   = [17:16]
+//MEM_RW(DMC_BASE, UMCTL5_ADDRMAP4) = fill_word(0,0,2,2); // addrmap_bg_b[2:0]   = 2 + 3 + 8  + [2:0]   = [15:13]
+//MEM_RW(DMC_BASE, UMCTL5_ADDRMAP5) = fill_word(31,4,4,4); // addrmap_col_b[10:7]  = 2 + 0 + 0  + [10:7]   = [12:9]
+//MEM_RW(DMC_BASE, UMCTL5_ADDRMAP6) = fill_word(4,4,0,0); // addrmap_col_b[6:3]   = 2 + 0 + 0  + [6:3]   = [8:5]
 
-MEM_RW(DMC_BASE, 0x020000)  = 0x00000000; //PCCFG
-MEM_RW(DMC_BASE, 0x020004)  = 0x00006000; //PCFGR
-MEM_RW(DMC_BASE, 0x020008)  = 0x00004000; //PCFGW
-MEM_RW(DMC_BASE, 0x020094)  = 0x00010001; //PCFGQOS0
-MEM_RW(DMC_BASE, 0x020098)  = 0x061f00fc; //PCFGQOS1
-MEM_RW(DMC_BASE, 0x02009c)  = 0x01010e0b; //PCFGWQOS0
-MEM_RW(DMC_BASE, 0x0200a0)  = 0x05540678; //PCFGWQOS1
 
-// Note: Carry forward from lpddr4, Need to revisit this.
-// ARM Standard address map passthrough
-MEM_RW(DMC_BASE, 0x020114)  = 0x00000000; //PSTAT
-MEM_RW(DMC_BASE, 0x021004)  = 0x00006000; //PCFGR
-MEM_RW(DMC_BASE, 0x021008)  = 0x00006000; //PCFGW
-MEM_RW(DMC_BASE, 0x021094)  = 0x00210001; //PCFGQOS0
-MEM_RW(DMC_BASE, 0x021098)  = 0x034f02af; //PCFGQOS1
-MEM_RW(DMC_BASE, 0x02109c)  = 0x01110100; //PCFGWQOS0
-MEM_RW(DMC_BASE, 0x0210a0)  = 0x04b60057; //PCFGWQOS1
+MEM_RW(DMC_BASE, UMCTL5_ADDRMAP1) = fill_word(get_cs_offset(3),get_cs_offset(2),get_cs_offset(1),get_cs_offset(0)); ; // addrmap_cs_b0    = 2 + 6 + 10 + [0]    = [18]
+MEM_RW(DMC_BASE, UMCTL5_ADDRMAP3) = fill_word(0,get_bank_offset(2),get_bank_offset(1),get_bank_offset(0)); // addrmap_bank_b[1:0]  = 2 + 3 + 11 + [1:0]   = [17:16]
+MEM_RW(DMC_BASE, UMCTL5_ADDRMAP4) = fill_word(0,get_bankg_offset(2),get_bankg_offset(1),get_bankg_offset(0)); // addrmap_bg_b[2:0]   = 2 + 3 + 8  + [2:0]   = [15:13]
+MEM_RW(DMC_BASE, UMCTL5_ADDRMAP5) = fill_word(get_col_offset(10),get_col_offset(9),get_col_offset(8),get_col_offset(7)); // addrmap_col_b[10:7]  = 2 + 0 + 0  + [10:7]   = [12:9]
+MEM_RW(DMC_BASE, UMCTL5_ADDRMAP6) = fill_word(get_col_offset(6),get_col_offset(5),get_col_offset(4),0); // addrmap_col_b[6:3]   = 2 + 0 + 0  + [6:3]   = [8:5]
 
-MEM_RW(DMC_BASE, 0x000000)  = 0x2f101b22; //DRAMSET1TMG0
-MEM_RW(DMC_BASE, 0x000004)  = 0x00060633; //DRAMSET1TMG1
-MEM_RW(DMC_BASE, 0x000008)  = 0x10110a1e; //DRAMSET1TMG2
-MEM_RW(DMC_BASE, 0x00000c)  = 0x000c2136; //DRAMSET1TMG3
-MEM_RW(DMC_BASE, 0x000010)  = 0x0f040412; //DRAMSET1TMG4
-MEM_RW(DMC_BASE, 0x000014)  = 0x02040c01; //DRAMSET1TMG5
-MEM_RW(DMC_BASE, 0x000018)  = 0x00000008; //DRAMSET1TMG6
-MEM_RW(DMC_BASE, 0x00001c)  = 0x00000003; //DRAMSET1TMG7
-MEM_RW(DMC_BASE, 0x000020)  = 0x00004400; //DRAMSET1TMG8
-MEM_RW(DMC_BASE, 0x000024)  = 0x00020419; //DRAMSET1TMG9
-MEM_RW(DMC_BASE, 0x000030)  = 0x00030000; //DRAMSET1TMG12
-MEM_RW(DMC_BASE, 0x000034)  = 0x13100002; //DRAMSET1TMG13
-MEM_RW(DMC_BASE, 0x000038)  = 0x0020006e; //DRAMSET1TMG14
-MEM_RW(DMC_BASE, 0x00005c)  = 0x009d05cf; //DRAMSET1TMG23
-MEM_RW(DMC_BASE, 0x000060)  = 0x00081615; //DRAMSET1TMG24
-MEM_RW(DMC_BASE, 0x000064)  = 0x00002f06; //DRAMSET1TMG25
-MEM_RW(DMC_BASE, 0x000078)  = 0x00190b18; //DRAMSET1TMG30
+  
+//enable bank hashing in the dmc
+MEM_RW(DMC_BASE, UMCTL5_ADDRMAP12) = MEM_RW(DMC_BASE, UMCTL5_ADDRMAP12) | (1<<4); // bank hash en
 
-// DFITMG* parameter values must match with PHY
-MEM_RW(DMC_BASE, 0x000580)  = 0x063f023E; //DFITMG0
-MEM_RW(DMC_BASE, 0x000584)  = 0x00140606; //DFITMG1
-MEM_RW(DMC_BASE, 0x000588)  = 0x00243f3b; //DFITMG2
-MEM_RW(DMC_BASE, 0x000590)  = 0x1C2C0400; //DFITMG4
-MEM_RW(DMC_BASE, 0x000594)  = 0x04100010; //DFITMG5
-MEM_RW(DMC_BASE, 0x0005a0)  = 0x00020202; //DFILPTMG0
-MEM_RW(DMC_BASE, 0x0005a4)  = 0x00000201; //DFILPTMG1
-MEM_RW(DMC_BASE, 0x0005a8)  = 0x001b0003; //DFIUPDTMG0
-MEM_RW(DMC_BASE, 0x0005ac)  = 0x000b00e8; //DFIUPDTMG1
-MEM_RW(DMC_BASE, 0x0005b0)  = 0x00000004; //DFIMSGTMG0
-MEM_RW(DMC_BASE, 0x000600)  = 0x0210000C; //RFSHSET1TMG0 - t_refi_x1_sel=0, refresh_margin=2, refresh_to_x1_x32=0x10, t_refi_x1_x32 = round_down(488ns/1.25ns/32)= 0xC
-MEM_RW(DMC_BASE, 0x000a80)  = 0x00003d91; //DQSOSCCTL0
-MEM_RW(DMC_BASE, 0x000c80)  = 0x0f000001; //PERFHPR1 // kispet01: This is related to performance tuning for different priorities, use settings for OoB and change later if required
-MEM_RW(DMC_BASE, 0x000c84)  = 0x0f00007f; //PERFLPR1 // kispet01: This is related to performance tuning for different priorities, use settings for OoB and change later if required
-MEM_RW(DMC_BASE, 0x000c88)  = 0x0f00007f; //PERFWR1  // kispet01: This is related to performance tuning for different priorities, use settings for OoB and change later if required
-MEM_RW(DMC_BASE, 0x000d00)  = 0x00000001; //TMGCFG - frequency_ratio- 1:1:4 Mode
-//MEM_RW(DMC_BASE, 0x000d04)  = 0x00000202; //RANKTMG0 // kispet01: Was 0x00000e12, Modified: diff_rank_wr_gap=2, diff_rank_rd_gap=2 (to match with LPDDR4 sequence)
-MEM_RW(DMC_BASE, 0x000d04)  = 0x00000e12; //RANKTMG0 // Note: Reverting to IP OOB TB values to avoid VIP issues during rank switching
-//MEM_RW(DMC_BASE, 0x000d08)  = 0x00000e12; //RANKTMG1 // kispet01: Need to review. rd2wr_dr, wr2rd_dr param values. LPDDR4 is using 'd16 and 'd21 respecitvely
-MEM_RW(DMC_BASE, 0x000d08)  = 0x00000f11; //RANKTMG1 // Note: Reverting to IP OOB TB values to avoid VIP issues during rank switching
-MEM_RW(DMC_BASE, 0x000d0c)  = 0x00020001; //PWRTMG - Low power timing for selfref_to_x32, powerdown_to_x32, Use default
-MEM_RW(DMC_BASE, 0x020090)  = 0x00000001; //PCTRL - Enable AXI Port 0
-MEM_RW(DMC_BASE, 0x021090)  = 0x00000001; //PCTRL - Enable AXI Port 1
 
-// Phy and Memory initialization to be performed separately after releasing reset from SCP
-#else
-#include <phy_registers.h>
-#include <snps_defines.h>
-
-
-// COMMENT THIS OUT IF YOU DON'T WANT THE BONUS PERF STUFF************************************************
-#define UMCTL5_SCHEDTMG0                   0x00c00
-#define UMCTL5_PERFHPR1                    0x00c80
-#define UMCTL5_PERFLPR1                    0x00c84
-#define UMCTL5_PERFWR1                     0x00c88
-// COMMENT THIS OUT IF YOU DON'T WANT THE BONUS PERF STUFF************************************************
- MEM_RW(DMC_BASE, UMCTL5_PERFHPR1)  = (UMCTL_HPR_XACT_RUN_LENGTH << 24) | (UMCTL_HPR_STARVE);
- MEM_RW(DMC_BASE, UMCTL5_PERFLPR1)  = (UMCTL_LPR_XACT_RUN_LENGTH << 24) | (UMCTL_LPR_STARVE);
- MEM_RW(DMC_BASE, UMCTL5_PERFWR1)  = (UMCTL_WR_XACT_RUN_LENGTH  << 24) | (UMCTL_WR_STARVE);
-// COMMENT THIS OUT IF YOU DON'T WANT THE BONUS PERF STUFF************************************************
+// 4 DMC standard t2 addrmap offsets  
+//MEM_RW(DMC_BASE, UMCTL5_ADDRMAP11) = fill_word(31,31,11,11); // addrmap_row_b[1:0]   = 2 + 6 + 11  + [1:0]   = [20:19]
+//MEM_RW(DMC_BASE, UMCTL5_ADDRMAP10) = fill_word(11,11,11,11); // addrmap_row_b[5:2]   = 2 + 6 + 11  + [5:2]   = [24:21]
+//MEM_RW(DMC_BASE, UMCTL5_ADDRMAP9) = fill_word(11,11,11,11); // addrmap_row_b[9:6]   = 2 + 6 + 11  + [9:6]   = [28:25]
+//MEM_RW(DMC_BASE, UMCTL5_ADDRMAP8) = fill_word(11,11,11,11); //addrmap_row_b[13:10] = 2 + 6 + 11  + [13:10] = [32:29]
+//MEM_RW(DMC_BASE, UMCTL5_ADDRMAP7) = fill_word(11,11,11,11); //addrmap_row_b[17:14] = 3 + 6 + 9  + [17:14]  = [35:32]
 
-  MEM_RW(DMC_BASE, 0x10000) = 0x03080008; // MSTR0 - x16 device/LPDDR5/2Rank/BL16
-  MEM_RW(DMC_BASE, 0x10200) = 0x00000100; // RFSHMOD0  - refresh burst x8
-  MEM_RW(DMC_BASE, 0x10280) = 0x80000000; // ZQCTL0    - disable zq
-  MEM_RW(DMC_BASE, 0x10288) = 0x00000001; // ZQCTL2    -
-  MEM_RW(DMC_BASE, 0x10380) = (1<<31)  | (1<<16) | ( UMCTL_LPR_NUM_ENTRIES << 8) | (UMCTL_OPT_WRCAM_FILL_LEVEL << 4) |
-                              (UMCTL_ENHANCED_RW << 3) | ((UMCTL_PC_TIMER!=-1)?(1<<2):0)  | 0x1; // SCHED0
-  MEM_RW(DMC_BASE, 0x10384) = (UMCTL_PAGE_HIT_LIMIT_RD << 28) | (UMCTL_PAGE_HIT_LIMIT_WR << 24) |
-                              (UMCTL_WINDOW_LIMIT_RD << 20) | (UMCTL_WINDOW_LIMIT_WR << 16) |
-            (UMCTL_DELAY_SWITCH_WRITE << 12); // SCHED1
-  MEM_RW(DMC_BASE, 0x1038C) = (UMCTL_RD_PGHIT_NUM_THRESH << 24) | (UMCTL_WR_PGHIT_NUM_THRESH << 16) |
-                            (UMCTL_WRCAM_HIGHTHRESH << 8) | UMCTL_WRCAM_LOWTHRESH; //0x4040208; // SCHED3   - wrcam_highthresh=2 wrcam_lowthresh=32
-MEM_RW(DMC_BASE, 0x10390) = (8<<24) | (0x40<<16) | (UMCTL_WR_ACT_GAP << 8)           | UMCTL_RD_ACT_GAP; // SCHED4   - wr_page_exp=8 rd_pageexp=64 wractgap=0 rdactgap=0
+MEM_RW(DMC_BASE, UMCTL5_ADDRMAP11) = fill_word(31,31,get_row_offset(1),get_row_offset(0)); // addrmap_row_b[1:0]   = 2 + 6 + 11  + [1:0]   = [20:19]
+MEM_RW(DMC_BASE, UMCTL5_ADDRMAP10) = fill_word(get_row_offset(5),get_row_offset(4),get_row_offset(3),get_row_offset(2)); // addrmap_row_b[5:2]   = 2 + 6 + 11  + [5:2]   = [24:21]
+MEM_RW(DMC_BASE, UMCTL5_ADDRMAP9) = fill_word(get_row_offset(9),get_row_offset(8),get_row_offset(7),get_row_offset(6)); // addrmap_row_b[9:6]   = 2 + 6 + 11  + [9:6]   = [28:25]
+MEM_RW(DMC_BASE, UMCTL5_ADDRMAP8) = fill_word(get_row_offset(13),get_row_offset(12),get_row_offset(11),get_row_offset(10)); //addrmap_row_b[13:10] = 2 + 6 + 11  + [13:10] = [32:29]
+MEM_RW(DMC_BASE, UMCTL5_ADDRMAP7) = fill_word(get_row_offset(17),get_row_offset(16),get_row_offset(15),get_row_offset(14)); //addrmap_row_b[17:14] = 3 + 6 + 9  + [17:14]  = [35:32]
 
-  MEM_RW(DMC_BASE, 0xc00) = (UMCTL_RDWR_IDLE_GAP << 8) |((UMCTL_PC_TIMER!=-1)? UMCTL_PC_TIMER:0); //0x83c0810 // SCHEDTMG0
-  MEM_RW(DMC_BASE, 0x10c90) = 0x0000f00f; // RANKCTL   - maxwr = f maxrd = f
-  MEM_RW(DMC_BASE, 0x10d00) = 0x00000000; // INITTMG0 - [0] - 1 pre/post =0
-  MEM_RW(DMC_BASE, 0x00d00) = 0x00000001; // TMGCFG - [0] - Freq ratio 4
-  MEM_RW(DMC_BASE, 0x10508) = 0xc0000000; // DFIUPD0   - dis_auto_ctrlup
-  MEM_RW(DMC_BASE, 0x00600) = 0x82100186; // RFSHSET1TMG0 - t_refi_x1_sel = 1 refresh_margin=2 refresh_to_x1_x32=16 t_refi_x1_x32=390
-  MEM_RW(DMC_BASE, 0x00604) = 0x00000070; // RFSHSET1TMG1 - t_rfc_min = 112
-  MEM_RW(DMC_BASE, 0x00608) = 0x06480000; // RFSHSET1TMG2 - t_pbr2act = 6 t_pbr2pbr = 72
+  
 
-//#if DMC_BANK_STRIPE == 32
-//  MEM_RW(DMC_BASE, 0x30018) = 0x02020200; // ADDRMAP6 - addrmap_col_b[6:3]   = 1 + 0 + 2  + [6:3]   = [9:7,4]
-//  MEM_RW(DMC_BASE, 0x30014) = 0x1f020202; // ADDRMAP5 - addrmap_col_b[10:7]  = 1 + 0 + 2  + [9:7]   = [12:10]
-//  MEM_RW(DMC_BASE, 0x30010) = 0x003f0101; // ADDRMAP4 - addrmap_bg_b[2:0]    = 1 + 3 + 1  + [1:0]   = [6:5]
-//  MEM_RW(DMC_BASE, 0x3000C) = 0x003f0909; // ADDRMAP3 - addrmap_bank_b[2:0]  = 1 + 3 + 9  + [1:0]   = [14:13]
-//#else
-//  MEM_RW(DMC_BASE, 0x30018) = 0x00000000; // ADDRMAP6 - addrmap_col_b[6:3]   = 1 + 0 + 0  + [6:3]   = [7:4]
-//  MEM_RW(DMC_BASE, 0x30014) = 0x1f000000; // ADDRMAP5 - addrmap_col_b[10:7]  = 1 + 0 + 0  + [9:7]   = [10:8]
-//  MEM_RW(DMC_BASE, 0x30010) = 0x003f0707; // ADDRMAP4 - addrmap_bg_b[2:0]    = 1 + 3 + 7  + [1:0]   = [12:11]
-//  MEM_RW(DMC_BASE, 0x3000C) = 0x003f0909; // ADDRMAP3 - addrmap_bank_b[2:0]  = 1 + 3 + 9  + [1:0]   = [14:13]
-//#endif
-//  // RCB SDRAM address map =  log2(DATA_WIDTH) + base + offset
-//  MEM_RW(DMC_BASE, 0x30004) = 0x3f3f1f08; // ADDRMAP1 - addrmap_cs_b0      = 1 + 6 + 8  + [0]     = [15]
-//  MEM_RW(DMC_BASE, 0x3002C) = 0x00000909; // ADDRMAP11- addrmap_row_b[1:0]   = 1 + 6 + 9  + [1:0]   = [17:16]
-//  MEM_RW(DMC_BASE, 0x30028) = 0x09090909; // ADDRMAP10- addrmap_row_b[5:2]   = 1 + 6 + 9  + [5:2]   = [21:18]
-//  MEM_RW(DMC_BASE, 0x30024) = 0x09090909; // ADDRMAP9 - addrmap_row_b[9:6]   = 1 + 6 + 9  + [9:6]   = [25:22]
-//#if DMC_ROW_BITS+11 == 11
-//  MEM_RW(DMC_BASE, 0x30020) = 0x1f1f1f09; // ADDRMAP8 - addrmap_row_b[13:10] = 1 + 6 + 9  + [10]    = [26]
-//  MEM_RW(DMC_BASE, 0x3001C) = 0x1f1f1f1f; // ADDRMAP7 - addrmap_row_b[17:14] = 1 + 6 + 9  +         =
-//#elif DMC_ROW_BITS+11 == 12
-//  MEM_RW(DMC_BASE, 0x30020) = 0x1f1f0909; // ADDRMAP8 - addrmap_row_b[13:10] = 1 + 6 + 9  + [11:10] = [27:26]
-//  MEM_RW(DMC_BASE, 0x3001C) = 0x1f1f1f1f; // ADDRMAP7 - addrmap_row_b[17:14] = 1 + 6 + 9  +         =
-//#elif DMC_ROW_BITS+11 == 13
-//  MEM_RW(DMC_BASE, 0x30020) = 0x1f090909; // ADDRMAP8 - addrmap_row_b[13:10] = 1 + 6 + 9  + [12:10] = [28:26]
-//  MEM_RW(DMC_BASE, 0x3001C) = 0x1f1f1f1f; // ADDRMAP7 - addrmap_row_b[17:14] = 1 + 6 + 9  +          =
-//#elif DMC_ROW_BITS+11 == 14
-//  MEM_RW(DMC_BASE, 0x30020) = 0x09090909; // ADDRMAP8 - addrmap_row_b[13:10] = 1 + 6 + 9  + [13:10] = [29:26]
-//  MEM_RW(DMC_BASE, 0x3001C) = 0x1f1f1f1f; // ADDRMAP7 - addrmap_row_b[17:14] = 1 + 6 + 9  +         =
-//#elif DMC_ROW_BITS+11 == 15
-//  MEM_RW(DMC_BASE, 0x30020) = 0x09090909; // ADDRMAP8 - addrmap_row_b[13:10] = 1 + 6 + 9  + [13:10] = [29:26]
-//  MEM_RW(DMC_BASE, 0x3001C) = 0x1f1f1f09; // ADDRMAP7 - addrmap_row_b[17:14] = 1 + 6 + 9  + [14]    = [30]
-//#elif DMC_ROW_BITS+11 == 16
-//  MEM_RW(DMC_BASE, 0x30020) = 0x09090909; // ADDRMAP8 - addrmap_row_b[13:10] = 1 + 6 + 9  + [13:10] = [29:26]
-//  MEM_RW(DMC_BASE, 0x3001C) = 0x1f1f0909; // ADDRMAP7 - addrmap_row_b[17:14] = 1 + 6 + 9  + [15:14] = [31:30]
-//#endif
 
-// Below registers are used to map the HIF address to SDRAM address
-MEM_RW(DMC_BASE, 0x030004)  = 0x3f3f3f08; //ADDRMAP1  (addrmap_cs_b3_0)         ->  addrmap_cs_b3 = 0x3f(unused), addrmap_cs_b2 = 0x3f(unused), addrmap_cs_b1 = 0x3f(unused), addrmap_cs_b0 = (14[HIF] - 6[base]) = 0x8
-//MEM_RW(DMC_BASE, 0x03000c)  = 0x3f3f0707; //ADDRMAP3  (addrmap_bank_b2_0)       ->  addrmap_bank_b2 = 0x3f(unused), addrmap_bank_b1 = (11[HIF] - 4[base]) = 0x07, addrmap_bank_b0 = (10[HIF] - 3[base]) = 0x07
-//MEM_RW(DMC_BASE, 0x030010)  = 0x003f0909; //ADDRMAP4  (addrmap_bank_bg_b2_0)    ->  addrmap_bank_bg_b2 = unused, addrmap_bank_bg_b1 = (13[HIF] - 4[base]) = 0x09, addrmap_bank_bg_b0 = (12[HIF] - 3[base]) = 0x09
-MEM_RW(DMC_BASE, 0x03000c)  = 0x003f0909; //ADDRMAP3  (addrmap_bank_b2_0)       ->  addrmap_bank_b2 = 0x3f(unused), addrmap_bank_b1 = (13[HIF] - 4[base]) = 0x09, addrmap_bank_b0 = (12[HIF] - 3[base]) = 0x09
-MEM_RW(DMC_BASE, 0x030010)  = 0x003f0707; //ADDRMAP4  (addrmap_bank_bg_b2_0)    ->  addrmap_bank_bg_b2 = unused, addrmap_bank_bg_b1 = (11[HIF] - 4[base]) = 0x07, addrmap_bank_bg_b0 = (10[HIF] - 3[base]) = 0x07
-MEM_RW(DMC_BASE, 0x030014)  = 0x1f000000; //ADDRMAP5  (addrmap_col_b10_7)       ->  addrmap_col_b10 = 0x1f(unused), addrmap_col_b9 = (9[HIF] - 9[base]) = 0x00, addrmap_col_b8 = (8[HIF] - 8[base]) = 0x00, addrmap_col_b7 = (7[HIF] - 7[base]) = 0x00
-MEM_RW(DMC_BASE, 0x030018)  = 0x00000000; //ADDRMAP6  (addrmap_col_b6_3)        ->  addrmap_col_b6 = (6[HIF] - 6[base]) = 0x00, addrmap_col_b5 = (5[HIF] - 5[base]) = 0x00, addrmap_col_b4 = (5[HIF] - 5[base]) = 0x00, addrmap_col_b4 = (4[HIF] - 4[base]) = 0x00
-MEM_RW(DMC_BASE, 0x03001c)  = 0x1f1f0909; //ADDRMAP7  (addrmap_row_b17_14)      ->  addrmap_row_b17 = 0x1f(unused), addrmap_row_b16 = 0x1f(unused), addrmap_row_b15 = 0x1f(unused), addrmap_row_b14 = (29[HIF] - 20[base]) = 0x09
-MEM_RW(DMC_BASE, 0x030020)  = 0x09090909; //ADDRMAP8  (addrmap_row_b13_10)      ->  addrmap_row_b13 = (28[HIF] - 19[base]) = 0x09, addrmap_row_b12 = (27[HIF] - 18[base]) = 0x09, addrmap_row_b11 = (26[HIF] - 17[base]) = 0x09, addrmap_row_b10 = (25[HIF] - 16[base]) = 0x09
-MEM_RW(DMC_BASE, 0x030024)  = 0x09090909; //ADDRMAP9  (addrmap_row_b9_6)        ->  addrmap_row_b9 = (24[HIF] - 15[base]) = 0x09, addrmap_row_b8 = (23[HIF] - 14[base]) = 0x09, addrmap_row_b7 = (22[HIF] - 13[base]) = 0x09, addrmap_row_b6 = (21[HIF] - 12[base]) = 0x09
-MEM_RW(DMC_BASE, 0x030028)  = 0x09090909; //ADDRMAP10 (addrmap_row_b5_2)        ->  addrmap_row_b5 = (20[HIF] - 11[base]) = 0x09, addrmap_row_b4 = (19[HIF] - 10[base]) = 0x09, addrmap_row_b3 = (18[HIF] - 9[base]) = 0x09, addrmap_row_b2 = (17[HIF] - 8[base]) = 0x09
-MEM_RW(DMC_BASE, 0x03002c)  = 0x00000909; //ADDRMAP11 (addrmap_row_b1_0)        ->  addrmap_row_b1 = (16[HIF] - 7[base]) = 0x09,addrmap_row_b0 = (15[HIF] - 6[base]) = 0x09
-MEM_RW(DMC_BASE, 0x030030)  = 0x00000000; //ADDRMAP12 (nonbinary_device_density)->  3'b000: All addresses are valid
 #ifdef DMC_DISABLE_REFRESH
-  MEM_RW(DMC_BASE, 0x010208) = 0x00000001; // RFSHCTL0  - dis_auto_ref
+  MEM_RW(DMC_BASE, UMCTL5_RFSHCTL0) = 0x1;                          // dis_auto_ref
 #endif
-MEM_RW(DMC_BASE, 0x00600)  = 0x82100186; //RFSHSET1TMG0 - t_refi_x1_sel = 1 refresh_margin=2 refresh_to_x1_x32=16 t_refi_x1_x32=390
-MEM_RW(DMC_BASE, 0x00d04)  = 0x00000b07; //RANKTMG0
-MEM_RW(DMC_BASE, 0x00d08)  = 0x00001102; //RANKTMG1
-MEM_RW(DMC_BASE, 0x00000)  = 0x28100322; //DRAMSET1TMG0
-MEM_RW(DMC_BASE, 0x00004)  = 0x00060630; //DRAMSET1TMG1
-MEM_RW(DMC_BASE, 0x00008)  = 0x09111117; //DRAMSET1TMG2 - WL 9 RL - 17
-MEM_RW(DMC_BASE, 0x0000c)  = 0x000c212f; //DRAMSET1TMG3
-MEM_RW(DMC_BASE, 0x00010)  = 0x0f04040f; //DRAMSET1TMG4 - t_rcd = 15 t_ccd_l = 4 t_rrd_l = 4 t_rp = 15
-MEM_RW(DMC_BASE, 0x00014)  = 0x02040c01; //DRAMSET1TMG5
-MEM_RW(DMC_BASE, 0x00018)  = 0x00000008; //DRAMSET1TMG6
-MEM_RW(DMC_BASE, 0x0001c)  = 0x00000003; //DRAMSET1TMG7
-MEM_RW(DMC_BASE, 0x00020)  = 0x00004400; //DRAMSET1TMG8
-MEM_RW(DMC_BASE, 0x00024)  = 0x00020412; //DRAMSET1TMG9 - tccd_s = 2 t_rrd_s = 4 twr2rd_s = 18
-MEM_RW(DMC_BASE, 0x00030)  = 0x00030000; //DRAMSET1TMG12
-MEM_RW(DMC_BASE, 0x00034)  = 0x0c100002; //DRAMSET1TMG13  odtloff=12 t_ccd_mw=16 t_ppd=2 for LPDDR4 only
-MEM_RW(DMC_BASE, 0x00038)  = 0x000000e6; //DRAMSET1TMG14
-MEM_RW(DMC_BASE, 0x0005c)  = 0x009d0bcc; //DRAMSET1TMG23
-MEM_RW(DMC_BASE, 0x00060)  = 0x000f160e; //DRAMSET1TMG24 - 4Bank/4BG
-MEM_RW(DMC_BASE, 0x00064)  = 0x00002806; //DRAMSET1TMG25
-MEM_RW(DMC_BASE, 0x00078)  = 0x00191218; //DRAMSET1TMG30
-MEM_RW(DMC_BASE, 0x00580)  = 0x0627002f; //DFITMG0 - tctldelay = 6 trddataen = 39 tphywrdata = 0 tphywrlat =47 // old latency pass
-MEM_RW(DMC_BASE, 0x00584)  = 0x00140606; //DFITMG1
-MEM_RW(DMC_BASE, 0x00588)  = 0x00243f1f; //DFITMG2
-MEM_RW(DMC_BASE, 0x00590)  = 0x180c0402; //DFITMG4
-MEM_RW(DMC_BASE, 0x00594)  = 0x04100006; //DFITMG5
 
-  // Enable QOS
-#ifdef QOS_DISABLE
-  MEM_RW(DMC_BASE, 0x20094+0x1000*0)  = 0x02000e00;  // RQOS region2>d region1>8
-  MEM_RW(DMC_BASE, 0x20098+0x1000*0)  = 0x03ff03ff;
-  MEM_RW(DMC_BASE, 0x2009c+0x1000*0)  = 0x00000e00;  // WQOS region2>d region1>8
-  MEM_RW(DMC_BASE, 0x200a0+0x1000*0)  = 0x03ff03ff;
-  MEM_RW(DMC_BASE, 0x20094+0x1000*1)  = 0x02000e00;  // RQOS region2>d region1>8
-  MEM_RW(DMC_BASE, 0x20098+0x1000*1)  = 0x03ff03ff;
-  MEM_RW(DMC_BASE, 0x2009c+0x1000*1)  = 0x00000e00;  // WQOS region2>d region1>8
-  MEM_RW(DMC_BASE, 0x200a0+0x1000*1)  = 0x03ff03ff;
-  MEM_RW(DMC_BASE, 0x20004+0x1000*0)  = 0x000143ff;  // RQOS region2>d region1>8
-  MEM_RW(DMC_BASE, 0x20004+0x1000*1)  = 0x000143ff;  // RQOS region2>d region1>8
-#else
-  MEM_RW(DMC_BASE, 0x20094+0x1000*0)  = 0x02100d08;  // RQOS region2>d region1>8
-  MEM_RW(DMC_BASE, 0x20098+0x1000*0)  = UMCTL_VP_TIMEOUT;  // PCFGQOS1 - timeoutr timeoutb
-  MEM_RW(DMC_BASE, 0x2009c+0x1000*0)  = 0x01000908;  // WQOS region2>d region1>8
-  MEM_RW(DMC_BASE, 0x200a0+0x1000*0)  = UMCTL_VP_WTIMEOUT;  // WQOS region2>0 region1>0
-  MEM_RW(DMC_BASE, 0x20094+0x1000*1)  = 0x02100d08;  // RQOS region2>d region1>8
-  MEM_RW(DMC_BASE, 0x20098+0x1000*1)  = UMCTL_VP_TIMEOUT;  // PCFGQOS1 - timeoutr timeoutb
-  MEM_RW(DMC_BASE, 0x2009c+0x1000*1)  = 0x01000a00;  // WQOS region2>d region1>8
-  MEM_RW(DMC_BASE, 0x200a0+0x1000*1)  = UMCTL_VP_WTIMEOUT;  // WQOS region2>0 region1>0
-  MEM_RW(DMC_BASE, 0x20004+0x1000*0)  = 0x000143ff;  // RQOS region2>d region1>8
-  MEM_RW(DMC_BASE, 0x20004+0x1000*1)  = 0x000153ff;  // RQOS region2>d region1>8
-#endif
-  // Enable AXI Ports
-  MEM_RW(DMC_BASE, 0x20090+0x1000*0)  = 0x000000001;  // PCTRL_0 - [0] - 1 AXI PORT enable
-  MEM_RW(DMC_BASE, 0x20090+0x1000*1)  = 0x000000001;  // PCTRL_0 - [0] - 1 AXI PORT enable
-  while ((MEM_RW(DMC_BASE, 0x10090)&0x1)  ==1 );  // MRSTAT - wait busy
+#if DMC_WCK_ALWAYS_ON
+
+MEM_RW(DMC_BASE, UMCTL5_RANKTMG0) = 0x00000b07;
+MEM_RW(DMC_BASE, UMCTL5_RANKTMG1) = 0x00001102;
+MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG0) = 0x2b101b22;// 0x35101b22;
+MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG1) = 0x00060630; //0x00060633;
+MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG2) = 0x0C17141A;                   // WL 12 RL - 23!!!!!!!
+MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG3) = 0x000c2732;
+MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG4) = 0x0f04040f; //0x0f040412;                 // t_rcd = 15 t_ccd_l = 4 t_rrd_l = 4 t_rp = 18
+MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG5) = 0x02040c01;
+MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG6) = 0x00000008;
+MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG7) = 0x00000003;
+  
+MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG9) = 0x00020415; //0x00020419;    // tccd_s = 2 t_rrd_s = 4 twr2rd_s = 27
+MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG12) = 0x00030000;
+MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG13) = 0x0C100002; //0x13100002;
+MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG14) = 0x000000e6; //0x0020006e;
+MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG23) = 0x009d0bcc; //0x009d05cf;
+MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG24) = 0x00111C11;  // rd2wr diff bank group is artificially low here , should be x12 but Synopsys DMC seems to truncate value above x11 in some way.
+MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG25) = 0x00002b08;   
+MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG30) = 0x00191218;// 0x00190b18;
+MEM_RW(DMC_BASE, UMCTL5_DFITMG0) = 0x063f001f;           //1f           // tctldelay = 6 trddataen = 39 tphywrdata = 0 tphywrlat = 47 - try 35 this represented 16 , now 31// old latency pass
+MEM_RW(DMC_BASE, UMCTL5_DFITMG1) = 0x00140606;
+MEM_RW(DMC_BASE, UMCTL5_DFITMG2) = 0x00243f1f;
+MEM_RW(DMC_BASE, UMCTL5_DFITMG4) = 0x180c0402;
+MEM_RW(DMC_BASE, UMCTL5_DFITMG5) = 0x04100006;
+
+
+
+#else // !DMC_WCK_ALWAYS_ON
+
+// Highlighted with ! is all values that needed to be changed when changing read/write latency in line with lpddr5x spec
+  MEM_RW(DMC_BASE, UMCTL5_RANKTMG0) = 0x00000e12;
+  MEM_RW(DMC_BASE, UMCTL5_RANKTMG1) = 0x00000f11;
+  MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG0) = 0x35101b22;
+  MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG1) = 0x00060633;
+  MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG2) = 0x16170a24;                   // !WL = 22 !RL = 23  rd2wr = 10    !wr2rd = 36
+  MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG3) = 0x000c923C;                 // !rd2mr = 146        !wr2mr = 60
+  MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG4) = 0x0f040412;                 // t_rcd = 15 t_ccd_l = 4 t_rrd_l = 4 t_rp = 18
+  MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG5) = 0x02040c01;
+  MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG6) = 0x00000008;
+  MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG7) = 0x00000003;
+    
+  MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG9) = 0x0002041F;                  // tccd_s = 2 t_rrd_s = 4 !twr2rd_s = 31
+  MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG12) = 0x00030000;
+  MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG13) = 0x13100002;
+  MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG14) = 0x0020006e;
+  MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG23) = 0x009d05cf;
+  MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG24) = 0x00081C1B;                   //4Bank/4BG  !rd_sync=28    !wr_sync =27
+  MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG25) = 0x00003508;                  // !wra2pre= 53       !rda2pre =8(nrbtp) 
+  MEM_RW(DMC_BASE, UMCTL5_DRAMSET1TMG30) = 0x00190b18;
+  MEM_RW(DMC_BASE, UMCTL5_DFITMG0) = 0x0627083f;                      // tctldelay = 6 phy_dfi_clk = 1 trddataen = 39 !tphywrdata = 8 !tphywrlat = 63               
+  MEM_RW(DMC_BASE, UMCTL5_DFITMG1) = 0x001A0606;                      // !dfi_t_wrdata_delay = 10
+  MEM_RW(DMC_BASE, UMCTL5_DFITMG2) = 0x00243f3b;
+  MEM_RW(DMC_BASE, UMCTL5_DFITMG4) = 0x1C2C0400;
+  MEM_RW(DMC_BASE, UMCTL5_DFITMG5) = 0x0410000C;
+
+#endif // !DMC_WCK_ALWAYS_ON
+  
 
-#endif
+#ifdef QOS_DISABLE
+  MEM_RW(DMC_BASE, UMCTL5_PCFGQOS0+0x1000*0) = 0x02000e00;          // RQOS region2>d region1>8
+  MEM_RW(DMC_BASE, UMCTL5_PCFGQOS1+0x1000*0) = 0x03ff03ff;
+  MEM_RW(DMC_BASE, UMCTL5_PCFGWQOS0+0x1000*0) = 0x00000e00;         // WQOS region2>d region1>8
+  MEM_RW(DMC_BASE, UMCTL5_PCFGWQOS1+0x1000*0) = 0x03ff03ff;
+
+  MEM_RW(DMC_BASE, UMCTL5_PCFGQOS0+0x1000*1) = 0x02000e00;          // RQOS region2>d region1>8
+  MEM_RW(DMC_BASE, UMCTL5_PCFGQOS1+0x1000*1) = 0x03ff03ff;
+  MEM_RW(DMC_BASE, UMCTL5_PCFGWQOS0+0x1000*1) = 0x00000e00;         // WQOS region2>d region1>8
+  MEM_RW(DMC_BASE, UMCTL5_PCFGWQOS1+0x1000*1) = 0x03ff03ff;
+
+  MEM_RW(DMC_BASE, 0x20004+0x1000*0) = 0x000143ff;                  // RQOS region2>d region1>8
+  MEM_RW(DMC_BASE, 0x20004+0x1000*1) = 0x000143ff;                  // RQOS region2>d region1>8
+#else // !QOS_DISABLE
+  MEM_RW(DMC_BASE, UMCTL5_PCFGQOS0+0x1000*0) = 0x02100d08;          // RQOS region2>d region1>8
+  MEM_RW(DMC_BASE, UMCTL5_PCFGQOS1+0x1000*0) = UMCTL_VP_TIMEOUT;    // RQOS timeoutr timeoutb
+  MEM_RW(DMC_BASE, UMCTL5_PCFGWQOS0+0x1000*0) = 0x01000908;         // WQOS region2>d region1>8
+  MEM_RW(DMC_BASE, UMCTL5_PCFGWQOS1+0x1000*0) = UMCTL_VP_WTIMEOUT;  // WQOS region2>0 region1>0
+
+  MEM_RW(DMC_BASE, UMCTL5_PCFGQOS0+0x1000*1) = 0x02100d08;          // RQOS region2>d region1>8
+  MEM_RW(DMC_BASE, UMCTL5_PCFGQOS1+0x1000*1) = UMCTL_VP_TIMEOUT;    // PCFGQOS1 - timeoutr timeoutb
+  MEM_RW(DMC_BASE, UMCTL5_PCFGWQOS0+0x1000*1) = 0x01000a00;         // WQOS region2>d region1>8
+  MEM_RW(DMC_BASE, UMCTL5_PCFGWQOS1+0x1000*1) = UMCTL_VP_WTIMEOUT;  // WQOS region2>0 region1>0
+
+  MEM_RW(DMC_BASE, 0x20004+0x1000*0) = 0x000143ff;                  // RQOS region2>d region1>8
+  MEM_RW(DMC_BASE, 0x20004+0x1000*1) = 0x000153ff;                  // RQOS region2>d region1>8
+#endif // !QOS_DISABLE
+            
+            
+   
+    
+  // Create contiguous address space for armalt map
+  // In this instance middle region is split in a way that doesn't wholly match the regions
+  // But it is fine for up to 32GB of space, having the regions touching or going over 1TB 
+  // Causes issues for the controller, but we need 4 regions to handle the full std map
+  MEM_RW(DMC_BASE, UMCTL5_SWCTLSTATIC) = 0x1;
+  MEM_RW(DMC_BASE, UMCTL5_SARBASE0) = 1; // 2GB      0x0000_8000_0000
+  MEM_RW(DMC_BASE, UMCTL5_SARBASE1) = 257; // 514GB  0x0080_8000_0000
+  MEM_RW(DMC_BASE, UMCTL5_SARBASE2) = 278; // 536GB
+  MEM_RW(DMC_BASE, UMCTL5_SARBASE3) = 500; // 1TB
+  MEM_RW(DMC_BASE, UMCTL5_SARSIZE0) = 1-1; // 2GB
+  MEM_RW(DMC_BASE, UMCTL5_SARSIZE1) = 20; // 22GB
+  MEM_RW(DMC_BASE, UMCTL5_SARSIZE2) = 10; // 12GB
+  MEM_RW(DMC_BASE, UMCTL5_SARSIZE3) = 271-1; // 542GB
+  MEM_RW(DMC_BASE, UMCTL5_SWCTLSTATIC) = 0x0;
+  
+  
+  
+                                               // Enable AXI Ports
+  MEM_RW(DMC_BASE, UMCTL5_PCTRL+0x1000*0) = 0x1;                    // PCTRL_0 - [0] - 1 AXI PORT enable
+  MEM_RW(DMC_BASE, UMCTL5_PCTRL+0x1000*1) = 0x1;                    // PCTRL_0 - [0] - 1 AXI PORT enable
+
+  while ((MEM_RW(DMC_BASE, UMCTL5_MRSTAT) & 1) == 1)
+      ;
diff --git a/module/snps_umctl/include/snps_defines.h b/module/snps_umctl/include/snps_defines.h
index c2fec991..51736d5c 100644
--- a/module/snps_umctl/include/snps_defines.h
+++ b/module/snps_umctl/include/snps_defines.h
@@ -1,155 +1,104 @@
 
-#ifdef SNPS_VIP_FW
 
-#ifndef UMCTL2_DEFINES_H
-#define UMCTL2_DEFINES_H
-
-
-#ifndef UMCTL_HPR_STARVE
-#define UMCTL_HPR_STARVE 0x1 // reset value
-#endif
-
-#ifndef UMCTL_HPR_XACT_RUN_LENGTH
-#define UMCTL_HPR_XACT_RUN_LENGTH 0xf // reset value
-#endif
-
-//PERFLPR1
-#ifndef UMCTL_LPR_STARVE
-#define UMCTL_LPR_STARVE 0x1ff // reset value
-#endif
-
-#ifndef UMCTL_LPR_XACT_RUN_LENGTH
-#define UMCTL_LPR_XACT_RUN_LENGTH 0x40 // reset value
-#endif
-
-//PERFWR1
-#ifndef UMCTL_WR_STARVE
-#define UMCTL_WR_STARVE 0x3ff // reset value
-#endif
+#ifndef UMCTL_DEFINES_H
+#define UMCTL_DEFINES_H
 
-#ifndef UMCTL_WR_XACT_RUN_LENGTH
-#define UMCTL_WR_XACT_RUN_LENGTH 0x10 // reset value
+//SCHED0
+#ifndef UMCTL_OPT_VPRW_SCH 
+#define UMCTL_OPT_VPRW_SCH 1
 #endif
 
-
-#ifndef UMCTL2_RDWR_IDLE_GAP
-#define UMCTL2_RDWR_IDLE_GAP 0
+#ifndef UMCTL_LPR_NUM_ENTRIES 
+#define UMCTL_LPR_NUM_ENTRIES 0x0000003f
 #endif
 
-#ifndef UMCTL2_LPR_NUM_ENTRIES
-#define UMCTL2_LPR_NUM_ENTRIES 2
+#ifndef UMCTL_OPT_WRCAM_FILL_LEVEL 
+#define UMCTL_OPT_WRCAM_FILL_LEVEL 1
 #endif
 
-#ifndef UMCTL2_OPT_WRCAM_FILL_LEVEL
-#define UMCTL2_OPT_WRCAM_FILL_LEVEL 1
+//SCHED1
+#ifndef UMCTL_PAGE_HIT_LIMIT_RD 
+#define UMCTL_PAGE_HIT_LIMIT_RD 0 // reset default function disabled
 #endif
 
-#ifndef UMCTL2_ENHANCED_RW
-#define UMCTL2_ENHANCED_RW 1
+#ifndef UMCTL_PAGE_HIT_LIMIT_WR  
+#define UMCTL_PAGE_HIT_LIMIT_WR 0 // reset default function disabled
 #endif
 
-#ifndef UMCTL2_PC_TIMER
-#define UMCTL2_PC_TIMER 0x20
+#ifndef UMCTL_WINDOW_LIMIT_RD 
+#define UMCTL_WINDOW_LIMIT_RD 0 // reset value
 #endif
 
-#ifndef UMCTL2_FORCE_LOW_PRI
-#define UMCTL2_FORCE_LOW_PRI 1
+#ifndef UMCTL_WINDOW_LIMIT_WR 
+#define UMCTL_WINDOW_LIMIT_WR 0 // reset value
 #endif
 
-#ifndef UMCTL2_DELAY_SWITCH_WRITE
-#define UMCTL2_DELAY_SWITCH_WRITE 2
+#ifndef UMCTL_DELAY_SWITCH_WRITE
+#define UMCTL_DELAY_SWITCH_WRITE 2 // reset value
 #endif
 
-#ifndef UMCTL2_RD_PGHIT_NUM_THRESH
-#define UMCTL2_RD_PGHIT_NUM_THRESH 4
+//SCHED3
+#ifndef UMCTL_RD_PGHIT_NUM_THRESH 
+#define UMCTL_RD_PGHIT_NUM_THRESH 4 // 
 #endif
 
-#ifndef UMCTL2_WR_PGHIT_NUM_THRESH
-#define UMCTL2_WR_PGHIT_NUM_THRESH 4
+#ifndef UMCTL_WR_PGHIT_NUM_THRESH 
+#define UMCTL_WR_PGHIT_NUM_THRESH 4 // 
 #endif
 
-#ifndef UMCTL2_WRCAM_HIGHTHRESH
-#define UMCTL2_WRCAM_HIGHTHRESH 2
+#ifndef UMCTL_WRCAM_HIGHTHRESH 
+#define UMCTL_WRCAM_HIGHTHRESH 2   // should be increased for larger cam sizes
 #endif
 
-#ifndef UMCTL2_WRCAM_LOWTHRESH
-#define UMCTL2_WRCAM_LOWTHRESH 32
+#ifndef UMCTL_WRCAM_LOWTHRESH 
+#define UMCTL_WRCAM_LOWTHRESH 8    // should be increased for larger cam sizes
 #endif
 
-#ifndef UMCTL2_WR_ACT_GAP
-#define UMCTL2_WR_ACT_GAP 16
-#endif
 
-#ifndef UMCTL2_RD_ACT_GAP
-#define UMCTL2_RD_ACT_GAP 128
+//SCHED4
+#ifndef UMCTL_WR_ACT_GAP 
+#define UMCTL_WR_ACT_GAP 8 // 
 #endif
 
-#ifndef UMCTL_PAGE_HIT_LIMIT_RD
-#define UMCTL_PAGE_HIT_LIMIT_RD 0
+#ifndef UMCTL_RD_ACT_GAP 
+#define UMCTL_RD_ACT_GAP 0x10 // 
 #endif
 
-#ifndef UMCTL_PAGE_HIT_LIMIT_WR
-#define UMCTL_PAGE_HIT_LIMIT_WR 0
-#endif
-
-#ifndef UMCTL_WINDOW_LIMIT_RD
-#define UMCTL_WINDOW_LIMIT_RD 0
+//SCHEDTMG0
+#ifndef UMCTL_RDWR_IDLE_GAP 
+#define UMCTL_RDWR_IDLE_GAP 0
 #endif
 
-#ifndef UMCTL_WINDOW_LIMIT_WR
-#define UMCTL_WINDOW_LIMIT_WR 0
+#ifndef UMCTL_PC_TIMER 
+#define UMCTL_PC_TIMER 0
 #endif
 
-#ifndef UMCTL2_VP_TIMEOUT
-#define UMCTL2_VP_TIMEOUT 0x000f000f
-#endif
 
+//RANKCTL
+#ifndef UMCTL_MAX_RANK_WR
+#define UMCTL_MAX_RANK_WR 0x0 // reset value
 #endif
 
-#else //SNPS_VIP_FW
 
-#ifndef UMCTL_DEFINES_H
-#define UMCTL_DEFINES_H
-
-#ifndef BA_BEFORE_BG
-#define BA_BEFORE_BG 1
-#endif
-#ifndef DMC_WCK_ALWAYS_ON
-#define DMC_WCK_ALWAYS_ON 1
-#endif
-#ifndef QOS_DISABLE
-#define QOS_DISABLE 0
-#endif
-
-#ifndef UMCTL_RDWR_IDLE_GAP
-#define UMCTL_RDWR_IDLE_GAP 0
-#endif
-
-#ifndef UMCTL_LPR_NUM_ENTRIES
-#ifdef QOS_DISABLE
-#define UMCTL_LPR_NUM_ENTRIES 63
-#else
-#define UMCTL_LPR_NUM_ENTRIES 2
-#endif
-#endif
-
-#ifndef UMCTL_OPT_WRCAM_FILL_LEVEL
-#define UMCTL_OPT_WRCAM_FILL_LEVEL 1
+//UMCTL2 SCHED
+#ifndef UMCTL_FORCE_LOW_PRI 
+#define UMCTL_FORCE_LOW_PRI 1
 #endif
 
-#ifndef UMCTL_ENHANCED_RW
-#define UMCTL_ENHANCED_RW 1
+//PCHBCBUSYH/L/W
+#ifndef UMCTL_CBUSY_MID  // must be overwritten for larger CAM sizes
+#define UMCTL_CBUSY_BUSY 2
+#define UMCTL_CBUSY_MID  5
+#define UMCTL_CBUSY_FREE 7
 #endif
 
-#ifndef UMCTL_PC_TIMER
-#define UMCTL_PC_TIMER 0x20
-#endif
 
+//PERFHPR1
 #ifndef UMCTL_HPR_STARVE
 #define UMCTL_HPR_STARVE 0x1 // reset value
 #endif
 
-#ifndef UMCTL_HPR_XACT_RUN_LENGTH
+#ifndef UMCTL_HPR_XACT_RUN_LENGTH 
 #define UMCTL_HPR_XACT_RUN_LENGTH 0xf // reset value
 #endif
 
@@ -158,7 +107,7 @@
 #define UMCTL_LPR_STARVE 0x1ff // reset value
 #endif
 
-#ifndef UMCTL_LPR_XACT_RUN_LENGTH
+#ifndef UMCTL_LPR_XACT_RUN_LENGTH 
 #define UMCTL_LPR_XACT_RUN_LENGTH 0x40 // reset value
 #endif
 
@@ -167,66 +116,17 @@
 #define UMCTL_WR_STARVE 0x3ff // reset value
 #endif
 
-#ifndef UMCTL_WR_XACT_RUN_LENGTH
+#ifndef UMCTL_WR_XACT_RUN_LENGTH 
 #define UMCTL_WR_XACT_RUN_LENGTH 0x10 // reset value
 #endif
 
-#ifndef UMCTL_FORCE_LOW_PRI
-#define UMCTL_FORCE_LOW_PRI 1
-#endif
-
-#ifndef UMCTL_DELAY_SWITCH_WRITE
-#define UMCTL_DELAY_SWITCH_WRITE 0
-#endif
-
-#ifndef UMCTL_RD_PGHIT_NUM_THRESH
-#define UMCTL_RD_PGHIT_NUM_THRESH 4
-#endif
-
-#ifndef UMCTL_WR_PGHIT_NUM_THRESH
-#define UMCTL_WR_PGHIT_NUM_THRESH 8
-#endif
-
-#ifndef UMCTL_WRCAM_HIGHTHRESH
-#define UMCTL_WRCAM_HIGHTHRESH 16
-#endif
-
-#ifndef UMCTL_WRCAM_LOWTHRESH
-#define UMCTL_WRCAM_LOWTHRESH 32
-#endif
-
-#ifndef UMCTL_WR_ACT_GAP
-#define UMCTL_WR_ACT_GAP 0
-#endif
-
-#ifndef UMCTL_RD_ACT_GAP
-#define UMCTL_RD_ACT_GAP 0
-#endif
-
-#ifndef UMCTL_PAGE_HIT_LIMIT_RD
-#define UMCTL_PAGE_HIT_LIMIT_RD 0
-#endif
-
-#ifndef UMCTL_PAGE_HIT_LIMIT_WR
-#define UMCTL_PAGE_HIT_LIMIT_WR 0
-#endif
-
-#ifndef UMCTL_WINDOW_LIMIT_RD
-#define UMCTL_WINDOW_LIMIT_RD 0
-#endif
-
-#ifndef UMCTL_WINDOW_LIMIT_WR
-#define UMCTL_WINDOW_LIMIT_WR 0
-#endif
-
+//PCFGQOS1
 #ifndef UMCTL_VP_TIMEOUT
-#define UMCTL_VP_TIMEOUT 0x000f000f
+#define UMCTL_VP_TIMEOUT 0x03c003c0
 #endif
 
 #ifndef UMCTL_VP_WTIMEOUT
-#define UMCTL_VP_WTIMEOUT 0x000f000f
+#define UMCTL_VP_WTIMEOUT 0x03e803e8
 #endif
 
 #endif
-
-#endif //SNPS_VIP_FW
diff --git a/module/snps_umctl/include/test_defs.h b/module/snps_umctl/include/test_defs.h
index 2e94ab8f..01ae1863 100644
--- a/module/snps_umctl/include/test_defs.h
+++ b/module/snps_umctl/include/test_defs.h
@@ -3,7 +3,7 @@
 
 
 #define HCG 1       // Enable High Level Clock Gating
-
+  
 
 //Clock Divider Settings
 #define CCI_NO_SCP
@@ -25,7 +25,7 @@
 #define CPUASI0_WR_QOS   0x80020057
 #define CPUASI1_RD_QOS   0x80020057
 #define CPUASI1_WR_QOS   0x80020057
-
+      
 #define GPUASI0_RD_QOS   0x4
 #define GPUASI0_WR_QOS   0x4
 #define GPUASI1_RD_QOS   0x4
@@ -55,7 +55,7 @@
 
 #ifndef ROS_COMPONENT
 #define DMC_PHY_BASE_ADDR   0xA8000000
-#else
+#else 
 #define DMC_PHY_BASE_ADDR   0x9Fb60000
 #endif
 
@@ -63,7 +63,6 @@
 #define UMCTL2_INIT_FUN     "umctl2_lpddr4_3200.h"
 #define MULTI_PORT
 #define UMCTL2_PC_TIMER            0x00000020
-//#define UMCTL2_LPR_NUM_ENTRIES     0x00000010
 #define UMCTL2_VP_TIMEOUT          0x03c003c0
 #define UMCTL2_VP_WTIMEOUT         0x03e803e8
 #define UMCTL2_PORT1_TIMEOUT       0x00004000
@@ -78,9 +77,9 @@
 #define DMC_FMT_CTRL_ALIGN_BOUNDARY 1
 #define DMC_PHY_SYNCUP 1
 #define DMC_ACCESS_GRAN 1
-#define DMC_COL_BITS 1         // 10 col bits -1 for syncup
-#define DMC_BANK_BITS 0        // 8 banks
-#define DMC_RANK_BITS 1        // 2 ranks
+//#define DMC_COL_BITS 1         // 10 col bits -1 for syncup
+//#define DMC_BANK_BITS 0        // 8 banks
+//#define DMC_RANK_BITS 1        // 2 ranks
 #define DMC_BANK_GROUP 0       // 0 bank groups
 #define MEM_CHANNEL 4
 #define DMC_ADDR_SHUTTER 2
@@ -91,28 +90,40 @@
 #define DMC_HASH_ENABLE 1
 #endif
 
-
 #define DMC_ADDR_DEC 1 //rcb
-
+  
 // LPDDR4-4267 x16 (cernan)
 #define LPDDR4_4267
 #define DMC_DEVICE_WIDTH 2 // x16
 #define DMC_MEM_BURST 3        // 32 on the fly
-#define DMC_MEM_TYPE 3         // LPDDR4
-#define DMC_ROW_BITS 5         // 16 row bits
+#define DMC_MEM_TYPE 4         // LPDDR5
   #define DPU_TRANS_LENGTH 8
 
-// UMCTL2 specific values
-#define UMCTL2_RDWR_IDLE_GAP          0x40
-#define UMCTL2_LPR_NUM_ENTRIES        0x00
-#define UMCTL2_WR_ACT_GAP             0x00
-#define UMCTL2_RD_ACT_GAP             0x00
-#define UMCTL2_RD_PGHIT_NUM_THRESHOLD 0x08
-#define UMCTL2_DELAY_SWITCH_WRITE     0x0F
 
-#define NPU0_BASE 0x050000000
+// UMCTL specific values
+#define UMCTL_PC_TIMER      0x0
+
+#define UMCTL_LPR_CREDIT    0x20
+#define UMCTL_WR_ACT_GAP    16 
+#define UMCTL_RD_ACT_GAP    128
 
+#define UMCTL_RD_PGHIT_NUM_THRESH 0x00000000
+#define UMCTL_WR_PGHIT_NUM_THRESH 0x00000000
+#define UMCTL_RDWR_IDLE_GAP       0x00000010
 
+#define UMCTL_DELAY_SWITCH_WRITE  0x00000004
+
+#define UMCTL_VP_TIMEOUT          0x03c003c0
+#define UMCTL_VP_WTIMEOUT         0x03e803e8
+#define UMCTL_PORT1_TIMEOUT       0x00004000
+
+#define SYSTEM_PIK_DMC_DATA_RESET_OFFSET  0x0B14
+
+#define QOS_DISABLE TRUE
+#define DMC_WCK_ALWAYS_ON 1
+#define UMCTL_LPR_STARVE                  0x1ff
+
+#define NPU0_BASE 0x050000000
 
 #define SDRAM_BASE_ADDR               0x80000000
 #define SDRAM_HIGH_ADDR               0x880000000
@@ -127,3 +138,4 @@
 #define CPUFREQ 2700
 
 #endif // TEST_DEFS_H
+
diff --git a/module/snps_umctl/include/umctl5_registers.h b/module/snps_umctl/include/umctl5_registers.h
new file mode 100644
index 00000000..10e3f071
--- /dev/null
+++ b/module/snps_umctl/include/umctl5_registers.h
@@ -0,0 +1,335 @@
+#ifndef _UMCTL5_REGISTERS_H
+#define _UMCTL5_REGISTERS_H
+
+//REGB_FREQ0_CH0 registers
+#define UMCTL5_DRAMSET1TMG0                0x00000
+#define UMCTL5_DRAMSET1TMG1                0x00004
+#define UMCTL5_DRAMSET1TMG2                0x00008
+#define UMCTL5_DRAMSET1TMG3                0x0000c
+#define UMCTL5_DRAMSET1TMG4                0x00010
+#define UMCTL5_DRAMSET1TMG5                0x00014
+#define UMCTL5_DRAMSET1TMG6                0x00018
+#define UMCTL5_DRAMSET1TMG7                0x0001c
+#define UMCTL5_DRAMSET1TMG8                0x00020
+#define UMCTL5_DRAMSET1TMG9                0x00024
+#define UMCTL5_DRAMSET1TMG10               0x00028
+#define UMCTL5_DRAMSET1TMG11               0x0002c
+#define UMCTL5_DRAMSET1TMG12               0x00030
+#define UMCTL5_DRAMSET1TMG13               0x00034
+#define UMCTL5_DRAMSET1TMG14               0x00038
+#define UMCTL5_DRAMSET1TMG15               0x0003c
+#define UMCTL5_DRAMSET1TMG16               0x00040
+#define UMCTL5_DRAMSET1TMG18               0x00048
+#define UMCTL5_DRAMSET1TMG19               0x0004c
+#define UMCTL5_DRAMSET1TMG20               0x00050
+#define UMCTL5_DRAMSET1TMG21               0x00054
+#define UMCTL5_DRAMSET1TMG22               0x00058
+#define UMCTL5_DRAMSET1TMG23               0x0005c
+#define UMCTL5_DRAMSET1TMG24               0x00060
+#define UMCTL5_DRAMSET1TMG25               0x00064
+#define UMCTL5_DRAMSET1TMG26               0x00068
+#define UMCTL5_DRAMSET1TMG27               0x0006c
+#define UMCTL5_DRAMSET1TMG28               0x00070
+#define UMCTL5_DRAMSET1TMG29               0x00074
+#define UMCTL5_DRAMSET1TMG30               0x00078
+#define UMCTL5_DRAMSET1TMG31               0x0007c
+
+#define UMCTL5_RANK_SWITCH_TIMING_CONTROL0 0x00400
+#define UMCTL5_RANK_SWITCH_TIMING_CONTROL1 0x00404
+#define UMCTL5_RANK_SWITCH_TIMING_CONTROL2 0x00408
+#define UMCTL5_RANK_SWITCH_TIMING_CONTROL3 0x0040c
+#define UMCTL5_RANK_SWITCH_TIMING_CONTROL4 0x00410
+#define UMCTL5_RANK_SWITCH_TIMING_CONTROL5 0x00414
+
+#define UMCTL5_INITMR0                     0x00500
+#define UMCTL5_INITMR1                     0x00504
+#define UMCTL5_INITMR2                     0x00508
+#define UMCTL5_INITMR3                     0x0050c
+#define UMCTL5_DFITMG0                     0x00580
+#define UMCTL5_DFITMG1                     0x00584
+#define UMCTL5_DFITMG2                     0x00588
+#define UMCTL5_DFITMG3                     0x0058c
+#define UMCTL5_DFITMG4                     0x00590
+#define UMCTL5_DFITMG5                     0x00594
+#define UMCTL5_DFITMG6                     0x00598
+#define UMCTL5_DFITMG7                     0x0059c
+#define UMCTL5_DFILPTMG0                   0x005a0
+#define UMCTL5_DFILPTMG1                   0x005a4
+#define UMCTL5_DFIUPDTMG0                  0x005a8
+#define UMCTL5_DFIUPDTMG1                  0x005ac
+
+#define UMCTL5_RFSHSET1TMG0                0x00600
+#define UMCTL5_RFSHSET1TMG1                0x00604
+#define UMCTL5_RFSHSET1TMG2                0x00608
+#define UMCTL5_RFSHSET1TMG3                0x0060c
+#define UMCTL5_RFSHSET1TMG4                0x00610
+#define UMCTL5_RFSHSET1TMG5                0x00614
+#define UMCTL5_RFSHSET1TMG6                0x00618
+#define UMCTL5_RFSHSET1TMG7                0x0061c
+#define UMCTL5_RFSHSET1TMG9                0x00624
+
+#define UMCTL5_ZQSET1TMG0                  0x00800
+#define UMCTL5_ZQSET1TMG1                  0x00804
+#define UMCTL5_HWLPTMG0                    0x00b80
+
+#define UMCTL5_SCHEDTMG0                   0x00c00
+#define UMCTL5_PERFHPR1                    0x00c80
+#define UMCTL5_PERFLPR1                    0x00c84
+
+#define UMCTL5_PERFWR1                     0x00c88
+#define UMCTL5_TMGCFG                      0x00d00
+#define UMCTL5_RANKTMG0                    0x00d04
+#define UMCTL5_RANKTMG1                    0x00d08
+#define UMCTL5_PWRTMG                      0x00d0c
+#define UMCTL5_ODTCFG                      0x00d10
+#define UMCTL5_CRCPARTMG0                  0x00d14
+#define UMCTL5_CRCPARTMG1                  0x00d18
+
+//REGB_DDRC_CH0 Registers
+#define UMCTL5_MSTR0                       0x10000
+#define UMCTL5_MSTR1                       0x10004
+#define UMCTL5_MSTR2                       0x10008
+#define UMCTL5_MSTR3                       0x1000c
+#define UMCTL5_MSTR4                       0x10010
+#define UMCTL5_STAT                        0x10014
+#define UMCTL5_STAT2                       0x10018
+#define UMCTL5_STAT3                       0x1001c
+#define UMCTL5_MRCTRL0                     0x10080
+#define UMCTL5_MRCTRL1                     0x10084
+#define UMCTL5_MRCTRL2                     0x10088
+#define UMCTL5_MRSTAT                      0x10090
+#define UMCTL5_DERATECTL1                  0x10104
+#define UMCTL5_DERATECTL2                  0x10108
+#define UMCTL5_DERATECTL3                  0x1010c
+#define UMCTL5_DERATECTL4                  0x10110
+#define UMCTL5_DERATECTL5                  0x10114
+#define UMCTL5_DERATECTL6                  0x10118
+#define UMCTL5_DERATESTAT0                 0x1011c
+#define UMCTL5_DERATESTAT1                 0x10120
+#define UMCTL5_DERATEDBGCTL                0x10124
+#define UMCTL5_DERATEDBGSTAT               0x10128
+#define UMCTL5_PWRCTL                      0x10180
+#define UMCTL5_HWLPCTL                     0x10184
+#define UMCTL5_HWLPCTL2                    0x10188
+#define UMCTL5_RFSHMOD0                    0x10200
+#define UMCTL5_RFSHMOD1                    0x10204
+#define UMCTL5_RFSHCTL0                    0x10208
+#define UMCTL5_ZQCTL0                      0x10280
+#define UMCTL5_ZQCTL2                      0x10288
+#define UMCTL5_DQSOSCCFG0                  0x10308
+#define UMCTL5_DQSOSCTMG0                  0x1030c
+#define UMCTL5_SCHED0                      0x10380
+#define UMCTL5_SCHED1                      0x10384
+#define UMCTL5_SCHED3                      0x1038c
+#define UMCTL5_SCHED4                      0x10390
+#define UMCTL5_DFILPCFG0                   0x10500
+#define UMCTL5_DFIUPD0                     0x10508
+#define UMCTL5_DFIMISC                     0x10510
+#define UMCTL5_DFISTAT                     0x10514
+#define UMCTL5_DFIPHYMSTR                  0x10518
+#define UMCTL5_ECCCFG0                     0x10600
+#define UMCTL5_ECCCFG1                     0x10604
+#define UMCTL5_ECCSTAT                     0x10608
+#define UMCTL5_ECCCTL                      0x1060c
+#define UMCTL5_ECCERRCNT                   0x10610
+#define UMCTL5_ECCCADDR0                   0x10614
+#define UMCTL5_ECCCADDR1                   0x10618
+#define UMCTL5_ECCCSYN0                    0x1061c
+#define UMCTL5_ECCCSYN1                    0x10620
+#define UMCTL5_ECCCSYN2                    0x10624
+#define UMCTL5_ECCBITMASK0                 0x10628
+#define UMCTL5_ECCBITMASK1                 0x1062c
+#define UMCTL5_ECCBITMASK2                 0x10630
+#define UMCTL5_ECCUADDR0                   0x10634
+#define UMCTL5_ECCUADDR1                   0x10638
+#define UMCTL5_ECCUSYN0                    0x1063c
+#define UMCTL5_ECCUSYN1                    0x10640
+#define UMCTL5_ECCUSYN2                    0x10644
+#define UMCTL5_ECCPOISONADDR0              0x10648
+#define UMCTL5_ECCPOISONADDR1              0x1064c
+#define UMCTL5_ECCPOISONPAT0               0x10658
+#define UMCTL5_ECCPOISONPAT2               0x10660
+#define UMCTL5_ECCCFG2                     0x10668
+#define UMCTL5_CRCPARCTL0                  0x10800
+#define UMCTL5_CRCPARCTL1                  0x10804
+#define UMCTL5_CRCPARCTL2                  0x10808
+#define UMCTL5_CRCPARSTAT                  0x1080c
+#define UMCTL5_CAPARPOISONCTL              0x10810
+#define UMCTL5_CAPARPOISONSTAT             0x10814
+#define UMCTL5_CRCPOISONCTL0               0x10820
+#define UMCTL5_CRCPOISONSTAT               0x1082c
+#define UMCTL5_RDCRCERRADDR0               0x10830
+#define UMCTL5_RDCRCERRADDR1               0x10834
+#define UMCTL5_RDCRCERRSTAT0               0x10840
+#define UMCTL5_CRCSTAT0                    0x10848
+#define UMCTL5_CRCSTAT1                    0x1084c
+#define UMCTL5_CRCSTAT2                    0x10850
+#define UMCTL5_CRCSTAT3                    0x10854
+#define UMCTL5_CRCSTAT4                    0x10858
+#define UMCTL5_CRCSTAT10                   0x10870
+#define UMCTL5_PASCTL0                     0x10a00
+#define UMCTL5_PASCTL1                     0x10a04
+#define UMCTL5_PASCTL2                     0x10a08
+#define UMCTL5_PASCTL3                     0x10a0c
+#define UMCTL5_PASCTL4                     0x10a10
+#define UMCTL5_PASCTL5                     0x10a14
+#define UMCTL5_PASCTL6                     0x10a18
+#define UMCTL5_PASCTL7                     0x10a1c
+#define UMCTL5_PASCTL8                     0x10a20
+#define UMCTL5_PASCTL9                     0x10a24
+#define UMCTL5_PASCTL10                    0x10a28
+#define UMCTL5_PASCTL11                    0x10a2c
+#define UMCTL5_PASCTL12                    0x10a30
+#define UMCTL5_PASCTL13                    0x10a34
+#define UMCTL5_PASCTL14                    0x10a38
+#define UMCTL5_PASCTL15                    0x10a3c
+#define UMCTL5_PASCTL16                    0x10a40
+#define UMCTL5_PASCTL17                    0x10a44
+#define UMCTL5_PASCTL18                    0x10a48
+#define UMCTL5_PASCTL19                    0x10a4c
+#define UMCTL5_PASCTL20                    0x10a50
+#define UMCTL5_PASCTL21                    0x10a54
+#define UMCTL5_PASCTL22                    0x10a58
+#define UMCTL5_PASCTL23                    0x10a5c
+#define UMCTL5_PASCTL24                    0x10a60
+#define UMCTL5_PASCTL25                    0x10a64
+#define UMCTL5_PASCTL36                    0x10a90
+#define UMCTL5_PASCTL37                    0x10a94
+#define UMCTL5_CMDCFG                      0x10b00
+#define UMCTL5_CMDCTL                      0x10b04
+#define UMCTL5_CMDEXTCTL                   0x10b08
+#define UMCTL5_CMDSTAT                     0x10b0c
+#define UMCTL5_CMDMRRDATA                  0x10b14
+#define UMCTL5_PASINT                      0x10b18
+#define UMCTL5_PASINTCTL                   0x10b1c
+#define UMCTL5_PASERRSTS                   0x10b20
+#define UMCTL5_DU_CFGBUF_CTRL              0x10b24
+#define UMCTL5_DU_CFGBUF_STAT              0x10b28
+#define UMCTL5_DU_CMDBUF_CTRL              0x10b2c
+#define UMCTL5_DU_CMDBUF_STAT              0x10b30
+#define UMCTL5_LP_CMDBUF_CTRL              0x10b34
+#define UMCTL5_LP_CMDBUF_STAT              0x10b38
+#define UMCTL5_OPCTRL0                     0x10b80
+#define UMCTL5_OPCTRL1                     0x10b84
+#define UMCTL5_OPCTRLCAM                   0x10b88
+#define UMCTL5_OPCTRLCMD                   0x10b8c
+#define UMCTL5_OPCTRLSTAT                  0x10b90
+#define UMCTL5_OPREFCTRL0                  0x10b98
+#define UMCTL5_OPREFSTAT0                  0x10ba0
+#define UMCTL5_SWCTL                       0x10c80
+#define UMCTL5_SWSTAT                      0x10c84
+#define UMCTL5_DIMMCTL                     0x10c88
+#define UMCTL5_CHCTL                       0x10c8c
+#define UMCTL5_RANKCTL                     0x10c90
+#define UMCTL5_DBICTL                      0x10c94
+#define UMCTL5_ODTMAP                      0x10c9c
+#define UMCTL5_SWCTLSTATIC                 0x10ca4
+#define UMCTL5_INITTMG0                    0x10d00
+#define UMCTL5_INITTMG1                    0x10d04
+#define UMCTL5_INITTMG2                    0x10d08
+#define UMCTL5_DS_DBG_CTRL0                0x10d80
+#define UMCTL5_DS_DBG_STAT0                0x10d84
+#define UMCTL5_DS_DBG_STAT1                0x10d88
+#define UMCTL5_DS_DBG_STAT2                0x10d8c
+#define UMCTL5_DS_DBG_STAT3                0x10d90
+#define UMCTL5_DU_DBG_STAT0                0x10d94
+#define UMCTL5_DU_DBG_STAT1                0x10d98
+#define UMCTL5_LC_DBG_STAT0                0x10d9c
+#define UMCTL5_LC_DBG_STAT1                0x10da0
+#define UMCTL5_LC_DBG_STAT2                0x10da4
+#define UMCTL5_LC_DBG_STAT3                0x10da8
+#define UMCTL5_LC_DBG_STAT4                0x10dac
+#define UMCTL5_LC_DBG_STAT5                0x10db0
+#define UMCTL5_LC_DBG_STAT6                0x10db4
+#define UMCTL5_DDRCTL_VER_NUMBER           0x10ff8
+#define UMCTL5_DDRCTL_VER_TYPE             0x10ffc
+
+//REGB_ARB_PORT0 Registers
+#define UMCTL5_PCTRL                       0x20090
+#define UMCTL5_PCFGQOS0                    0x20094
+#define UMCTL5_PCFGQOS1                    0x20098
+#define UMCTL5_PCFGWQOS0                   0x2009c
+#define UMCTL5_PCFGWQOS1                   0x200a0
+#define UMCTL5_SBRCTL                      0x200e0
+#define UMCTL5_SBRSTAT                     0x200e4
+#define UMCTL5_SBRWDATA0                   0x200e8
+#define UMCTL5_SBRSTART0                   0x200f0
+#define UMCTL5_SBRSTART1                   0x200f4
+#define UMCTL5_SBRRANGE0                   0x200f8
+#define UMCTL5_SBRRANGE1                   0x200fc
+#define UMCTL5_SBRSTART0DCH1               0x20100
+#define UMCTL5_SBRSTART1DCH1               0x20104
+#define UMCTL5_SBRRANGE0DCH1               0x20108
+#define UMCTL5_SBRRANGE1DCH1               0x2010c
+#define UMCTL5_PDCH                        0x20110
+#define UMCTL5_PSTAT                       0x20114
+#define UMCTL5_SBRLPCTL                    0x20118
+#define UMCTL5_SBRADDRLOG0                 0x2011c
+#define UMCTL5_SBRADDRLOG1                 0x20120
+#define UMCTL5_SBRADDRRESTORE0             0x20124
+#define UMCTL5_SBRADDRRESTORE1             0x20128
+#define UMCTL5_SBRADDRLOG0DCH1             0x2012c
+#define UMCTL5_SBRADDRLOG1DCH1             0x20130
+#define UMCTL5_SBRADDRRESTORE0DCH1         0x20134
+#define UMCTL5_SBRADDRRESTORE1DCH1         0x20138
+#define UMCTL5_PCHBLCTRL                   0x20900
+#define UMCTL5_PCHBTCTRL                   0x20904
+#define UMCTL5_PCHBPRCTMR                  0x20908
+#define UMCTL5_PCHBPROTQCTL                0x2090c
+#define UMCTL5_PCHBRQOS0                   0x20910
+#define UMCTL5_PCHBRQOS1                   0x20914
+#define UMCTL5_PCHBWQOS0                   0x20918
+#define UMCTL5_PCHBWQOS1                   0x2091c
+#define UMCTL5_PCHBCBUSYH                  0x20920
+#define UMCTL5_PCHBCBUSYL                  0x20924
+#define UMCTL5_PCHBCBUSYW                  0x20928
+#define UMCTL5_PCHBLSTAT0                  0x20980
+#define UMCTL5_PCHBRLSTAT                  0x20990
+#define UMCTL5_PCHBTZCFG                   0x20a00
+#define UMCTL5_PCHBTZACT                   0x20a04
+#define UMCTL5_PCHBTZINTSTS                0x20a08
+#define UMCTL5_PCHBTZINTCLR                0x20a0c
+#define UMCTL5_PCHBTZLOGADDR0              0x20a10
+#define UMCTL5_PCHBTZLOGADDR1              0x20a14
+#define UMCTL5_PCHBTZLOGOP                 0x20a18
+#define UMCTL5_PCHBTZLOGID0                0x20a1c
+#define UMCTL5_PCHBTZLOGID1                0x20a20
+#define UMCTL5_PCHBTZCTRL                  0x20a24
+#define UMCTL5_PCHBTZRSETL0                0x20b00
+#define UMCTL5_PCHBTZRSETH0                0x20b04
+#define UMCTL5_PCHBTZRATTR0                0x20b08
+#define UMCTL5_PCHBTZRSETL1                0x20b10
+#define UMCTL5_PCHBTZRSETH1                0x20b14
+#define UMCTL5_PCHBTZRATTR1                0x20b18
+#define UMCTL5_PCHBTZRSETL2                0x20b20
+#define UMCTL5_PCHBTZRSETH2                0x20b24
+#define UMCTL5_PCHBTZRATTR2                0x20b28
+#define UMCTL5_PCHBTZRSETL3                0x20b30
+#define UMCTL5_PCHBTZRSETH3                0x20b34
+#define UMCTL5_PCHBTZRATTR3                0x20b38
+
+//REGB_ADDR_MAP0 Registers
+#define UMCTL5_ADDRMAP1                    0x30004
+#define UMCTL5_ADDRMAP2                    0x30008
+#define UMCTL5_ADDRMAP3                    0x3000c
+#define UMCTL5_ADDRMAP4                    0x30010
+#define UMCTL5_ADDRMAP5                    0x30014
+#define UMCTL5_ADDRMAP6                    0x30018
+#define UMCTL5_ADDRMAP7                    0x3001c
+#define UMCTL5_ADDRMAP8                    0x30020
+#define UMCTL5_ADDRMAP9                    0x30024
+#define UMCTL5_ADDRMAP10                   0x30028
+#define UMCTL5_ADDRMAP11                   0x3002c
+#define UMCTL5_ADDRMAP12                   0x30030
+
+//SYstem address regions
+#define UMCTL5_SARBASE0   0x200c0
+#define UMCTL5_SARSIZE0   0x200c4
+#define UMCTL5_SARBASE1   0x200c8
+#define UMCTL5_SARSIZE1   0x200cc
+#define UMCTL5_SARBASE2   0x200d0
+#define UMCTL5_SARSIZE2   0x200d4
+#define UMCTL5_SARBASE3   0x200d8
+#define UMCTL5_SARSIZE3   0x200dc
+
+#endif //_UMCTL5_REGISTERS_H
diff --git a/module/snps_umctl/src/mod_snps_umctl.c b/module/snps_umctl/src/mod_snps_umctl.c
index d4a316b1..db18abc3 100644
--- a/module/snps_umctl/src/mod_snps_umctl.c
+++ b/module/snps_umctl/src/mod_snps_umctl.c
@@ -80,6 +80,19 @@
 #define DMC_PHY_OFFSET    0x10000
 #endif
 
+#define DMC_ROW_BITS 16
+
+#define DMC_COL_BITS 10
+#define DMC_BANK_BITS 4
+#define DMC_BG_BITS 2
+#define DMC_RANK_BITS 1
+#define DMC_NUM_LOG2 2
+
+#define DMC_BANK_STRIPE_LOG2  6
+#define DMC_STRIPE_LOG2 8
+#define DMC_ADDR_DEC 1
+#define DMC_DATA_WIDTH_LOG2 1
+
 #define POWER_PERIPH_BASE         ((uint32_t)0x50000000)
 #define PIK_SCP_BASE              (POWER_PERIPH_BASE + 0x0)
 #define PIK_SYSTEM_BASE           (POWER_PERIPH_BASE + 0x40000)
@@ -89,6 +102,50 @@
 
 #ifdef LPDDR5
 
+char get_row_offset(int b) {
+  if (b >= DMC_ROW_BITS) return(0x3f);
+#if DMC_ADDR_DEC == 1 // RCBI
+  else return(DMC_COL_BITS+DMC_BANK_BITS+DMC_RANK_BITS+DMC_NUM_LOG2-6); 
+#else // crbi
+  else return(DMC_COL_BITS+DMC_BANK_BITSS+DMC_NUM_LOG2-6);
+#endif
+  return 0;
+}
+char get_cs_offset(int b) {
+  if (b >= DMC_RANK_BITS) return(0x3f);
+#if DMC_ADDR_DEC == 1 // RCBI
+  else return(DMC_COL_BITS+DMC_BANK_BITS+DMC_NUM_LOG2-6);
+#else // crbi
+  else return(DMC_COL_BITS+DMC_BANK_BITS+DMC_BG_BITS+DMC_ROW_BITS+DMC_NUM_LOG2-6); 
+#endif
+  return 0;
+}
+char get_bankg_offset(int b) {
+  int shutter_offset = (b+DMC_BANK_STRIPE_LOG2 >= DMC_STRIPE_LOG2) ? DMC_NUM_LOG2 : 0;    
+  if (b >= DMC_BG_BITS) return(0x3f);
+  else return((DMC_BANK_STRIPE_LOG2-DMC_DATA_WIDTH_LOG2)+shutter_offset-3);  
+  return 0;
+}
+char get_bank_offset(int b) {
+  int shutter_offset = (b+DMC_COL_BITS+DMC_BG_BITS+DMC_DATA_WIDTH_LOG2 >= DMC_STRIPE_LOG2) ? DMC_NUM_LOG2 : 0;  
+  if ((b >= (DMC_BANK_BITS - DMC_BG_BITS))) return(0x3f);
+  else return(DMC_COL_BITS+DMC_BG_BITS+shutter_offset-3); 
+  return 0;
+}
+char get_col_offset(int b) {
+  int shutter_offset, col_offset;
+  if (DMC_BANK_STRIPE_LOG2 < DMC_STRIPE_LOG2) {    
+    col_offset = (b+DMC_DATA_WIDTH_LOG2 >= DMC_BANK_STRIPE_LOG2) ? DMC_BG_BITS : 0;    
+    shutter_offset = (b+DMC_DATA_WIDTH_LOG2+col_offset >= DMC_STRIPE_LOG2) ? DMC_NUM_LOG2 : 0; 
+  } else {
+    shutter_offset = (b+DMC_DATA_WIDTH_LOG2 >= DMC_STRIPE_LOG2) ? DMC_NUM_LOG2 : 0;
+    col_offset = (b+DMC_DATA_WIDTH_LOG2+shutter_offset >= DMC_BANK_STRIPE_LOG2) ? DMC_BG_BITS : 0;
+  }
+  if (b >= DMC_COL_BITS) return(0x1f);
+  else return(col_offset+shutter_offset); 
+  return 0;
+}
+
 void DWC_ddrctl_lpddr5_init_regs (unsigned int index) {
     unsigned int DMC_BASE = DMC_BASE_ADDR + DMC_OFFSET*index;
 
@@ -158,6 +215,7 @@ void setup_mpu(void)
   MPU->CTRL = 0x03;
 }
 
+
 static void snps_umctl2_configure_controller()
 {
 #ifdef DMC_INIT
@@ -265,7 +323,6 @@ static int snps_umctl_init(fwk_id_t module_id, unsigned int unused,
 }
 
 const struct fwk_module module_snps_umctl = {
-    .name = "SNPS_UMCTL",
     .type = FWK_MODULE_TYPE_DRIVER,
     .init = snps_umctl_init,
     .bind = mod_snps_umctl_bind,
diff --git a/product/tc2/include/scp_css_mmap.h b/product/tc2/include/scp_css_mmap.h
new file mode 100644
index 00000000..3d017e62
--- /dev/null
+++ b/product/tc2/include/scp_css_mmap.h
@@ -0,0 +1,13 @@
+/*
+ * Arm SCP/MCP Software
+ * Copyright (c) 2022, Arm Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef SCP_CSS_MMAP_H
+#define SCP_CSS_MMAP_H
+
+#include "scp_mmap.h"
+
+#endif /* SCP_CSS_MMAP_H */
-- 
2.25.1

