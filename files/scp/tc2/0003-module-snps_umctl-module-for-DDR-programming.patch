From b28fa95fe7c6c4b9dcf569bea8dcdde4add4c4dd Mon Sep 17 00:00:00 2001
From: Usama Arif <usama.arif@arm.com>
Date: Mon, 26 Apr 2021 10:30:57 +0100
Subject: [PATCH 03/18] module/snps_umctl: module for DDR programming

This includes the code for both LPDDR4 and LPDDR5

Signed-off-by: Usama Arif <usama.arif@arm.com>
Change-Id: Ie391b02e62b7deb512a5f98a02518b04c2e7121c
---
 .../include/DWC_ddrctl_lpddr5_init_mem.h      | 380 ++++++++++++++++
 .../include/DWC_ddrctl_lpddr5_init_regs.h     | 263 +++++++++++
 module/snps_umctl/include/dmc620_registers.h  | 425 ++++++++++++++++++
 module/snps_umctl/include/fw_tzc400.h         |  82 ++++
 module/snps_umctl/include/mod_snps_umctl.h    |  13 +
 module/snps_umctl/include/phy_registers.h     |  27 ++
 module/snps_umctl/include/snps_defines.h      | 168 +++++++
 module/snps_umctl/include/test_defs.h         | 118 +++++
 .../include/umctl2_lpddr4_3200_init_mem.h     |  22 +
 .../include/umctl2_lpddr4_3200_init_regs.h    |  93 ++++
 module/snps_umctl/src/Makefile                |  11 +
 module/snps_umctl/src/mod_snps_umctl.c        | 279 ++++++++++++
 12 files changed, 1881 insertions(+)
 create mode 100644 module/snps_umctl/include/DWC_ddrctl_lpddr5_init_mem.h
 create mode 100644 module/snps_umctl/include/DWC_ddrctl_lpddr5_init_regs.h
 create mode 100644 module/snps_umctl/include/dmc620_registers.h
 create mode 100644 module/snps_umctl/include/fw_tzc400.h
 create mode 100644 module/snps_umctl/include/mod_snps_umctl.h
 create mode 100644 module/snps_umctl/include/phy_registers.h
 create mode 100644 module/snps_umctl/include/snps_defines.h
 create mode 100644 module/snps_umctl/include/test_defs.h
 create mode 100644 module/snps_umctl/include/umctl2_lpddr4_3200_init_mem.h
 create mode 100644 module/snps_umctl/include/umctl2_lpddr4_3200_init_regs.h
 create mode 100644 module/snps_umctl/src/Makefile
 create mode 100644 module/snps_umctl/src/mod_snps_umctl.c

diff --git a/module/snps_umctl/include/DWC_ddrctl_lpddr5_init_mem.h b/module/snps_umctl/include/DWC_ddrctl_lpddr5_init_mem.h
new file mode 100644
index 00000000..253a986e
--- /dev/null
+++ b/module/snps_umctl/include/DWC_ddrctl_lpddr5_init_mem.h
@@ -0,0 +1,380 @@
+
+#ifdef SNPS_VIP_FW
+// Phy and Memory initialization
+
+// Disable auto-refreshes, self-refresh, powerdown and assertion of dfi_dram_clk_disable by setting RFSHCTL0.dis_auto_refresh = 1, PWRCTL.powerdown_en = 0 and PWRCTL.selfref_en = 0 PWRCTL.en_dfi_dram_clk_disable = 0
+MEM_RW(DMC_BASE, 0x010208)  = 0x00000001; //RFSHCTL0
+MEM_RW(DMC_BASE, 0x010180)  = 0x00020200; //PWRCTL
+
+#ifndef DMC_BYPASS_PHY_INIT
+  // Set SWCTL.sw_done to 0
+  MEM_RW(DMC_BASE, 0x010c80)  = 0x00000000; //SWCTL
+
+  // Set DFIMISC.dfi_init_complete_en to 0
+  MEM_RW(DMC_BASE, 0x010510)  = 0x00000004; //DFIMISC
+
+  // Set SWCTL.sw_done to 1 (Require polling SWSTAT.sw_done_ack after setting SWCTL.sw_done to 1)
+  MEM_RW(DMC_BASE, 0x010c80)  = 0x00000001; //SWCTL
+  while ((MEM_RW(DMC_BASE, 0x010c84)&0x1)  ==0 ); //SWSTAT
+
+  // PHY initialization.
+  // Start PHY initialization and training by accessing relevant PUB registers
+  // Not required in simulation now as we are using PHY VIP model
+  // For PHY models with configuration interface, do the PHY initilization here
+
+//  while ((MEM_RW(DMC_BASE, 0x18)&0x1)  ==1 );  // MRSTAT - wait busy
+//
+//  // Configure PHY
+////  MEM_RW(PHY_BASE,DMC620_PHY_INIT_COMPLETE)   = 0x00000001; //0x00   
+//  MEM_RW(PHY_BASE,DMC620_PHY_READ_DELAY)      = 0x00000002; //0x08
+//  MEM_RW(PHY_BASE,DMC620_PHY_CAPTURE_MASK)    = 0x0000001f; //0x0C
+//  MEM_RW(PHY_BASE,DMC620_PHY_T_CONTROL_DELAY) = 0x00000000; //0x14
+//  MEM_RW(PHY_BASE,DMC620_PHY_WR_LATENCY)      = 0x01000000; //0x18   
+//  MEM_RW(PHY_BASE,DMC620_PHY_RDDATA_EN)       = 0x00001a00; //0x1C
+//  MEM_RW(PHY_BASE,DMC620_PHY_RD_LATENCY)      = 0x00000016; //0x20
+//  MEM_RW(PHY_BASE,DMC620_PHY_CLP_ACK)         = 0x00641300; //0x30
+//  MEM_RW(PHY_BASE,0x04C)                      = 0x00000002; //0x4c PHY500_DFI_WR_PREMBL (0x58 DMC620_PHY_WR_PREMBL)
+//  MEM_RW(PHY_BASE,DMC620_PHY_DELAY_SEL)       = 0x0000000A; //0x820
+////  MEM_RW(PHY_BASE,DMC620_PHY_REF_EN)          = 0x00000000; //0x824
+//  MEM_RW(PHY_BASE,DMC620_PHY_T_CTRL_UPD_MIN)  = 0x00000000; //0x828
+  
+//  while ((MEM_RW(DMC_BASE, 0x4)&0x1) != 1 );  // STAT - wait until normal
+
+//
+  // Set SWCTL.sw_done to 0
+  MEM_RW(DMC_BASE, 0x010c80)  = 0x00000000; //SWCTL
+
+  // Set DFIMISC.dfi_init_start to 1
+  MEM_RW(DMC_BASE, 0x010510)  = 0x00000024; //DFIMISC
+
+  // Set SWCTL.sw_done to 1 (Require polling SWSTAT.sw_done_ack after setting SWCTL.sw_done to 1)
+  MEM_RW(DMC_BASE, 0x010c80)  = 0x00000001; //SWCTL
+  while ((MEM_RW(DMC_BASE, 0x010c84)&0x1)  ==0 ); //SWSTAT
+
+  // Poll DFISTAT.dfi_init_complete=1
+  while ((MEM_RW(DMC_BASE, 0x010514)&0x1)  ==0 ); //DFISTAT
+
+  // Set SWCTL.sw_done to 0
+  MEM_RW(DMC_BASE, 0x010c80)  = 0x00000000; //SWCTL
+
+  // Set DFIMISC.dfi_init_start to 0
+  MEM_RW(DMC_BASE, 0x010510)  = 0x00000004; //DFIMISC
+
+  // The following registers may need to be updated after training has completed:
+  // RANKTMG0.diff_rank_wr_gap
+  // RANKTMG0.diff_rank_rd_gap
+  // DRAMSET1TMG2.rd2wr
+  // DRAMSET1TMG2.wr2rd
+
+  // Set DFIMISC.dfi_init_complete_en to 1
+  MEM_RW(DMC_BASE, 0x010510)  = 0x00000005; //DFIMISC
+
+  // Set PWRCTL.selfref_sw to 0
+  MEM_RW(DMC_BASE, 0x010180)  = 0x00020200; //PWRCTL
+
+  // Set SWCTL.sw_done to 1 (Require polling SWSTAT.sw_done_ack after setting SWCTL.sw_done to 1
+  MEM_RW(DMC_BASE, 0x010c80)  = 0x00000001; //SWCTL
+  while ((MEM_RW(DMC_BASE, 0x010c84)&0x1)  ==0 ); //SWSTAT
+#else
+  //##########################################################
+  // REVISIT [kispet01 @2020-03-02] This option is not yet tested. Remove this comment after completing the check
+  c_print_str("Warning: Bypassing PHY init sequence, this option is not tested and may not work as expected.\n");
+  //##########################################################
+  printf("Bypassed PHY initilization for DMC%0d\n",index);
+#endif
+
+// Wait for DWC_ddrctl to move to normal operating mode by monitoring STAT.operating_mode signal
+while ((MEM_RW(DMC_BASE, 0x010014)&0x7)  !=1 ); //STAT
+
+// Revert back the below registers to the original values if desired
+// RFSHCTL0.dis_auto_refresh = 0, PWRCTL.powerdown_en = 0 and PWRCTL.selfref_en = 0 PWRTL.en_dfi_dram_clk_disable = 0
+MEM_RW(DMC_BASE, 0x010208)  = 0x00000000; //RFSHCTL0 - RFSHCTL0.dis_auto_refresh = 0
+
+// Note: Skipping frontdoor MR writes by default to reduce simulation time
+#ifdef DMC_SDRAM_MR_WRITES_EN
+// Initiate Mode Register Writes from the controller for SDRAM Memory
+// Software sequence for Mode register writes is as below:
+// 1. Poll MRSTAT.mr_wr_busy until it is 0. This checks that there is no outstanding MR transaction. No
+// writes must be performed to MRCTRL0 and MRCTRL1 if MRSTAT.mr_wr_busy = 1.
+// 2. Write the MRCTRL0.mr_type, MRCTRL0.mr_addr, MRCTRL0.mr_rank and (for MRWs)
+// MRCTRL1.mr_data to define the MR transaction.
+// 3. In a separate APB transaction, write the MRCTRL0.mr_wr to 1. This bit is self-clearing, and triggers the
+// MR transaction. The DDRCTL then asserts the MRSTAT.mr_wr_busy while it performs the MR transaction
+// to SDRAM, and no further accesses can be initiated until it is de-asserted.
+
+//MR18, Addr = 'h12, Data = 'h0, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001200; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR18, Addr = 'h12, Data = 'h0, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001200; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR1, Addr = 'h1, Data = 'hb0, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x000001b0; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR1, Addr = 'h1, Data = 'hb0, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x000001b0; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR2, Addr = 'h2, Data = 'hbb, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x000002bb; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR2, Addr = 'h2, Data = 'hbb, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x000002bb; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR3, Addr = 'h3, Data = 'h26, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00000326; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR3, Addr = 'h3, Data = 'h26, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00000326; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR10, Addr = 'ha, Data = 'h58, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00000a58; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR10, Addr = 'ha, Data = 'h58, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00000a58; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR11, Addr = 'hb, Data = 'h44, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00000b44; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR11, Addr = 'hb, Data = 'h44, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00000b44; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR12, Addr = 'hc, Data = 'h2d, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00000c2d; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR12, Addr = 'hc, Data = 'h2d, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00000c2d; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR13, Addr = 'hd, Data = 'h21, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+//MEM_RW(DMC_BASE, 0x010084)  = 0x00000d21; //MRCTRL1 - Program MR Address and MR WData
+// Enabling DM for Masked Writes 
+MEM_RW(DMC_BASE, 0x010084)  = 0x00000d01; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR13, Addr = 'hd, Data = 'h21, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+//MEM_RW(DMC_BASE, 0x010084)  = 0x00000d21; //MRCTRL1 - Program MR Address and MR WData
+// Enabling DM for Masked Writes 
+MEM_RW(DMC_BASE, 0x010084)  = 0x00000d01; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+// Note: Removing MR14, MR15 register writes to avoid tVREF related errors from VIP
+// Need to check with IP team to see if there is a way to control this timing 
+////MR14, Addr = 'he, Data = 'h15, Rank 0
+//while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+//MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+//MEM_RW(DMC_BASE, 0x010084)  = 0x00000e15; //MRCTRL1 - Program MR Address and MR WData
+//MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+//
+////MR14, Addr = 'he, Data = 'h15, Rank 1
+//while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+//MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+//MEM_RW(DMC_BASE, 0x010084)  = 0x00000e15; //MRCTRL1 - Program MR Address and MR WData
+//MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+//
+////MR15, Addr = 'hf, Data = 'h62, Rank 0
+//while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+//MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+//MEM_RW(DMC_BASE, 0x010084)  = 0x00000f62; //MRCTRL1 - Program MR Address and MR WData
+//MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+//
+////MR15, Addr = 'hf, Data = 'h62, Rank 1
+//while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+//MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+//MEM_RW(DMC_BASE, 0x010084)  = 0x00000f62; //MRCTRL1 - Program MR Address and MR WData
+//MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR16, Addr = 'h10, Data = 'h0, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001000; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR16, Addr = 'h10, Data = 'h0, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001000; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR17, Addr = 'h11, Data = 'h1d, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x0000111d; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR17, Addr = 'h11, Data = 'h1d, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x0000111d; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR19, Addr = 'h13, Data = 'h0, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001300; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR19, Addr = 'h13, Data = 'h0, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001300; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR20, Addr = 'h14, Data = 'h2, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001402; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR20, Addr = 'h14, Data = 'h2, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001402; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR22, Addr = 'h16, Data = 'h0, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001600; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR22, Addr = 'h16, Data = 'h0, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001600; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR23, Addr = 'h17, Data = 'h0, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001700; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR23, Addr = 'h17, Data = 'h0, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001700; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR25, Addr = 'h19, Data = 'h0, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001900; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR25, Addr = 'h19, Data = 'h0, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001900; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR28, Addr = 'h1c, Data = 'h8, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001c08; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR28, Addr = 'h1c, Data = 'h8, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00001c08; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR37, Addr = 'h25, Data = 'h40, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00002540; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR37, Addr = 'h25, Data = 'h40, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00002540; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR40, Addr = 'h28, Data = 'h40, Rank 0
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000010; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00002840; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000010; //MRCTRL0 - Trigger MR Write from the controller
+
+//MR40, Addr = 'h28, Data = 'h40, Rank 1
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000020; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x00002840; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000020; //MRCTRL0 - Trigger MR Write from the controller
+
+//Poll MRSTAT.mr_wr_busy until it is 0. This checks that there is no outstanding MR transaction
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 ); //MRSTAT
+
+#endif // #ifndef DMC_SDRAM_MR_WRITES_EN
+#else
+#include <phy_registers.h>
+#include <snps_defines.h>
+  // Initialize the PHY Registers
+  MEM_RW(PHY_BASE,PHY_INIT_COMPLETE)   = 0x00000001; //0x00   
+  MEM_RW(PHY_BASE, PHY_READ_DELAY)     = 0x00000001; //0x08   
+  MEM_RW(PHY_BASE, PHY_CAPTURE_MASK)   = 0x00000003; //0x0C   
+  MEM_RW(PHY_BASE, PHY_T_CTRL_DELAY)   = 0x0a000000; //0x14	 
+  MEM_RW(PHY_BASE, PHY_WR_LATENCY)     = 0x01000033; //0x18	  // mask offset = 0 data offset =1 
+  MEM_RW(PHY_BASE, PHY_RDDATA_EN)      = 0x00002400; //0x1C	  
+  MEM_RW(PHY_BASE, PHY_RD_LATENCY)     = 0x00000024; //0x20			   		   
+  MEM_RW(PHY_BASE, PHY_LP_ACK)         = 0x00030000; //0x30
+  MEM_RW(PHY_BASE, PHY_WR_PREMBL)      = 0x00000002; //0x58
+  MEM_RW(PHY_BASE, PHY_DELAY_SEL)      = 0x0000000d; //0x820
+  MEM_RW(PHY_BASE, PHY_REF_EN)	       = 0x00000000; //0x824
+  MEM_RW(PHY_BASE, PHY_T_CTRL_UPD_MIN) = 0x00000000; //0x828
+
+  while ((MEM_RW(DMC_BASE, 0x10014))  !=1 ) ;  // STAT - wait until normal
+
+//MRSTAT //MR2 WL =16 RL=17
+MEM_RW(DMC_BASE, 0x010080)  = 0x00000030; //MRCTRL0 - Program the Rank#
+MEM_RW(DMC_BASE, 0x010084)  = 0x0000026b; //MRCTRL1 - Program MR Address and MR WData
+MEM_RW(DMC_BASE, 0x010080)  = 0x80000030; //MRCTRL0 - Trigger MR Write from the controller
+while ((MEM_RW(DMC_BASE, 0x010090)&0x1)  ==1 );
+//
+#endif
diff --git a/module/snps_umctl/include/DWC_ddrctl_lpddr5_init_regs.h b/module/snps_umctl/include/DWC_ddrctl_lpddr5_init_regs.h
new file mode 100644
index 00000000..e834af80
--- /dev/null
+++ b/module/snps_umctl/include/DWC_ddrctl_lpddr5_init_regs.h
@@ -0,0 +1,263 @@
+#ifdef SNPS_VIP_FW
+
+// Configure the DWC_ddrctl controller registers
+// Intital version of the initialization sequence
+// Note: Below Register values are extracted from the RAL Model log of Synopsys DMC OOB Testbench
+
+MEM_RW(DMC_BASE, 0x010000)  = 0x03080008; //MSTR0 - LPDDR5/2-Rank/BL16
+MEM_RW(DMC_BASE, 0x010184)  = 0x00000002; //HWLPCTL - Use default settings for Power
+MEM_RW(DMC_BASE, 0x010200)  = 0x00000107; //RFSHMOD0
+MEM_RW(DMC_BASE, 0x010280)  = 0x80000000; //ZQCTL0 - dis_auto_zq=0x1
+MEM_RW(DMC_BASE, 0x010300)  = 0x00400040; //DQSOSCRUNTIME
+MEM_RW(DMC_BASE, 0x010308)  = 0x00000000; //DQSOSCCFG0 // kispet01: Do we need dis_dqsosc_srx=1? : Disable issuing DQSOSC command seq
+MEM_RW(DMC_BASE, 0x010380)  = 0xc000201c; //SCHED0 - opt_vprw_sch=1, dis_speculative_act=1, lpr_num_entries=0x20, opt_wrcam_fill_level=1, rdwr_switch_policy_sel=1, pageclose=1
+MEM_RW(DMC_BASE, 0x010384)  = (UMCTL2_DELAY_SWITCH_WRITE << 12); //SCHED1
+MEM_RW(DMC_BASE, 0x01038c)  = (UMCTL2_RD_PGHIT_NUM_THRESH << 24) | (UMCTL2_WR_PGHIT_NUM_THRESH << 16) |
+      	      	      	      (UMCTL2_WRCAM_HIGHTHRESH << 8)     | UMCTL2_WRCAM_LOWTHRESH;
+MEM_RW(DMC_BASE, 0x010390)  = (UMCTL2_WR_ACT_GAP << 8)           | UMCTL2_RD_ACT_GAP;
+MEM_RW(DMC_BASE, 0x010c80)  = 0x00000001; // SWCTL - Enable writes to quasi-dynamic registers outside reset.
+MEM_RW(DMC_BASE, 0x010c94)  = 0x00000001; // DBICTL //Enabling DM for Masked Writes
+
+#ifdef DMC_DISABLE_DRAM_INIT
+  // Let PHY perform the SDRAM initialization sequence
+  MEM_RW(DMC_BASE, 0x010d00)  = 0x40020005; //INITTMG0 -skip_dram_init = 2'b01 -> Skip DRAM initialization and start in normal operating mode
+#else
+  //##########################################################
+  // REVISIT [kispet01 @2020-03-02] This option is not yet tested. Remove this comment after completing the check
+  c_print_str("Warning: Performing SDRAM init from Controller, this option is not tested and may not work as expected.");
+  //##########################################################
+  // DMC performs memory initialization/training
+  MEM_RW(DMC_BASE, 0x010d00)  = 0x00020005; //INITTMG0
+#endif
+
+MEM_RW(DMC_BASE, 0x010d04)  = 0x00010000; //INITTMG1 - Number of cycles for SDRAM reset, dram_rstn_x1024=0x1
+
+// System Address to SDRAM Address mapping 
+// Memory configuraton - 8GB (4DFI X 2GB)
+// 2GB per DFI, 2GB = 2Ranks X 1GB, 1GB = 8Gb (x16,4B/4BG mode,10columns,15rows -> 32MbX16DQX4BGX4B)
+// x reperesents the bits that gets removed or are dont care in each stage
+// ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
+// AXI(40Bits) - System Address            | 39 | 38 | 37 | 36 | 35 | 34 | 33 | 32 | 31 | 30 | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |   
+// ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
+// AXI(33Bits) - 8GB (4DFI X 2GB)          | x  | x  | x  | x  | x  | x  | x  | 32 | 31 | 30 | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |
+// ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
+// AXI(31Bits) - 2GB per DFI (2ranksX1GB)  | x  | x  | x  | x  | x  | x  | x  | 32 | 31 | 30 | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 |  x |  x |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |  Addr[9:8] removed to account for channel striping by interconnect  
+// ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
+// AXI(31Bits) -                           | x  | x  | x  | x  | x  | x  | x  | 30 | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  x |  x |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |
+// ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
+// AXI(30Bits) - post SDRAM beat alignment | x  | x  | x  | x  | x  | x  | x  | 32 | 31 | 30 | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 |  x |  x |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  x |   
+// ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
+// HIF(30Bits) -                           | x  | x  | x  | x  | x  | x  | x  | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  7 |  x |  x |  6 |  5 |  4 |  3 |  2 |  1 |  0 | x  |  LSB bit removed for SDRAM Beat size (2Bytes) alignment
+// ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
+// SDRAM(30Bits) -                         | x  | x  | x  | x  | x  | x  | x  | r14| r13| r12| r11| r10| r9 | r8 | r7 | r6 | r5 | r4 | r3 | r2 | r1 | r0 | cs | bg1| bg0| b1 | b0 | c9 | c8 | c7 |  x |  x | c6 | c5 | c4 | c3 | c2 | c1 | c0 | x  |
+// ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
+// SDRAM(30Bits) -                         | x  | x  | x  | x  | x  | x  | x  | x  | x  | r14| r13| r12| r11| r10| r9 | r8 | r7 | r6 | r5 | r4 | r3 | r2 | r1 | r0 | cs | bg1| bg0| b1 | b0 | c9 | c8 | c7 | c6 | c5 | c4 | c3 | c2 | c1 | c0 | x  |
+// ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
+// AXI(40Bits) - System Address            | 0  | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 |
+// ----------------------------------------+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+----+
+// Below registers are used to map the HIF address to SDRAM address
+MEM_RW(DMC_BASE, 0x030004)  = 0x3f3f3f08; //ADDRMAP1  (addrmap_cs_b3_0)         ->  addrmap_cs_b3 = 0x3f(unused), addrmap_cs_b2 = 0x3f(unused), addrmap_cs_b1 = 0x3f(unused), addrmap_cs_b0 = (14[HIF] - 6[base]) = 0x8
+MEM_RW(DMC_BASE, 0x03000c)  = 0x3f3f0707; //ADDRMAP3  (addrmap_bank_b2_0)       ->  addrmap_bank_b2 = 0x3f(unused), addrmap_bank_b1 = (11[HIF] - 4[base]) = 0x07, addrmap_bank_b0 = (10[HIF] - 3[base]) = 0x07
+MEM_RW(DMC_BASE, 0x030010)  = 0x003f0909; //ADDRMAP4  (addrmap_bank_bg_b2_0)    ->  addrmap_bank_bg_b2 = unused, addrmap_bank_bg_b1 = (13[HIF] - 4[base]) = 0x09, addrmap_bank_bg_b0 = (12[HIF] - 3[base]) = 0x09 
+MEM_RW(DMC_BASE, 0x030014)  = 0x1f000000; //ADDRMAP5  (addrmap_col_b10_7)       ->  addrmap_col_b10 = 0x1f(unused), addrmap_col_b9 = (9[HIF] - 9[base]) = 0x00, addrmap_col_b8 = (8[HIF] - 8[base]) = 0x00, addrmap_col_b7 = (7[HIF] - 7[base]) = 0x00
+MEM_RW(DMC_BASE, 0x030018)  = 0x00000000; //ADDRMAP6  (addrmap_col_b6_3)        ->  addrmap_col_b6 = (6[HIF] - 6[base]) = 0x00, addrmap_col_b5 = (5[HIF] - 5[base]) = 0x00, addrmap_col_b4 = (5[HIF] - 5[base]) = 0x00, addrmap_col_b4 = (4[HIF] - 4[base]) = 0x00
+MEM_RW(DMC_BASE, 0x03001c)  = 0x1f1f1f09; //ADDRMAP7  (addrmap_row_b17_14)      ->  addrmap_row_b17 = 0x1f(unused), addrmap_row_b16 = 0x1f(unused), addrmap_row_b15 = 0x1f(unused), addrmap_row_b14 = (29[HIF] - 20[base]) = 0x09  
+MEM_RW(DMC_BASE, 0x030020)  = 0x09090909; //ADDRMAP8  (addrmap_row_b13_10)      ->  addrmap_row_b13 = (28[HIF] - 19[base]) = 0x09, addrmap_row_b12 = (27[HIF] - 18[base]) = 0x09, addrmap_row_b11 = (26[HIF] - 17[base]) = 0x09, addrmap_row_b10 = (25[HIF] - 16[base]) = 0x09
+MEM_RW(DMC_BASE, 0x030024)  = 0x09090909; //ADDRMAP9  (addrmap_row_b9_6)        ->  addrmap_row_b9 = (24[HIF] - 15[base]) = 0x09, addrmap_row_b8 = (23[HIF] - 14[base]) = 0x09, addrmap_row_b7 = (22[HIF] - 13[base]) = 0x09, addrmap_row_b6 = (21[HIF] - 12[base]) = 0x09
+MEM_RW(DMC_BASE, 0x030028)  = 0x09090909; //ADDRMAP10 (addrmap_row_b5_2)        ->  addrmap_row_b5 = (20[HIF] - 11[base]) = 0x09, addrmap_row_b4 = (19[HIF] - 10[base]) = 0x09, addrmap_row_b3 = (18[HIF] - 9[base]) = 0x09, addrmap_row_b2 = (17[HIF] - 8[base]) = 0x09
+MEM_RW(DMC_BASE, 0x03002c)  = 0x00000909; //ADDRMAP11 (addrmap_row_b1_0)        ->  addrmap_row_b1 = (16[HIF] - 7[base]) = 0x09,addrmap_row_b0 = (15[HIF] - 6[base]) = 0x09
+MEM_RW(DMC_BASE, 0x030030)  = 0x00000000; //ADDRMAP12 (nonbinary_device_density)->  3'b000: All addresses are valid
+
+MEM_RW(DMC_BASE, 0x020000)  = 0x00000000; //PCCFG
+MEM_RW(DMC_BASE, 0x020004)  = 0x00006000; //PCFGR
+MEM_RW(DMC_BASE, 0x020008)  = 0x00004000; //PCFGW
+MEM_RW(DMC_BASE, 0x020094)  = 0x00010001; //PCFGQOS0
+MEM_RW(DMC_BASE, 0x020098)  = 0x061f00fc; //PCFGQOS1
+MEM_RW(DMC_BASE, 0x02009c)  = 0x01010e0b; //PCFGWQOS0
+MEM_RW(DMC_BASE, 0x0200a0)  = 0x05540678; //PCFGWQOS1
+
+// Note: Carry forward from lpddr4, Need to revisit this. 
+// ARM Standard address map passthrough
+MEM_RW(DMC_BASE, 0x020114)  = 0x00000000; //PSTAT
+MEM_RW(DMC_BASE, 0x021004)  = 0x00006000; //PCFGR
+MEM_RW(DMC_BASE, 0x021008)  = 0x00006000; //PCFGW
+MEM_RW(DMC_BASE, 0x021094)  = 0x00210001; //PCFGQOS0
+MEM_RW(DMC_BASE, 0x021098)  = 0x034f02af; //PCFGQOS1
+MEM_RW(DMC_BASE, 0x02109c)  = 0x01110100; //PCFGWQOS0
+MEM_RW(DMC_BASE, 0x0210a0)  = 0x04b60057; //PCFGWQOS1
+
+MEM_RW(DMC_BASE, 0x000000)  = 0x2f101b22; //DRAMSET1TMG0
+MEM_RW(DMC_BASE, 0x000004)  = 0x00060633; //DRAMSET1TMG1
+MEM_RW(DMC_BASE, 0x000008)  = 0x10110a1e; //DRAMSET1TMG2
+MEM_RW(DMC_BASE, 0x00000c)  = 0x000c2136; //DRAMSET1TMG3
+MEM_RW(DMC_BASE, 0x000010)  = 0x0f040412; //DRAMSET1TMG4
+MEM_RW(DMC_BASE, 0x000014)  = 0x02040c01; //DRAMSET1TMG5
+MEM_RW(DMC_BASE, 0x000018)  = 0x00000008; //DRAMSET1TMG6
+MEM_RW(DMC_BASE, 0x00001c)  = 0x00000003; //DRAMSET1TMG7
+MEM_RW(DMC_BASE, 0x000020)  = 0x00004400; //DRAMSET1TMG8
+MEM_RW(DMC_BASE, 0x000024)  = 0x00020419; //DRAMSET1TMG9
+MEM_RW(DMC_BASE, 0x000030)  = 0x00030000; //DRAMSET1TMG12
+MEM_RW(DMC_BASE, 0x000034)  = 0x13100002; //DRAMSET1TMG13
+MEM_RW(DMC_BASE, 0x000038)  = 0x0020006e; //DRAMSET1TMG14
+MEM_RW(DMC_BASE, 0x00005c)  = 0x009d05cf; //DRAMSET1TMG23
+MEM_RW(DMC_BASE, 0x000060)  = 0x00081615; //DRAMSET1TMG24
+MEM_RW(DMC_BASE, 0x000064)  = 0x00002f06; //DRAMSET1TMG25
+MEM_RW(DMC_BASE, 0x000078)  = 0x00190b18; //DRAMSET1TMG30
+
+// DFITMG* parameter values must match with PHY
+MEM_RW(DMC_BASE, 0x000580)  = 0x063f023E; //DFITMG0
+MEM_RW(DMC_BASE, 0x000584)  = 0x00140606; //DFITMG1
+MEM_RW(DMC_BASE, 0x000588)  = 0x00243f3b; //DFITMG2
+MEM_RW(DMC_BASE, 0x000590)  = 0x1C2C0400; //DFITMG4
+MEM_RW(DMC_BASE, 0x000594)  = 0x04100010; //DFITMG5
+MEM_RW(DMC_BASE, 0x0005a0)  = 0x00020202; //DFILPTMG0
+MEM_RW(DMC_BASE, 0x0005a4)  = 0x00000201; //DFILPTMG1
+MEM_RW(DMC_BASE, 0x0005a8)  = 0x001b0003; //DFIUPDTMG0
+MEM_RW(DMC_BASE, 0x0005ac)  = 0x000b00e8; //DFIUPDTMG1
+MEM_RW(DMC_BASE, 0x0005b0)  = 0x00000004; //DFIMSGTMG0
+MEM_RW(DMC_BASE, 0x000600)  = 0x0210000C; //RFSHSET1TMG0 - t_refi_x1_sel=0, refresh_margin=2, refresh_to_x1_x32=0x10, t_refi_x1_x32 = round_down(488ns/1.25ns/32)= 0xC
+MEM_RW(DMC_BASE, 0x000a80)  = 0x00003d91; //DQSOSCCTL0
+MEM_RW(DMC_BASE, 0x000c80)  = 0x0f000001; //PERFHPR1 // kispet01: This is related to performance tuning for different priorities, use settings for OoB and change later if required
+MEM_RW(DMC_BASE, 0x000c84)  = 0x0f00007f; //PERFLPR1 // kispet01: This is related to performance tuning for different priorities, use settings for OoB and change later if required
+MEM_RW(DMC_BASE, 0x000c88)  = 0x0f00007f; //PERFWR1  // kispet01: This is related to performance tuning for different priorities, use settings for OoB and change later if required
+MEM_RW(DMC_BASE, 0x000d00)  = 0x00000001; //TMGCFG - frequency_ratio- 1:1:4 Mode
+//MEM_RW(DMC_BASE, 0x000d04)  = 0x00000202; //RANKTMG0 // kispet01: Was 0x00000e12, Modified: diff_rank_wr_gap=2, diff_rank_rd_gap=2 (to match with LPDDR4 sequence)
+MEM_RW(DMC_BASE, 0x000d04)  = 0x00000e12; //RANKTMG0 // Note: Reverting to IP OOB TB values to avoid VIP issues during rank switching
+//MEM_RW(DMC_BASE, 0x000d08)  = 0x00000e12; //RANKTMG1 // kispet01: Need to review. rd2wr_dr, wr2rd_dr param values. LPDDR4 is using 'd16 and 'd21 respecitvely
+MEM_RW(DMC_BASE, 0x000d08)  = 0x00000f11; //RANKTMG1 // Note: Reverting to IP OOB TB values to avoid VIP issues during rank switching
+MEM_RW(DMC_BASE, 0x000d0c)  = 0x00020001; //PWRTMG - Low power timing for selfref_to_x32, powerdown_to_x32, Use default
+MEM_RW(DMC_BASE, 0x020090)  = 0x00000001; //PCTRL - Enable AXI Port 0
+MEM_RW(DMC_BASE, 0x021090)  = 0x00000001; //PCTRL - Enable AXI Port 1
+
+// Phy and Memory initialization to be performed separately after releasing reset from SCP
+#else
+#include <phy_registers.h>
+#include <snps_defines.h>
+  MEM_RW(DMC_BASE, 0x10000) = 0x03080008; // MSTR0 - x16 device/LPDDR5/2Rank/BL16
+  MEM_RW(DMC_BASE, 0x10200) = 0x00000100; // RFSHMOD0  - refresh burst x8
+  MEM_RW(DMC_BASE, 0x10280) = 0x80000000; // ZQCTL0    - disable zq
+  MEM_RW(DMC_BASE, 0x10288) = 0x00000001; // ZQCTL2    - 
+  MEM_RW(DMC_BASE, 0x10380) = (1<<31)  | (1<<16) | ( UMCTL_LPR_NUM_ENTRIES << 8) | (UMCTL_OPT_WRCAM_FILL_LEVEL << 4) | 
+      	      	      	      (UMCTL_ENHANCED_RW << 3) | ((UMCTL_PC_TIMER!=-1)?(1<<2):0)  | 0x1; // SCHED0  
+  MEM_RW(DMC_BASE, 0x10384) = (UMCTL_PAGE_HIT_LIMIT_RD << 28) | (UMCTL_PAGE_HIT_LIMIT_WR << 24) | 
+      	      	      	      (UMCTL_WINDOW_LIMIT_RD << 20) | (UMCTL_WINDOW_LIMIT_WR << 16) | 
+			      (UMCTL_DELAY_SWITCH_WRITE << 12); // SCHED1
+  MEM_RW(DMC_BASE, 0x1038C) = (UMCTL_RD_PGHIT_NUM_THRESH << 24) | (UMCTL_WR_PGHIT_NUM_THRESH << 16) | 
+      	      	      	    (UMCTL_WRCAM_HIGHTHRESH << 8) | UMCTL_WRCAM_LOWTHRESH; //0x4040208; // SCHED3   - wrcam_highthresh=2 wrcam_lowthresh=32
+MEM_RW(DMC_BASE, 0x10390) = (8<<24) | (0x40<<16) | (UMCTL_WR_ACT_GAP << 8)           | UMCTL_RD_ACT_GAP; // SCHED4   - wr_page_exp=8 rd_pageexp=64 wractgap=0 rdactgap=0
+
+  MEM_RW(DMC_BASE, 0xc00) = (UMCTL_RDWR_IDLE_GAP << 8) |((UMCTL_PC_TIMER!=-1)? UMCTL_PC_TIMER:0); //0x83c0810 // SCHEDTMG0
+  MEM_RW(DMC_BASE, 0x10c90) = 0x0000f00f; // RANKCTL   - maxwr = f maxrd = f
+  MEM_RW(DMC_BASE, 0x10d00) = 0x00000000; // INITTMG0 - [0] - 1 pre/post =0 
+  MEM_RW(DMC_BASE, 0x00d00) = 0x00000001; // TMGCFG - [0] - Freq ratio 4
+  MEM_RW(DMC_BASE, 0x10508) = 0xc0000000; // DFIUPD0   - dis_auto_ctrlup
+  MEM_RW(DMC_BASE, 0x00600) = 0x82100186; // RFSHSET1TMG0 - t_refi_x1_sel = 1 refresh_margin=2 refresh_to_x1_x32=16 t_refi_x1_x32=390
+  MEM_RW(DMC_BASE, 0x00604) = 0x00000070; // RFSHSET1TMG1 - t_rfc_min = 112
+  MEM_RW(DMC_BASE, 0x00608) = 0x06480000; // RFSHSET1TMG2 - t_pbr2act = 6 t_pbr2pbr = 72 
+
+//#if DMC_BANK_STRIPE == 32
+//  MEM_RW(DMC_BASE, 0x30018) = 0x02020200; // ADDRMAP6 - addrmap_col_b[6:3]   = 1 + 0 + 2  + [6:3]   = [9:7,4]  
+//  MEM_RW(DMC_BASE, 0x30014) = 0x1f020202; // ADDRMAP5 - addrmap_col_b[10:7]  = 1 + 0 + 2  + [9:7]   = [12:10]  
+//  MEM_RW(DMC_BASE, 0x30010) = 0x003f0101; // ADDRMAP4 - addrmap_bg_b[2:0]    = 1 + 3 + 1  + [1:0]   = [6:5]
+//  MEM_RW(DMC_BASE, 0x3000C) = 0x003f0909; // ADDRMAP3 - addrmap_bank_b[2:0]  = 1 + 3 + 9  + [1:0]   = [14:13]
+//#else
+//  MEM_RW(DMC_BASE, 0x30018) = 0x00000000; // ADDRMAP6 - addrmap_col_b[6:3]   = 1 + 0 + 0  + [6:3]   = [7:4]  
+//  MEM_RW(DMC_BASE, 0x30014) = 0x1f000000; // ADDRMAP5 - addrmap_col_b[10:7]  = 1 + 0 + 0  + [9:7]   = [10:8]  
+//  MEM_RW(DMC_BASE, 0x30010) = 0x003f0707; // ADDRMAP4 - addrmap_bg_b[2:0]    = 1 + 3 + 7  + [1:0]   = [12:11]
+//  MEM_RW(DMC_BASE, 0x3000C) = 0x003f0909; // ADDRMAP3 - addrmap_bank_b[2:0]  = 1 + 3 + 9  + [1:0]   = [14:13]
+//#endif
+//  // RCB SDRAM address map =  log2(DATA_WIDTH) + base + offset
+//  MEM_RW(DMC_BASE, 0x30004) = 0x3f3f1f08; // ADDRMAP1 - addrmap_cs_b0	     = 1 + 6 + 8  + [0]     = [15]
+//  MEM_RW(DMC_BASE, 0x3002C) = 0x00000909; // ADDRMAP11- addrmap_row_b[1:0]   = 1 + 6 + 9  + [1:0]   = [17:16]
+//  MEM_RW(DMC_BASE, 0x30028) = 0x09090909; // ADDRMAP10- addrmap_row_b[5:2]   = 1 + 6 + 9  + [5:2]   = [21:18]
+//  MEM_RW(DMC_BASE, 0x30024) = 0x09090909; // ADDRMAP9 - addrmap_row_b[9:6]   = 1 + 6 + 9  + [9:6]   = [25:22]
+//#if DMC_ROW_BITS+11 == 11
+//  MEM_RW(DMC_BASE, 0x30020) = 0x1f1f1f09; // ADDRMAP8 - addrmap_row_b[13:10] = 1 + 6 + 9  + [10]    = [26]
+//  MEM_RW(DMC_BASE, 0x3001C) = 0x1f1f1f1f; // ADDRMAP7 - addrmap_row_b[17:14] = 1 + 6 + 9  +         = 
+//#elif DMC_ROW_BITS+11 == 12
+//  MEM_RW(DMC_BASE, 0x30020) = 0x1f1f0909; // ADDRMAP8 - addrmap_row_b[13:10] = 1 + 6 + 9  + [11:10] = [27:26]
+//  MEM_RW(DMC_BASE, 0x3001C) = 0x1f1f1f1f; // ADDRMAP7 - addrmap_row_b[17:14] = 1 + 6 + 9  +         = 
+//#elif DMC_ROW_BITS+11 == 13
+//  MEM_RW(DMC_BASE, 0x30020) = 0x1f090909; // ADDRMAP8 - addrmap_row_b[13:10] = 1 + 6 + 9  + [12:10] = [28:26]
+//  MEM_RW(DMC_BASE, 0x3001C) = 0x1f1f1f1f; // ADDRMAP7 - addrmap_row_b[17:14] = 1 + 6 + 9  +          = 
+//#elif DMC_ROW_BITS+11 == 14
+//  MEM_RW(DMC_BASE, 0x30020) = 0x09090909; // ADDRMAP8 - addrmap_row_b[13:10] = 1 + 6 + 9  + [13:10] = [29:26]
+//  MEM_RW(DMC_BASE, 0x3001C) = 0x1f1f1f1f; // ADDRMAP7 - addrmap_row_b[17:14] = 1 + 6 + 9  +         = 
+//#elif DMC_ROW_BITS+11 == 15
+//  MEM_RW(DMC_BASE, 0x30020) = 0x09090909; // ADDRMAP8 - addrmap_row_b[13:10] = 1 + 6 + 9  + [13:10] = [29:26]
+//  MEM_RW(DMC_BASE, 0x3001C) = 0x1f1f1f09; // ADDRMAP7 - addrmap_row_b[17:14] = 1 + 6 + 9  + [14]    = [30]
+//#elif DMC_ROW_BITS+11 == 16
+//  MEM_RW(DMC_BASE, 0x30020) = 0x09090909; // ADDRMAP8 - addrmap_row_b[13:10] = 1 + 6 + 9  + [13:10] = [29:26]
+//  MEM_RW(DMC_BASE, 0x3001C) = 0x1f1f0909; // ADDRMAP7 - addrmap_row_b[17:14] = 1 + 6 + 9  + [15:14] = [31:30]
+//#endif
+  
+// Below registers are used to map the HIF address to SDRAM address
+MEM_RW(DMC_BASE, 0x030004)  = 0x3f3f3f08; //ADDRMAP1  (addrmap_cs_b3_0)         ->  addrmap_cs_b3 = 0x3f(unused), addrmap_cs_b2 = 0x3f(unused), addrmap_cs_b1 = 0x3f(unused), addrmap_cs_b0 = (14[HIF] - 6[base]) = 0x8
+MEM_RW(DMC_BASE, 0x03000c)  = 0x3f3f0707; //ADDRMAP3  (addrmap_bank_b2_0)       ->  addrmap_bank_b2 = 0x3f(unused), addrmap_bank_b1 = (11[HIF] - 4[base]) = 0x07, addrmap_bank_b0 = (10[HIF] - 3[base]) = 0x07
+MEM_RW(DMC_BASE, 0x030010)  = 0x003f0909; //ADDRMAP4  (addrmap_bank_bg_b2_0)    ->  addrmap_bank_bg_b2 = unused, addrmap_bank_bg_b1 = (13[HIF] - 4[base]) = 0x09, addrmap_bank_bg_b0 = (12[HIF] - 3[base]) = 0x09 
+MEM_RW(DMC_BASE, 0x030014)  = 0x1f000000; //ADDRMAP5  (addrmap_col_b10_7)       ->  addrmap_col_b10 = 0x1f(unused), addrmap_col_b9 = (9[HIF] - 9[base]) = 0x00, addrmap_col_b8 = (8[HIF] - 8[base]) = 0x00, addrmap_col_b7 = (7[HIF] - 7[base]) = 0x00
+MEM_RW(DMC_BASE, 0x030018)  = 0x00000000; //ADDRMAP6  (addrmap_col_b6_3)        ->  addrmap_col_b6 = (6[HIF] - 6[base]) = 0x00, addrmap_col_b5 = (5[HIF] - 5[base]) = 0x00, addrmap_col_b4 = (5[HIF] - 5[base]) = 0x00, addrmap_col_b4 = (4[HIF] - 4[base]) = 0x00
+MEM_RW(DMC_BASE, 0x03001c)  = 0x1f1f1f09; //ADDRMAP7  (addrmap_row_b17_14)      ->  addrmap_row_b17 = 0x1f(unused), addrmap_row_b16 = 0x1f(unused), addrmap_row_b15 = 0x1f(unused), addrmap_row_b14 = (29[HIF] - 20[base]) = 0x09  
+MEM_RW(DMC_BASE, 0x030020)  = 0x09090909; //ADDRMAP8  (addrmap_row_b13_10)      ->  addrmap_row_b13 = (28[HIF] - 19[base]) = 0x09, addrmap_row_b12 = (27[HIF] - 18[base]) = 0x09, addrmap_row_b11 = (26[HIF] - 17[base]) = 0x09, addrmap_row_b10 = (25[HIF] - 16[base]) = 0x09
+MEM_RW(DMC_BASE, 0x030024)  = 0x09090909; //ADDRMAP9  (addrmap_row_b9_6)        ->  addrmap_row_b9 = (24[HIF] - 15[base]) = 0x09, addrmap_row_b8 = (23[HIF] - 14[base]) = 0x09, addrmap_row_b7 = (22[HIF] - 13[base]) = 0x09, addrmap_row_b6 = (21[HIF] - 12[base]) = 0x09
+MEM_RW(DMC_BASE, 0x030028)  = 0x09090909; //ADDRMAP10 (addrmap_row_b5_2)        ->  addrmap_row_b5 = (20[HIF] - 11[base]) = 0x09, addrmap_row_b4 = (19[HIF] - 10[base]) = 0x09, addrmap_row_b3 = (18[HIF] - 9[base]) = 0x09, addrmap_row_b2 = (17[HIF] - 8[base]) = 0x09
+MEM_RW(DMC_BASE, 0x03002c)  = 0x00000909; //ADDRMAP11 (addrmap_row_b1_0)        ->  addrmap_row_b1 = (16[HIF] - 7[base]) = 0x09,addrmap_row_b0 = (15[HIF] - 6[base]) = 0x09
+MEM_RW(DMC_BASE, 0x030030)  = 0x00000000; //ADDRMAP12 (nonbinary_device_density)->  3'b000: All addresses are valid
+#ifdef DMC_DISABLE_REFRESH
+  MEM_RW(DMC_BASE, 0x010208) = 0x00000001; // RFSHCTL0  - dis_auto_ref
+#endif
+MEM_RW(DMC_BASE, 0x000d04)  = 0x00000e12; //RANKTMG0
+MEM_RW(DMC_BASE, 0x000d08)  = 0x00000f11; //RANKTMG1
+MEM_RW(DMC_BASE, 0x000000)  = 0x2f101b22; //DRAMSET1TMG0
+MEM_RW(DMC_BASE, 0x000004)  = 0x00060633; //DRAMSET1TMG1
+MEM_RW(DMC_BASE, 0x000008)  = 0x10110a1e; //DRAMSET1TMG2 - WL 16 RL - 17
+MEM_RW(DMC_BASE, 0x00000c)  = 0x000c2136; //DRAMSET1TMG3
+MEM_RW(DMC_BASE, 0x000010)  = 0x0f040412; //DRAMSET1TMG4 - t_rcd = 15 t_ccd_l = 4 t_rrd_l = 4 t_rp = 18
+MEM_RW(DMC_BASE, 0x000014)  = 0x02040c01; //DRAMSET1TMG5
+MEM_RW(DMC_BASE, 0x000018)  = 0x00000008; //DRAMSET1TMG6
+MEM_RW(DMC_BASE, 0x00001c)  = 0x00000003; //DRAMSET1TMG7
+MEM_RW(DMC_BASE, 0x000020)  = 0x00004400; //DRAMSET1TMG8
+MEM_RW(DMC_BASE, 0x000024)  = 0x00020419; //DRAMSET1TMG9 - tccd_s = 2 t_rrd_s = 4 twr2rd_s = 27
+MEM_RW(DMC_BASE, 0x000030)  = 0x00030000; //DRAMSET1TMG12
+MEM_RW(DMC_BASE, 0x000034)  = 0x13100002; //DRAMSET1TMG13
+MEM_RW(DMC_BASE, 0x000038)  = 0x0020006e; //DRAMSET1TMG14
+MEM_RW(DMC_BASE, 0x00005c)  = 0x009d05cf; //DRAMSET1TMG23
+MEM_RW(DMC_BASE, 0x000060)  = 0x00081615; //DRAMSET1TMG24 - 4Bank/4BG 
+MEM_RW(DMC_BASE, 0x000064)  = 0x00002f06; //DRAMSET1TMG25
+MEM_RW(DMC_BASE, 0x000078)  = 0x00190b18; //DRAMSET1TMG30
+MEM_RW(DMC_BASE, 0x000580)  = 0x0627002f; //DFITMG0 - tctldelay = 6 phy_dfi_clk = 1 trddataen = 39 tphywrdata = 0 tphywrlat = 64
+MEM_RW(DMC_BASE, 0x000584)  = 0x00140606; //DFITMG1
+MEM_RW(DMC_BASE, 0x000588)  = 0x00243f3b; //DFITMG2
+MEM_RW(DMC_BASE, 0x000590)  = 0x1C2C0400; //DFITMG4
+MEM_RW(DMC_BASE, 0x000594)  = 0x0410000C; //DFITMG5
+
+  // Enable QOS
+#ifdef QOS_DISABLE
+  MEM_RW(DMC_BASE, 0x20094+0x1000*0)  = 0x02000e00;  // RQOS region2>d region1>8
+  MEM_RW(DMC_BASE, 0x20098+0x1000*0)  = 0x03ff03ff;
+  MEM_RW(DMC_BASE, 0x2009c+0x1000*0)  = 0x00000e00;  // WQOS region2>d region1>8
+  MEM_RW(DMC_BASE, 0x200a0+0x1000*0)  = 0x03ff03ff;
+  MEM_RW(DMC_BASE, 0x20094+0x1000*1)  = 0x02000e00;  // RQOS region2>d region1>8
+  MEM_RW(DMC_BASE, 0x20098+0x1000*1)  = 0x03ff03ff;
+  MEM_RW(DMC_BASE, 0x2009c+0x1000*1)  = 0x00000e00;  // WQOS region2>d region1>8
+  MEM_RW(DMC_BASE, 0x200a0+0x1000*1)  = 0x03ff03ff;
+  MEM_RW(DMC_BASE, 0x20004+0x1000*0)  = 0x000143ff;  // RQOS region2>d region1>8
+  MEM_RW(DMC_BASE, 0x20004+0x1000*1)  = 0x000143ff;  // RQOS region2>d region1>8
+#else
+  MEM_RW(DMC_BASE, 0x20094+0x1000*0)  = 0x02100d08;  // RQOS region2>d region1>8
+  MEM_RW(DMC_BASE, 0x20098+0x1000*0)  = UMCTL_VP_TIMEOUT;  // PCFGQOS1 - timeoutr timeoutb
+  MEM_RW(DMC_BASE, 0x2009c+0x1000*0)  = 0x01000908;  // WQOS region2>d region1>8
+  MEM_RW(DMC_BASE, 0x200a0+0x1000*0)  = UMCTL_VP_WTIMEOUT;  // WQOS region2>0 region1>0
+  MEM_RW(DMC_BASE, 0x20094+0x1000*1)  = 0x02100d08;  // RQOS region2>d region1>8
+  MEM_RW(DMC_BASE, 0x20098+0x1000*1)  = UMCTL_VP_TIMEOUT;  // PCFGQOS1 - timeoutr timeoutb
+  MEM_RW(DMC_BASE, 0x2009c+0x1000*1)  = 0x01000a00;  // WQOS region2>d region1>8
+  MEM_RW(DMC_BASE, 0x200a0+0x1000*1)  = UMCTL_VP_WTIMEOUT;  // WQOS region2>0 region1>0
+  MEM_RW(DMC_BASE, 0x20004+0x1000*0)  = 0x000143ff;  // RQOS region2>d region1>8
+  MEM_RW(DMC_BASE, 0x20004+0x1000*1)  = 0x000153ff;  // RQOS region2>d region1>8
+#endif  
+  // Enable AXI Ports
+  MEM_RW(DMC_BASE, 0x20090+0x1000*0)  = 0x000000001;  // PCTRL_0 - [0] - 1 AXI PORT enable
+  MEM_RW(DMC_BASE, 0x20090+0x1000*1)  = 0x000000001;  // PCTRL_0 - [0] - 1 AXI PORT enable
+  while ((MEM_RW(DMC_BASE, 0x10090)&0x1)  ==1 );  // MRSTAT - wait busy
+
+#endif
diff --git a/module/snps_umctl/include/dmc620_registers.h b/module/snps_umctl/include/dmc620_registers.h
new file mode 100644
index 00000000..88735a32
--- /dev/null
+++ b/module/snps_umctl/include/dmc620_registers.h
@@ -0,0 +1,425 @@
+
+#define FPGAPHY_GENERAL_SETUP     					0x0000
+#define FPGAPHY_PLAYBACK_ENABLE     				0x0004
+#define FPGAPHY_PLAYBACK_STATUS     				0x0008
+#define FPGAPHY_WRITE_PIPE_DELAY     				0x000C
+#define FPGAPHY_CA_PIPE_DELAY     					0x0010
+#define FPGAPHY_DATA_BYTE_SEL     					0x0014
+#define FPGAPHY_CTRLUPD_CONFIG     					0x0018
+#define FPGAPHY_DEBUG     							0x001C
+#define FPGAPHY_INTERRUPT_MASK     					0x0020
+#define FPGAPHY_INTERRUPT_ENABLE     				0x0024
+#define FPGAPHY_INTERRUPT_STATUS     				0x0028
+#define FPGAPHY_INTERRUPT_CLEAR     				0x002C
+#define FPGAPHY_DFICLK_READ_DELAY_RANK_0     		0x0030
+#define FPGAPHY_FCLK_READ_DELAY_RANK_0_BYTES_7_0    0x0034
+#define FPGAPHY_FCLK_READ_DELAY_RANK_0_BYTE_8     	0x0038
+#define FPGAPHY_DFICLK_READ_DELAY_RANK_1     		0x0040
+#define FPGAPHY_FCLK_READ_DELAY_RANK_1_BYTES_7_0    0x0044
+#define FPGAPHY_FCLK_READ_DELAY_RANK_1_BYTE_8     	0x0048
+#define FPGAPHY_FCLK_READ_OFFSET_RANK_0_BYTES_7_0   0x0050
+#define FPGAPHY_FCLK_READ_OFFSET_RANK_0_BYTE_8     	0x0054
+#define FPGAPHY_FCLK_READ_OFFSET_RANK_1_BYTES_7_0   0x0058
+#define FPGAPHY_FCLK_READ_OFFSET_RANK_1_BYTE_8      0x005C
+#define FPGAPHY_AUTOTRAIN_LOOP_ADDR     			0x0060
+#define FPGAPHY_TRAIN_STATUS     					0x0064
+#define FPGAPHY_READ_TRAINING_CAPTURE_0     		0x0068
+#define FPGAPHY_READ_TRAINING_CAPTURE_1     		0x006C
+#define FPGAPHY_REVISION_REGISTER     				0x0070
+#define FPGAPHY_READ_PHASE_DELAY_RANK_0     		0x0074
+#define FPGAPHY_READ_PHASE_DELAY_RANK_1     		0x0078
+#define PLAYBACK_ENGINE_CODE_0						0x0800
+#define PLAYBACK_ENGINE_CODE_1						0x0804
+#define PLAYBACK_ENGINE_CODE_2						0x0808
+#define PLAYBACK_ENGINE_CODE_3						0x080C
+#define PLAYBACK_ENGINE_CODE_4						0x0810
+#define PLAYBACK_ENGINE_CODE_8 						0x0820
+#define PLAYBACK_ENGINE_CODE_9 						0x0824
+#define PLAYBACK_ENGINE_CODE_10 					0x0828
+#define PLAYBACK_ENGINE_CODE_11 					0x082c
+#define PLAYBACK_ENGINE_CODE_12 					0x0830
+#define PLAYBACK_ENGINE_CODE_16 					0x0840
+#define PLAYBACK_ENGINE_CODE_17 					0x0844
+#define PLAYBACK_ENGINE_CODE_18 					0x0848
+#define PLAYBACK_ENGINE_CODE_19 					0x084c
+#define PLAYBACK_ENGINE_CODE_20 					0x0850
+#define PLAYBACK_ENGINE_CODE_24 					0x0860
+#define PLAYBACK_ENGINE_CODE_25 					0x0864
+#define PLAYBACK_ENGINE_CODE_26 					0x0868
+#define PLAYBACK_ENGINE_CODE_27 					0x086c
+#define PLAYBACK_ENGINE_CODE_28 					0x0870
+#define PLAYBACK_ENGINE_CODE_32 					0x0880
+#define PLAYBACK_ENGINE_CODE_33 					0x0884
+#define PLAYBACK_ENGINE_CODE_34 					0x0888
+#define PLAYBACK_ENGINE_CODE_35 					0x088c
+#define PLAYBACK_ENGINE_CODE_36 					0x0890
+#define PLAYBACK_ENGINE_CODE_40 					0x08a0
+#define PLAYBACK_ENGINE_CODE_41 					0x08a4
+#define PLAYBACK_ENGINE_CODE_42 					0x08a8
+#define PLAYBACK_ENGINE_CODE_43 					0x08ac
+#define PLAYBACK_ENGINE_CODE_44 					0x08b0
+#define PLAYBACK_ENGINE_CODE_48 					0x08c0
+#define PLAYBACK_ENGINE_CODE_49 					0x08c4
+#define PLAYBACK_ENGINE_CODE_50 					0x08c8
+#define PLAYBACK_ENGINE_CODE_51 					0x08cc
+#define PLAYBACK_ENGINE_CODE_52 					0x08d0
+#define PLAYBACK_ENGINE_CODE_56 					0x08e0
+#define PLAYBACK_ENGINE_CODE_57 					0x08e4
+#define PLAYBACK_ENGINE_CODE_58 					0x08e8
+#define PLAYBACK_ENGINE_CODE_59 					0x08ec
+#define PLAYBACK_ENGINE_CODE_60 					0x08f0
+#define PLAYBACK_ENGINE_CODE_64 					0x0900
+#define PLAYBACK_ENGINE_CODE_65 					0x0904
+#define PLAYBACK_ENGINE_CODE_66 					0x0908
+#define PLAYBACK_ENGINE_CODE_67 					0x090c
+#define PLAYBACK_ENGINE_CODE_68 					0x0910
+#define PLAYBACK_ENGINE_CODE_72 					0x0920
+#define PLAYBACK_ENGINE_CODE_73 					0x0924
+#define PLAYBACK_ENGINE_CODE_74 					0x0928
+#define PLAYBACK_ENGINE_CODE_75 					0x092c
+#define PLAYBACK_ENGINE_CODE_76 					0x0930
+#define PLAYBACK_ENGINE_CODE_80 					0x0940
+#define PLAYBACK_ENGINE_CODE_81 					0x0944
+#define PLAYBACK_ENGINE_CODE_82 					0x0948
+#define PLAYBACK_ENGINE_CODE_83 					0x094c
+#define PLAYBACK_ENGINE_CODE_84 					0x0950
+#define PLAYBACK_ENGINE_CODE_88 					0x0960
+#define PLAYBACK_ENGINE_CODE_89 					0x0964
+#define PLAYBACK_ENGINE_CODE_90 					0x0968
+#define PLAYBACK_ENGINE_CODE_91 					0x096c
+#define PLAYBACK_ENGINE_CODE_92 					0x0970
+#define PLAYBACK_ENGINE_CODE_96 					0x0980
+#define PLAYBACK_ENGINE_CODE_97 					0x0984
+#define PLAYBACK_ENGINE_CODE_98 					0x0988
+#define PLAYBACK_ENGINE_CODE_99 					0x098c
+#define PLAYBACK_ENGINE_CODE_100 					0x0990
+#define PLAYBACK_ENGINE_CODE_104 					0x09a0
+#define PLAYBACK_ENGINE_CODE_105 					0x09a4
+#define PLAYBACK_ENGINE_CODE_106 					0x09a8
+#define PLAYBACK_ENGINE_CODE_107 					0x09ac
+#define PLAYBACK_ENGINE_CODE_108 					0x09b0
+#define PLAYBACK_ENGINE_CODE_112 					0x09c0
+#define PLAYBACK_ENGINE_CODE_113 					0x09c4
+#define PLAYBACK_ENGINE_CODE_114 					0x09c8
+#define PLAYBACK_ENGINE_CODE_115 					0x09cc
+#define PLAYBACK_ENGINE_CODE_116 					0x09d0
+#define PLAYBACK_ENGINE_CODE_120 					0x09e0
+#define PLAYBACK_ENGINE_CODE_121 					0x09e4
+#define PLAYBACK_ENGINE_CODE_122 					0x09e8
+#define PLAYBACK_ENGINE_CODE_123 					0x09ec
+#define PLAYBACK_ENGINE_CODE_124 					0x09f0
+#define PLAYBACK_ENGINE_CODE_128 					0x0a00
+#define PLAYBACK_ENGINE_CODE_129 					0x0a04
+#define PLAYBACK_ENGINE_CODE_130 					0x0a08
+#define PLAYBACK_ENGINE_CODE_131 					0x0a0c
+#define PLAYBACK_ENGINE_CODE_132 					0x0a10
+#define PLAYBACK_ENGINE_CODE_136 					0x0a20
+#define PLAYBACK_ENGINE_CODE_137 					0x0a24
+#define PLAYBACK_ENGINE_CODE_138 					0x0a28
+#define PLAYBACK_ENGINE_CODE_139 					0x0a2c
+#define PLAYBACK_ENGINE_CODE_140 					0x0a30
+#define PLAYBACK_ENGINE_CODE_144 					0x0a40
+#define PLAYBACK_ENGINE_CODE_145 					0x0a44
+#define PLAYBACK_ENGINE_CODE_146 					0x0a48
+#define PLAYBACK_ENGINE_CODE_147 					0x0a4c
+#define PLAYBACK_ENGINE_CODE_148 					0x0a50
+#define PLAYBACK_ENGINE_CODE_152 					0x0a60
+#define PLAYBACK_ENGINE_CODE_153 					0x0a64
+#define PLAYBACK_ENGINE_CODE_154 					0x0a68
+#define PLAYBACK_ENGINE_CODE_155 					0x0a6c
+#define PLAYBACK_ENGINE_CODE_156 					0x0a70
+#define PLAYBACK_ENGINE_CODE_160 					0x0a80
+#define PLAYBACK_ENGINE_CODE_161 					0x0a84
+#define PLAYBACK_ENGINE_CODE_162 					0x0a88
+#define PLAYBACK_ENGINE_CODE_163 					0x0a8c
+#define PLAYBACK_ENGINE_CODE_164 					0x0a90
+#define PLAYBACK_ENGINE_CODE_168 					0x0aa0
+#define PLAYBACK_ENGINE_CODE_169 					0x0aa4
+#define PLAYBACK_ENGINE_CODE_170 					0x0aa8
+#define PLAYBACK_ENGINE_CODE_171 					0x0aac
+#define PLAYBACK_ENGINE_CODE_172 					0x0ab0
+#define PLAYBACK_ENGINE_CODE_176 					0x0ac0
+#define PLAYBACK_ENGINE_CODE_177 					0x0ac4
+#define PLAYBACK_ENGINE_CODE_178 					0x0ac8
+#define PLAYBACK_ENGINE_CODE_179 					0x0acc
+#define PLAYBACK_ENGINE_CODE_180  					0x0ad0
+#define PLAYBACK_ENGINE_CODE_184  					0x0ae0
+#define PLAYBACK_ENGINE_CODE_185  					0x0ae4
+#define PLAYBACK_ENGINE_CODE_186  					0x0ae8
+#define PLAYBACK_ENGINE_CODE_187  					0x0aec
+#define PLAYBACK_ENGINE_CODE_188  					0x0af0
+#define PLAYBACK_ENGINE_CODE_192  					0x0b00
+#define PLAYBACK_ENGINE_CODE_193  					0x0b04
+#define PLAYBACK_ENGINE_CODE_194  					0x0b08
+#define PLAYBACK_ENGINE_CODE_195  					0x0b0c
+#define PLAYBACK_ENGINE_CODE_196  					0x0b10
+#define PLAYBACK_ENGINE_CODE_200  					0x0b20
+#define PLAYBACK_ENGINE_CODE_201  					0x0b24
+#define PLAYBACK_ENGINE_CODE_202  					0x0b28
+#define PLAYBACK_ENGINE_CODE_203  					0x0b2c
+#define PLAYBACK_ENGINE_CODE_204  					0x0b30
+#define PLAYBACK_ENGINE_CODE_208  					0x0b40
+#define PLAYBACK_ENGINE_CODE_209  					0x0b44
+#define PLAYBACK_ENGINE_CODE_210  					0x0b48
+#define PLAYBACK_ENGINE_CODE_211  					0x0b4c
+#define PLAYBACK_ENGINE_CODE_212  					0x0b50
+#define PLAYBACK_ENGINE_CODE_216  					0x0b60
+#define PLAYBACK_ENGINE_CODE_217  					0x0b64
+#define PLAYBACK_ENGINE_CODE_218  					0x0b68
+#define PLAYBACK_ENGINE_CODE_219  					0x0b6c
+#define PLAYBACK_ENGINE_CODE_220  					0x0b70
+#define PLAYBACK_ENGINE_CODE_224  					0x0b80
+#define PLAYBACK_ENGINE_CODE_225  					0x0b84
+#define PLAYBACK_ENGINE_CODE_226  					0x0b88
+#define PLAYBACK_ENGINE_CODE_227  					0x0b8c
+#define PLAYBACK_ENGINE_CODE_228  					0x0b90
+#define PLAYBACK_ENGINE_CODE_232  					0x0ba0
+#define PLAYBACK_ENGINE_CODE_233  					0x0ba4
+#define PLAYBACK_ENGINE_CODE_234  					0x0ba8
+#define PLAYBACK_ENGINE_CODE_235  					0x0bac
+#define PLAYBACK_ENGINE_CODE_236  					0x0bb0
+#define PLAYBACK_ENGINE_CODE_240  					0x0bc0
+#define PLAYBACK_ENGINE_CODE_241  					0x0bc4
+#define PLAYBACK_ENGINE_CODE_242  					0x0bc8
+#define PLAYBACK_ENGINE_CODE_243  					0x0bcc
+#define PLAYBACK_ENGINE_CODE_244  					0x0bd0
+#define PLAYBACK_ENGINE_CODE_248  					0x0be0
+#define PLAYBACK_ENGINE_CODE_249  					0x0be4
+#define PLAYBACK_ENGINE_CODE_250  					0x0be8
+#define PLAYBACK_ENGINE_CODE_251  					0x0bec
+#define PLAYBACK_ENGINE_CODE_252  					0x0bf0
+#define PLAYBACK_ENGINE_CODE_256  					0x0c00
+#define PLAYBACK_ENGINE_CODE_257  					0x0c04
+#define PLAYBACK_ENGINE_CODE_258  					0x0c08
+#define PLAYBACK_ENGINE_CODE_259  					0x0c0c
+#define PLAYBACK_ENGINE_CODE_260  					0x0c10
+#define PLAYBACK_ENGINE_CODE_264  					0x0c20
+#define PLAYBACK_ENGINE_CODE_265  					0x0c24
+#define PLAYBACK_ENGINE_CODE_266  					0x0c28
+#define PLAYBACK_ENGINE_CODE_267  					0x0c2c
+#define PLAYBACK_ENGINE_CODE_268  					0x0c30
+ #define     DFIMISC  0x01b0
+ #define     DFITMG0  0x0190
+ #define     DFITMG1  0x0194
+ #define   DFILPCFG0  0x0198
+ #define     DFIUPD0  0x01a0
+ #define     DFIUPD1  0x01a4
+ #define     DFIUPD2  0x01a8
+
+#define STAT 	0x0004
+#define SWSTAT 	0x0324
+
+ #define         DBG1  	0x0304
+ #define       PWRCTL  	0x0030
+ #define         MSTR  	0x0000
+ #define 		MRSTAT  0x0018
+ #define        INIT0  	0x00d0
+ #define        INIT1  	0x00d4
+ #define        INIT2  	0x00d8
+ #define        INIT3  	0x00dc
+ #define        INIT4  	0x00e0
+ #define        INIT5  	0x00e4
+ #define        INIT6  	0x00e8
+ #define	  RANKCTL  	0x00f4
+ #define     DRAMTMG0  	0x0100
+ #define     DRAMTMG1  	0x0104
+ #define     DRAMTMG2  	0x0108
+ #define     DRAMTMG3  	0x010c
+ #define     DRAMTMG4  	0x0110
+ #define     DRAMTMG5  	0x0114
+ #define     DRAMTMG6  	0x0118
+ #define     DRAMTMG7  	0x011c
+ #define     DRAMTMG13  0x0134
+ #define     DRAMTMG14  0x0138
+ #define     ADDRMAP0  	0x0200
+ #define     ADDRMAP1  	0x0204
+ #define     ADDRMAP2  	0x0208
+ #define     ADDRMAP3  	0x020c
+ #define     ADDRMAP4  	0x0210
+ #define     ADDRMAP5  	0x0214
+ #define     ADDRMAP6  	0x0218
+ #define 	ADDRMAP7 	0x021c
+ #define 	ADDRMAP8 	0x0220
+ #define     ADDRMAP9  	0x0224
+ #define    ADDRMAP10  	0x0228
+ #define    ADDRMAP11 	0x022c
+
+ #define      MRCTRL0 0x0010
+ #define      RFSHTMG 0x0064
+ #define       ZQCTL0 0x0180
+ #define      HWLPCTL 0x0038
+ #define       ODTCFG 0x0240
+ #define       ODTMAP 0x0244
+ #define        SCHED 0x0250
+ #define       SCHED1 0x0254
+ #define 	   SCHED3 0x0270
+ #define 	   SCHED4 0x0274
+
+ #define     PERFHPR1 0x025c
+ #define     PERFLPR1 0x0264
+ #define      PERFWR1 0x026c
+ #define         DBG0 0x0300
+ #define       DBGCMD 0x030c
+ #define      PCFGR_0 0x0404
+ #define      PCFGW_0 0x0408
+ #define      PCTRL_0 0x0490
+ #define      PCTRL_1 0x0540
+ #define      PCTRL_2 0x05f0
+ #define      PCTRL_3 0x06a0
+ #define 	  SWCTL   0x0320
+ #define 	 RFSHCTL0 0x0050
+ #define 	 RFSHCTL1 0x0054
+
+/* Register definitions for PHY */
+#define DMC620_PHY_INIT_COMPLETE      0x000
+#define DMC620_PHY_READ_DELAY         0x008
+#define DMC620_PHY_CAPTURE_MASK       0x00C
+#define DMC620_PHY_T_CONTROL_DELAY    0x014
+#define DMC620_PHY_WR_LATENCY         0x018
+#define DMC620_PHY_RDDATA_EN          0x01c
+#define DMC620_PHY_RD_LATENCY         0x020
+#define DMC620_PHY_CLP_ACK            0x030
+#define DMC620_PHY_RDLVL_REQ          0x044
+#define DMC620_PHY_WRLVL_REQ          0x04C
+#define DMC620_PHY_WR_PREMBL          0x058
+#define DMC620_PHY_DELAY_SEL	      0x820
+#define DMC620_PHY_REF_EN	      0x824
+#define DMC620_PHY_T_CTRL_UPD_MIN     0x828
+#define DMC620_PHY_OP_DELAY1          0x830
+#define DMC620_PHY_OP_DELAY2          0x834
+#define DMC620_PHY_OP_DELAY3          0x838
+#define DMC620_PHY_OP_DELAY4          0x83C
+
+#define DMC620_STATUS  	      				    0x000
+#define DMC620_CONFIG  	      				    0x004
+#define DMC620_COMMAND 	      	  	     		    0x008
+#define DMC620_ADD_CONTROL	      		   	    0x010
+#define DMC620_DEC_CONTROL	      		   	    0x014
+#define DMC620_FORMAT_CONTROL	      		   	    0x018
+#define DMC620_ADDRESS_MAP	      		   	    0x01c
+#define DMC620_LOW_PWR_CONTROL	      		   	    0x020
+#define DMC620_TURNAROUND_CONTROL     		   	    0x028
+#define DMC620_HIT_TURNAROUND_CONTROL 		   	    0x02c
+#define DMC620_QOS_CLASS_CONTROL      		   	    0x030
+#define DMC620_ESCALATION_CONTROL     		   	    0x034
+#define DMC620_QV_CONTROL_31_00       		   	    0x038
+#define DMC620_QV_CONTROL_63_32       		   	    0x03c
+#define DMC620_RT_CONTROL_31_00       		   	    0x040
+#define DMC620_RT_CONTROL_63_32       		   	    0x044
+#define DMC620_TIMEOUT_CONTROL        		   	    0x048
+#define DMC620_CREDIT_CONTROL        		   	    0x04c
+#define DMC620_WRITE_PRIORITY_CONTROL_31_00        	    0x050
+#define DMC620_WRITE_PRIORITY_CONTROL_63_32        	    0x054
+#define DMC620_QUEUE_THRESHOLD_CONTROL_31_00                0x058
+#define DMC620_QUEUE_THRESHOLD_CONTROL_63_32                0x05c
+#define DMC620_ADDR_SHUTTER_31_00                     	    0x060
+#define DMC620_ADDR_SHUTTER_63_32                     	    0x064
+#define DMC620_ADDR_SHUTTER_95_64                     	    0x068
+#define DMC620_ADDR_SHUTTER_127_96                     	    0x06c
+#define DMC620_ADDR_SHUTTER_159_128                    	    0x070
+#define DMC620_ADDR_SHUTTER_191_160                    	    0x074
+#define DMC620_MEMORY_ADDRESS_MAX_31_00    	      	    0x078
+#define DMC620_MEMORY_ADDRESS_MAX_43_32			    0x07C
+#define DMC620_ACCESS_ADDRESS_MIN0_31_00   		    0x080
+#define DMC620_ACCESS_ADDRESS_MIN0_43_32		    0x084
+#define DMC620_ACCESS_ADDRESS_MAX0_31_00   		    0x088
+#define DMC620_ACCESS_ADDRESS_MAX0_43_32   		    0x08C
+#define DMC620_ACCESS_ADDRESS_MIN1_31_00   		    0x090
+#define DMC620_ACCESS_ADDRESS_MIN1_43_32   		    0x094
+#define DMC620_ACCESS_ADDRESS_MAX1_31_00   		    0x098
+#define DMC620_ACCESS_ADDRESS_MAX1_43_32   		    0x09C
+#define DMC620_ACCESS_ADDRESS_MIN2_31_00   		    0x0a0
+#define DMC620_ACCESS_ADDRESS_MIN2_43_32   		    0x0a4
+#define DMC620_ACCESS_ADDRESS_MAX2_31_00   		    0x0a8
+#define DMC620_ACCESS_ADDRESS_MAX2_43_32   		    0x0ac
+#define DMC620_ACCESS_ADDRESS_MIN3_31_00   		    0x0b0
+#define DMC620_ACCESS_ADDRESS_MIN3_43_32   		    0x0b4
+#define DMC620_ACCESS_ADDRESS_MAX3_31_00   		    0x0b8
+#define DMC620_ACCESS_ADDRESS_MAX3_43_32   		    0x0bc
+#define DMC620_ACCESS_ADDRESS_MIN4_31_00   		    0x0c0
+#define DMC620_ACCESS_ADDRESS_MIN4_43_32   		    0x0c4
+#define DMC620_ACCESS_ADDRESS_MAX4_31_00   		    0x0c8
+#define DMC620_ACCESS_ADDRESS_MAX4_43_32   		    0x0cc
+#define DMC620_ACCESS_ADDRESS_MIN5_31_00   		    0x0d0
+#define DMC620_ACCESS_ADDRESS_MIN5_43_32   		    0x0d4
+#define DMC620_ACCESS_ADDRESS_MAX5_31_00   		    0x0d8
+#define DMC620_ACCESS_ADDRESS_MAX5_43_32   		    0x0dc
+#define DMC620_ACCESS_ADDRESS_MIN6_31_00   		    0x0e0
+#define DMC620_ACCESS_ADDRESS_MIN6_43_32   		    0x0e4
+#define DMC620_ACCESS_ADDRESS_MAX6_31_00   		    0x0e8
+#define DMC620_ACCESS_ADDRESS_MAX6_43_32   		    0x0ec
+#define DMC620_ACCESS_ADDRESS_MIN7_31_00   		    0x0f0
+#define DMC620_ACCESS_ADDRESS_MIN7_43_32   		    0x0f4
+#define DMC620_ACCESS_ADDRESS_MAX7_31_00   		    0x0f8
+#define DMC620_ACCESS_ADDRESS_MAX7_43_32   		    0x0fc
+#define DMC620_DIRECT_ADDR	      			    0x108
+#define DMC620_DIRECT_CMD	      			    0x10c
+#define DMC620_DCI_REPLAY_TYPE	      			    0x110
+#define DMC620_DCI_STRB      	      			    0x118
+#define DMC620_DCI_DATA      	      			    0x11c
+#define DMC620_REFRESH_CONTROL	      			    0x120
+#define DMC620_MEMORY_TYPE	      			    0x128
+#define DMC620_FEATURE_CONFIG         			    0x130
+#define DMC620_SCRUB_CONTROL0	      			    0x170
+#define DMC620_SCRUB_CONTROL1	      			    0x180
+#define DMC620_SCRUB_CONTROL2	      			    0x190
+#define DMC620_SCRUB_CONTROL3	      			    0x1a0
+#define DMC620_SCRUB_CONTROL4	      			    0x1b0
+#define DMC620_SCRUB_CONTROL5	      			    0x1c0
+#define DMC620_SCRUB_CONTROL6	      			    0x1d0
+#define DMC620_SCRUB_CONTROL7	      			    0x1e0
+#define DMC620_FEATURE_CONTROL          		    0x1f0
+#define DMC620_MUX_CONTROL              		    0x1f4
+#define DMC620_RANK_REMAP_CONTROL       		    0x1f8
+#define DMC620_SCRUB_CONTROL    	      	      	    0x1fc
+#define DMC620_T_REFI  	      	      	      	      	    0x200
+#define DMC620_T_RFC		      			    0x204
+#define DMC620_T_MRR		      			    0x208
+#define DMC620_T_MRW		      			    0x20c
+#define DMC620_T_REFRESH_ENABLE	      	      	      	    0x210
+#define DMC620_T_RCD		      			    0x218
+#define DMC620_T_RAS		      			    0x21c
+#define DMC620_T_RP		      			    0x220
+#define DMC620_T_RPALL 	      	      			    0x224
+#define DMC620_T_RRD		      			    0x228
+#define DMC620_T_ACT_WINDOW	      			    0x22c
+#define DMC620_T_RTR		      			    0x234
+#define DMC620_T_RTW		      			    0x238
+#define DMC620_T_RTP		      			    0x23c
+#define DMC620_T_WR		      			    0x244
+#define DMC620_T_WTR		      			    0x248
+#define DMC620_T_WTW		      			    0x24c
+#define DMC620_T_XMPD		      			    0x254
+#define DMC620_T_EP		      			    0x258
+#define DMC620_T_XP		      			    0x25c
+#define DMC620_T_ESR		      			    0x260
+#define DMC620_T_XSR		      			    0x264
+#define DMC620_T_ESRCK 	      	      			    0x268
+#define DMC620_T_CKXSR 	      	      			    0x26c
+#define DMC620_T_CMD		      			    0x270
+#define DMC620_T_PARITY	      	      			    0x274
+#define DMC620_T_ZQCS	      	      			    0x278
+#define DMC620_T_RW_ODT_CLR    	      			    0x27c
+#define DMC620_T_RDDATA_EN	      			    0x300
+#define DMC620_T_PHYRDLAT	      			    0x304
+#define DMC620_T_PHYWRLAT	      			    0x308
+#define DMC620_RDLVL_CONTROL	      			    0x310
+#define DMC620_RDLVL_MRS	      			    0x314
+#define DMC620_T_RDLVL_EN	      			    0x318
+#define DMC620_T_RDLVL_RR	      			    0x31c
+#define DMC620_WDLVL_CONTROL	      			    0x320
+#define DMC620_WRLVL_MRS	      			    0x324
+#define DMC620_T_WRLVL_EN	      			    0x328
+#define DMC620_T_WRLVL_WW	      			    0x32c
+#define DMC620_PHY_POWER_CONTROL      			    0x348
+#define DMC620_T_LPRESP	      	      			    0x34c
+#define DMC620_PHY_UPDATE_CONTROL     			    0x350
+#define DMC620_ODTH   		      			    0x354
+#define DMC620_ODT_TIMING	      			    0x358
+#define DMC620_ODT_WR_CONTROL_31_00   			    0x360
+#define DMC620_ODT_WR_CONTROL_63_32   			    0x364
+#define DMC620_ODT_RD_CONTROL_31_00   			    0x368
+#define DMC620_ODT_RD_CONTROL_63_32   			    0x36C
+
+
+
diff --git a/module/snps_umctl/include/fw_tzc400.h b/module/snps_umctl/include/fw_tzc400.h
new file mode 100644
index 00000000..94eec1bd
--- /dev/null
+++ b/module/snps_umctl/include/fw_tzc400.h
@@ -0,0 +1,82 @@
+/*
+ * ARM System Control Processor Software
+ *
+ * This confidential and proprietary software may be used only as
+ * authorised by a licensing agreement from ARM Limited
+ * (C) COPYRIGHT 2012 ARM Limited
+ * ALL RIGHTS RESERVED
+ * The entire notice above must be reproduced on all authorised
+ * copies and copies may only be made to the extent permitted
+ * by a licensing agreement from ARM Limited.
+ *
+ * Description:
+ *     This module implements the TZC400 routines.
+ */
+
+#ifndef FW_TZC400_H
+#define FW_TZC400_H
+
+// #include <global_defines.h>
+
+typedef struct {
+	__IO uint32_t         FAIL_ADDRESS_LOW;
+	__IO uint32_t         FAIL_ADDRESS_HIGH;
+	__IO uint32_t         FAIL_CONTROL;
+	__IO uint32_t         FAIL_ID;
+} TZC400_FAIL_TypeDef;
+
+
+typedef struct {
+	__IO uint32_t         REGION_BASE_LOW;
+	__IO uint32_t         REGION_BASE_HIGH;
+	__IO uint32_t         REGION_TOP_LOW;
+	__IO uint32_t         REGION_TOP_HIGH;
+	__IO uint32_t         REGION_ATTRIBUTES;
+	__IO uint32_t         REGION_ID_ACCESS;
+	__IO uint32_t         RESERVED3[2];
+} TZC400_REGION_TypeDef;
+
+typedef struct {
+	__IO uint32_t         BUILD_CONFIG;
+	__IO uint32_t         ACTION;
+	__IO uint32_t         GATE_KEEPER;
+	__IO uint32_t         SPECULATION_CTRL;
+	__IO uint32_t         INT_STATUS;
+	__IO uint32_t         INT_CLEAR;
+	__IO uint32_t         RESERVED1[2];
+	TZC400_FAIL_TypeDef   FAIL[4];
+	__IO uint32_t         RESERVED2[40];
+	TZC400_REGION_TypeDef REGION[9];
+ } TZC400_TypeDef;
+
+/*
+ * TZC400 initialisation.
+ */
+void fw_tzc400_init( unsigned int);
+
+/*
+ * TZC400 Filter setup
+ */
+void fw_tzc400_filter_setup( uint32_t, uint32_t, uint32_t, uint32_t);
+
+/*
+ * TZC400 Region setup
+ */
+void fw_tzc400_region_setup( uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t);
+
+/*
+ * TZC400 Interrupt Clearing
+ */
+void fw_tzc400_clear_int( uint32_t, uint32_t);
+
+/*
+ * TZC400 interrupt status
+ */
+uint32_t fw_tzc400_get_int_status( uint32_t);
+
+/*
+ * TZC400 BUILD CONFIGURATION
+ */
+uint32_t fw_tzc400_get_build_config( uint32_t);
+#endif /* FW_TZC400_H */
+
diff --git a/module/snps_umctl/include/mod_snps_umctl.h b/module/snps_umctl/include/mod_snps_umctl.h
new file mode 100644
index 00000000..9e34697e
--- /dev/null
+++ b/module/snps_umctl/include/mod_snps_umctl.h
@@ -0,0 +1,13 @@
+/*
+ * Arm SCP/MCP Software
+ * Copyright (c) 2020, Arm Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef MOD_SNPS_UMCTL_H
+#define MOD_SNPS_UMCTL_H
+
+#include <fwk_id.h>
+
+#endif /* MOD_LOG_H */
diff --git a/module/snps_umctl/include/phy_registers.h b/module/snps_umctl/include/phy_registers.h
new file mode 100644
index 00000000..fad87e5e
--- /dev/null
+++ b/module/snps_umctl/include/phy_registers.h
@@ -0,0 +1,27 @@
+/* Register definitions for PHY */
+#define PHY_INIT_COMPLETE      0x000
+#define PHY_READ_DELAY         0x008
+#define PHY_CAPTURE_MASK       0x00C
+#define PHY_CAS_LATENCY        0x010
+#define PHY_T_CTRL_DELAY       0x014
+#define PHY_WR_LATENCY         0x018
+#define PHY_RDDATA_EN          0x01c
+#define PHY_RD_LATENCY         0x020
+#define PHY_LP_REQ             0x02C
+#define PHY_LP_ACK             0x030
+#define PHY_RDLVL_REQ          0x034
+#define PHY_RDLVL_EN           0x038
+#define PHY_WRLVL_REQ          0x03C
+#define PHY_WRLVL_EN           0x040
+#define PHY_MSTR_REQ           0x044
+#define PHY_MSTR_ACK           0x048
+#define PHY_WR_PREMBL          0x04C
+#define PHY_DELAY_SEL          0x820 
+#define PHY_REF_EN             0x824 
+#define PHY_T_CTRL_UPD_MIN     0x828 
+#define PHY_OP_DELAY1          0x830   
+#define PHY_OP_DELAY2          0x834    
+#define PHY_OP_DELAY3          0x838    
+#define PHY_OP_DELAY4          0x83C    
+
+
diff --git a/module/snps_umctl/include/snps_defines.h b/module/snps_umctl/include/snps_defines.h
new file mode 100644
index 00000000..940cb833
--- /dev/null
+++ b/module/snps_umctl/include/snps_defines.h
@@ -0,0 +1,168 @@
+
+#ifndef LPDDR5
+
+#ifndef UMCTL2_DEFINES_H
+#define UMCTL2_DEFINES_H
+
+#ifndef UMCTL2_RDWR_IDLE_GAP
+#define UMCTL2_RDWR_IDLE_GAP 0
+#endif
+
+#ifndef UMCTL2_LPR_NUM_ENTRIES
+#define UMCTL2_LPR_NUM_ENTRIES 2
+#endif
+
+#ifndef UMCTL2_OPT_WRCAM_FILL_LEVEL
+#define UMCTL2_OPT_WRCAM_FILL_LEVEL 1
+#endif
+
+#ifndef UMCTL2_ENHANCED_RW
+#define UMCTL2_ENHANCED_RW 1
+#endif
+
+#ifndef UMCTL2_PC_TIMER
+#define UMCTL2_PC_TIMER 0x20
+#endif
+
+#ifndef UMCTL2_FORCE_LOW_PRI
+#define UMCTL2_FORCE_LOW_PRI 1
+#endif
+
+#ifndef UMCTL2_DELAY_SWITCH_WRITE
+#define UMCTL2_DELAY_SWITCH_WRITE 2
+#endif
+
+#ifndef UMCTL2_RD_PGHIT_NUM_THRESH
+#define UMCTL2_RD_PGHIT_NUM_THRESH 4
+#endif
+
+#ifndef UMCTL2_WR_PGHIT_NUM_THRESH
+#define UMCTL2_WR_PGHIT_NUM_THRESH 4
+#endif
+
+#ifndef UMCTL2_WRCAM_HIGHTHRESH
+#define UMCTL2_WRCAM_HIGHTHRESH 2
+#endif
+
+#ifndef UMCTL2_WRCAM_LOWTHRESH
+#define UMCTL2_WRCAM_LOWTHRESH 32
+#endif
+
+#ifndef UMCTL2_WR_ACT_GAP
+#define UMCTL2_WR_ACT_GAP 16
+#endif
+
+#ifndef UMCTL2_RD_ACT_GAP
+#define UMCTL2_RD_ACT_GAP 128
+#endif
+
+#ifndef UMCTL_PAGE_HIT_LIMIT_RD
+#define UMCTL_PAGE_HIT_LIMIT_RD 0
+#endif
+
+#ifndef UMCTL_PAGE_HIT_LIMIT_WR
+#define UMCTL_PAGE_HIT_LIMIT_WR 0
+#endif
+
+#ifndef UMCTL_WINDOW_LIMIT_RD
+#define UMCTL_WINDOW_LIMIT_RD 0
+#endif
+
+#ifndef UMCTL_WINDOW_LIMIT_WR
+#define UMCTL_WINDOW_LIMIT_WR 0
+#endif
+
+#ifndef UMCTL2_VP_TIMEOUT
+#define UMCTL2_VP_TIMEOUT 0x000f000f
+#endif
+
+#endif
+
+#else //SNPS_VIP_FW
+
+#ifndef UMCTL_DEFINES_H
+#define UMCTL_DEFINES_H
+
+#ifndef UMCTL_RDWR_IDLE_GAP
+#define UMCTL_RDWR_IDLE_GAP 0
+#endif
+
+#ifndef UMCTL_LPR_NUM_ENTRIES
+#ifdef QOS_DISABLE
+#define UMCTL_LPR_NUM_ENTRIES 63
+#else
+#define UMCTL_LPR_NUM_ENTRIES 2
+#endif
+#endif
+
+#ifndef UMCTL_OPT_WRCAM_FILL_LEVEL
+#define UMCTL_OPT_WRCAM_FILL_LEVEL 1
+#endif
+
+#ifndef UMCTL_ENHANCED_RW
+#define UMCTL_ENHANCED_RW 1
+#endif
+
+#ifndef UMCTL_PC_TIMER
+#define UMCTL_PC_TIMER 0x20
+#endif
+
+#ifndef UMCTL_FORCE_LOW_PRI
+#define UMCTL_FORCE_LOW_PRI 1
+#endif
+
+#ifndef UMCTL_DELAY_SWITCH_WRITE
+#define UMCTL_DELAY_SWITCH_WRITE 0
+#endif
+
+#ifndef UMCTL_RD_PGHIT_NUM_THRESH
+#define UMCTL_RD_PGHIT_NUM_THRESH 4
+#endif
+
+#ifndef UMCTL_WR_PGHIT_NUM_THRESH
+#define UMCTL_WR_PGHIT_NUM_THRESH 8
+#endif
+
+#ifndef UMCTL_WRCAM_HIGHTHRESH
+#define UMCTL_WRCAM_HIGHTHRESH 16
+#endif
+
+#ifndef UMCTL_WRCAM_LOWTHRESH
+#define UMCTL_WRCAM_LOWTHRESH 32
+#endif
+
+#ifndef UMCTL_WR_ACT_GAP
+#define UMCTL_WR_ACT_GAP 0
+#endif
+
+#ifndef UMCTL_RD_ACT_GAP
+#define UMCTL_RD_ACT_GAP 0
+#endif
+
+#ifndef UMCTL_PAGE_HIT_LIMIT_RD
+#define UMCTL_PAGE_HIT_LIMIT_RD 0
+#endif
+
+#ifndef UMCTL_PAGE_HIT_LIMIT_WR
+#define UMCTL_PAGE_HIT_LIMIT_WR 0
+#endif
+
+#ifndef UMCTL_WINDOW_LIMIT_RD
+#define UMCTL_WINDOW_LIMIT_RD 0
+#endif
+
+#ifndef UMCTL_WINDOW_LIMIT_WR
+#define UMCTL_WINDOW_LIMIT_WR 0
+#endif
+
+#ifndef UMCTL_VP_TIMEOUT
+#define UMCTL_VP_TIMEOUT 0x000f000f
+#endif
+
+#ifndef UMCTL_VP_WTIMEOUT
+#define UMCTL_VP_WTIMEOUT 0x000f000f
+#endif
+
+#endif
+
+#endif //SNPS_VIP_FW
diff --git a/module/snps_umctl/include/test_defs.h b/module/snps_umctl/include/test_defs.h
new file mode 100644
index 00000000..f5613d76
--- /dev/null
+++ b/module/snps_umctl/include/test_defs.h
@@ -0,0 +1,118 @@
+#ifndef TEST_DEFS_H
+#define TEST_DEFS_H
+
+
+#define HCG 1       // Enable High Level Clock Gating
+
+//Clock Divider Settings
+#define CCI_NO_SCP
+
+//Clock Divider Settings
+#define BCPU_CLKDIV   0
+#define BCPU_ACLKDIV  1
+#define LCPU_CLKDIV   0
+#define LCPU_ACLKDIV  0
+#define GPU_CLKDIV    0
+#define DPU_M0CLKDIV  0
+#define DPU_M1CLKDIV  0
+#define DPU_ACLKDIV   0
+#define VPU_CLKDIV    0
+
+// QoS Settings
+
+#define CPUASI0_RD_QOS   0x80020057
+#define CPUASI0_WR_QOS   0x80020057
+#define CPUASI1_RD_QOS   0x80020057
+#define CPUASI1_WR_QOS   0x80020057
+
+#define GPUASI0_RD_QOS   0x4
+#define GPUASI0_WR_QOS   0x4
+#define GPUASI1_RD_QOS   0x4
+#define GPUASI1_WR_QOS   0x4
+
+#define VPUASI_RD_QOS    0x8
+#define VPUASI_WR_QOS    0x8
+#define DMC_TIMEOUT_CONTROL                1
+#define DMC_RT_TIMEOUT_CONTROL 0x00008800
+#define DMC_RANK_TURNAROUND_CONTROL 0x0F0F0F0F
+#define DMC_HIT_TURNAROUND_CONTROL 0x8290BF80
+#define DMC_DIR_TURNAROUND_CONTROL 0x05050F00
+#define DMC_QOS_CLASS_CONTROL 0x00000C84
+#define DMC_QUEUE_THRESHOLD_CONTROL_63_32 0x99887700
+#define DMC_QUEUE_THRESHOLD_CONTROL_31_00 0x00000000
+#define DMC_WRITE_PRIORITY_CONTROL_63_32 0xEC840000
+#define DMC_WRITE_PRIORITY_CONTROL_31_00 0x00000000
+#define DPUASI0_ACOM_R   0x00000014
+#define DPUASI1_ACOM_R   0x00000014
+#define ISP_REAR_ACOM_R  0x00000014
+#define ISP_FRONT_ACOM_R 0x00000014
+
+
+// DMC500 settings
+#define DMC_BASE_ADDR       0xC1000000
+#define DMC_OFFSET          0x01000000
+#define DMC_PHY_BASE_ADDR   0xA8000000
+#define DMC_PHY_OFFSET      0x00010000
+#define UMCTL2_INIT_FUN     "umctl2_lpddr4_3200.h"
+#define MULTI_PORT
+#define UMCTL2_PC_TIMER            0x00000020
+//#define UMCTL2_LPR_NUM_ENTRIES     0x00000010
+#define UMCTL2_VP_TIMEOUT          0x03c003c0
+#define UMCTL2_VP_WTIMEOUT         0x03e803e8
+#define UMCTL2_PORT1_TIMEOUT       0x00004000
+//#define UMCTL2_RDWR_IDLE_GAP       0x00000040
+#define UMCTL2_RD_PGHIT_NUM_THRESH 0x00000008
+#define UMCTL2_WR_PGHIT_NUM_THRESH 0x00000000
+//#define UMCTL2_RD_ACT_GAP          0x00000040
+//#define UMCTL2_WR_ACT_GAP          0x00000008
+//#define UMCTL2_DELAY_SWITCH_WRITE  0x0000000F
+
+// format_control
+#define DMC_FMT_CTRL_ALIGN_BOUNDARY 1
+#define DMC_PHY_SYNCUP 1
+#define DMC_ACCESS_GRAN 1
+#define DMC_COL_BITS 1         // 10 col bits -1 for syncup
+#define DMC_BANK_BITS 0        // 8 banks
+#define DMC_RANK_BITS 1        // 2 ranks
+#define DMC_BANK_GROUP 0       // 0 bank groups
+#define MEM_CHANNEL 4
+#define DMC_ADDR_SHUTTER 2
+
+#ifndef DMC_HASH_ENABLE
+#define DMC_HASH_ENABLE 1
+#endif
+
+#define DMC_ADDR_DEC 1 //rcb
+  
+// LPDDR4-4267 x16 (cernan)
+#define LPDDR4_4267
+#define DMC_DEVICE_WIDTH 2 // x16
+#define DMC_MEM_BURST 3        // 32 on the fly
+#define DMC_MEM_TYPE 3         // LPDDR4
+#define DMC_ROW_BITS 5         // 16 row bits
+  #define DPU_TRANS_LENGTH 8
+
+// UMCTL2 specific values
+#define UMCTL2_RDWR_IDLE_GAP          0x40
+#define UMCTL2_LPR_NUM_ENTRIES        0x00
+#define UMCTL2_WR_ACT_GAP             0x00
+#define UMCTL2_RD_ACT_GAP             0x00
+#define UMCTL2_RD_PGHIT_NUM_THRESHOLD 0x08
+#define UMCTL2_DELAY_SWITCH_WRITE     0x0F
+
+#define NPU0_BASE 0x050000000
+
+#define SDRAM_BASE_ADDR               0x80000000
+#define SDRAM_HIGH_ADDR               0x880000000
+#define SDRAM_END_ADDR                (0x880000000+(size_t)PMA_SIZE*0x40000000)
+#define ALLOC_END                     SDRAM_END_ADDR
+#define SYSREGS_BASE                  0x1c010000
+#define UART_BASE_ADDR                0x7ff80000
+#define REFCNTCTRL_BASE_ADDR          0x2A430000
+#define PAGESIZE                      0x1000
+#define PMA_SIZE 6
+#define REFFREQ 500
+#define CPUFREQ 2700
+
+#endif // TEST_DEFS_H
+
diff --git a/module/snps_umctl/include/umctl2_lpddr4_3200_init_mem.h b/module/snps_umctl/include/umctl2_lpddr4_3200_init_mem.h
new file mode 100644
index 00000000..b9c52aa1
--- /dev/null
+++ b/module/snps_umctl/include/umctl2_lpddr4_3200_init_mem.h
@@ -0,0 +1,22 @@
+
+  while ((MEM_RW(DMC_BASE, 0x18)&0x1)  ==1 );  // MRSTAT - wait busy
+
+  // Configure PHY
+  MEM_RW(PHY_BASE,DMC620_PHY_INIT_COMPLETE)   = 0x00000001; //0x00
+  MEM_RW(PHY_BASE,DMC620_PHY_READ_DELAY)      = 0x00000002; //0x08
+  MEM_RW(PHY_BASE,DMC620_PHY_CAPTURE_MASK)    = 0x0000001f; //0x0C
+  MEM_RW(PHY_BASE,DMC620_PHY_T_CONTROL_DELAY) = 0x00000000; //0x14
+  MEM_RW(PHY_BASE,DMC620_PHY_WR_LATENCY)      = 0x01000000; //0x18
+  MEM_RW(PHY_BASE,DMC620_PHY_RDDATA_EN)       = 0x00001a00; //0x1C
+  MEM_RW(PHY_BASE,DMC620_PHY_RD_LATENCY)      = 0x00000016; //0x20
+  MEM_RW(PHY_BASE,DMC620_PHY_CLP_ACK)         = 0x00641300; //0x30
+  MEM_RW(PHY_BASE,DMC620_PHY_WRLVL_REQ)       = 0x00000002; //0x4c PHY500_DFI_WR_PREMBL (0x58 DMC620_PHY_WR_PREMBL)
+  MEM_RW(PHY_BASE,DMC620_PHY_WR_PREMBL)       = 0x00000001; //0x58
+  MEM_RW(PHY_BASE,DMC620_PHY_DELAY_SEL)       = 0x0000000A; //0x820
+  //MEM_RW(PHY_BASE,DMC620_PHY_REF_EN)          = 0x00000000; //0x824
+  MEM_RW(PHY_BASE,DMC620_PHY_T_CTRL_UPD_MIN)  = 0x00000000; //0x828
+
+//  while ((MEM_RW(DMC_BASE, 0x4)&0x1) != 1 );  // STAT - wait until normal
+
+//
+
diff --git a/module/snps_umctl/include/umctl2_lpddr4_3200_init_regs.h b/module/snps_umctl/include/umctl2_lpddr4_3200_init_regs.h
new file mode 100644
index 00000000..10060cd2
--- /dev/null
+++ b/module/snps_umctl/include/umctl2_lpddr4_3200_init_regs.h
@@ -0,0 +1,93 @@
+
+//void SMC_lpddr4_3200(uint32_t DMC_BASE,uint32_t PHY_BASE) {
+  MEM_RW(DMC_BASE, 0x00)  = 0x03080020; // MSTR - LPDDR4/2Rank/BL16
+  MEM_RW(DMC_BASE, 0xd0)  = 0x00000000; // INIT0 - skip_dram_init
+  MEM_RW(DMC_BASE, 0xdc)  = 0x0054002d; // INIT3 - MR1=0x54/MR2=0x2d
+
+  // RCB SDRAM address map
+  MEM_RW(DMC_BASE, 0x200) = 0x00000007; // ADDRMAP0 - addrmap_cs_b0        = 1 + 6 + 7  + [0]     = [14]
+  MEM_RW(DMC_BASE, 0x204) = 0x00080808; // ADDRMAP1 - addrmap_bank_b[2:0]  = 1 + 2 + 8  + [2:0]   = [13,12,11]
+  MEM_RW(DMC_BASE, 0x208) = 0x00000000; // ADDRMAP2 - addrmap_col_b[5:2]   = 1 + 0 + 0  + [5:2]   = [6:3]  
+  MEM_RW(DMC_BASE, 0x20c) = 0x00000000; // ADDRMAP3 - addrmap_col_b[9:6]   = 1 + 0 + 0  + [9:6]   = [10,9,8,7]  
+  MEM_RW(DMC_BASE, 0x210) = 0x00000000; // ADDRMAP4 - addrmap_col_b[11:10] = 1 + 0 + 0  + [11:10] = [12:11] -- unused
+  MEM_RW(DMC_BASE, 0x214) = 0x08080808; // ADDRMAP5 - addrmap_row_b[11:0]  = 1 + 6 + 10 + [11:0]  = [26:15]
+  MEM_RW(DMC_BASE, 0x218) = 0x08080808; // ADDRMAP6 - addrmap_row_b[15:12] = 1 + 6 + 10 + [15:12] = [30:27]
+  MEM_RW(DMC_BASE, 0x21C) = 0x00000808; // ADDRMAP7 - addrmap_row_b[17:16] = 1 + 6 + 10 + [17:16] = [32:31]
+
+  // Timing
+  MEM_RW(DMC_BASE, 0x050) = 0x00210074; // RFSHCTL0 - margin=2 ref_to=0x10 burst=8 per-bank-refresh
+  MEM_RW(DMC_BASE, 0x054) = 0x00400040; // RFSHCTL1 - timer0 = 0x40 timer1 = 0x40 
+#ifdef DMC_DISABLE_REFRESH
+  MEM_RW(DMC_BASE, 0x060) = 0x00000001; // RFSHCTL3  - dis_auto_ref
+#endif
+  MEM_RW(DMC_BASE, 0x064) = 0x00620121; // RFSHTMG  - tREFI = [16] - 3.9us/0.624ns/2/32 = 0x62 tRFC = [0] - 33  MEM_RW(DMC_BASE, 0x100) = 0x1a203622; // DRAMTMG0 - twr2pre = [24] - 26 tfaw = 32(40ns) trasmax=36 trasmin=34
+  MEM_RW(DMC_BASE, 0x0f4) = 0x00000220; // RANKCTL - wrgap = 2 rdgap = 2 maxrd = 0
+  MEM_RW(DMC_BASE, 0x100) = 0x1a203622; // DRAMTMG0 - twr2pre = [24] - 26 tfaw = 32(40ns) trasmax=36 trasmin=34
+  MEM_RW(DMC_BASE, 0x104) = 0x00060630; // DRAMTMG1 - txp = 8 rd2pre=6 trc=6
+  MEM_RW(DMC_BASE, 0x108) = 0x00001015; // DRAMTMG2 - trd2wr = 16 twr2rd=21
+  MEM_RW(DMC_BASE, 0x10c) = 0x005b0c00; // DRAMTMG3 - 
+  MEM_RW(DMC_BASE, 0x110) = 0x0f04080f; // DRAMTMG4 - trcd = 15(20ns) tccd = 4(5ns) trrd = 8(10ns) trp = 15(20ns)
+  MEM_RW(DMC_BASE, 0x114) = 0x02040c0c; // DRAMTMG5 - 
+  MEM_RW(DMC_BASE, 0x118) = 0x01010007; // DRAMTMG6 - 
+  MEM_RW(DMC_BASE, 0x11c) = 0x00000402; // DRAMTMG7 - 
+  MEM_RW(DMC_BASE, 0x134) = 0x0c100002; // DRAMTMG13- todtloff = 28 tccd_mw = 4(5ns) tppd = 2 
+  MEM_RW(DMC_BASE, 0x138) = 0x00000136; // DRAMTMG14- 
+  MEM_RW(DMC_BASE, 0x180) = 0xc3200018; // ZQCTL0   - 
+  MEM_RW(DMC_BASE, 0x190) = 0x0000810e; // DFITMG0  - tctldelay = 0 trddataen = 0 tphywrdata = 1 tphywrlat = 14
+
+  MEM_RW(DMC_BASE, 0x250) = (UMCTL2_RDWR_IDLE_GAP << 24)       | (UMCTL2_LPR_NUM_ENTRIES << 8) |
+      	      	      	    (UMCTL2_OPT_WRCAM_FILL_LEVEL << 4) | (UMCTL2_ENHANCED_RW << 3) | 
+			    ((UMCTL2_PC_TIMER!=-1)?(1<<2):0)   | (UMCTL2_FORCE_LOW_PRI); // SCHED
+  MEM_RW(DMC_BASE, 0x254) = (UMCTL2_DELAY_SWITCH_WRITE << 12); //  + ((UMCTL2_PC_TIMER!=-1)? UMCTL2_PC_TIMER:0) ; //0x0000f000; // SCHED1   - delay_switch_write=15 pageclosetimer=tRAS=00
+  MEM_RW(DMC_BASE, 0x270) = (UMCTL2_RD_PGHIT_NUM_THRESH << 24) | (UMCTL2_WR_PGHIT_NUM_THRESH << 16) | 
+      	      	      	    (UMCTL2_WRCAM_HIGHTHRESH << 8)     | UMCTL2_WRCAM_LOWTHRESH; //0x04040220; // SCHED3   - wrcam_highthresh=2 wrcam_lowthresh=32
+  MEM_RW(DMC_BASE, 0x274) = (UMCTL2_WR_ACT_GAP << 8)           | UMCTL2_RD_ACT_GAP; // SCHED4   - wr_page_exp=8 rd_pageexp=64 wractgap=0 rdactgap=0
+
+  MEM_RW(DMC_BASE, 0x25c) = 0x08000020;
+  MEM_RW(DMC_BASE, 0x264) = 0x140003e8;
+  MEM_RW(DMC_BASE, 0x26c) = 0x0f0003e8;
+
+  // Enable QOS
+  MEM_RW(DMC_BASE, 0x494+0xb0*0)  = 0x00110000;  // RQOS region2>0 region1>0
+  MEM_RW(DMC_BASE, 0x498+0xb0*0)  = UMCTL2_VP_TIMEOUT;  // RQOS region2>0 region1>0
+  MEM_RW(DMC_BASE, 0x49c+0xb0*0)  = 0x00110000;         // WQOS region2>0 region1>0
+  MEM_RW(DMC_BASE, 0x4a0+0xb0*0)  = UMCTL2_VP_WTIMEOUT; // WQOS region2>0 region1>0
+#ifdef MULTI_PORT
+  MEM_RW(DMC_BASE, 0x494+0xb0*1)  = 0x00200004;         // RQOS region2>0 region1>0
+  MEM_RW(DMC_BASE, 0x498+0xb0*1)  = UMCTL2_VP_TIMEOUT;  // RQOS region2>0 region1>0
+  MEM_RW(DMC_BASE, 0x49c+0xb0*1)  = 0x00000000;         // WQOS region2>0 region1>0
+  MEM_RW(DMC_BASE, 0x4a0+0xb0*1)  = UMCTL2_VP_WTIMEOUT; // WQOS region2>0 region1>0
+#endif
+
+  // Enable AXI Ports
+  MEM_RW(DMC_BASE, 0x490+0xb0*0)  = 0x000000001;  // PCTRL_0 - [0] - 1 AXI PORT enable
+#ifdef MULTI_PORT
+  MEM_RW(DMC_BASE, 0x490+0xb0*1)  = 0x000000001;  // PCTRL_1 - [0] - 1 AXI PORT enable
+#ifdef UMCTL2_PORT1_TIMEOUT
+  MEM_RW(DMC_BASE, 0x404+0xb0*1) = UMCTL2_PORT1_TIMEOUT;
+#endif
+#endif
+
+  // ARM Standard address map passthrough
+  MEM_RW(DMC_BASE, 0xF04+0x8*0) = 0x000; // SARBASE0 - 0x0000000000
+  MEM_RW(DMC_BASE, 0xF08+0x8*0) = 0x00F; // SARSIZE0 - 32GB
+
+//  while ((MEM_RW(DMC_BASE, 0x18)&0x1)  ==1 );  // MRSTAT - wait busy
+//
+//  // Configure PHY
+////  MEM_RW(PHY_BASE,DMC620_PHY_INIT_COMPLETE)   = 0x00000001; //0x00   
+//  MEM_RW(PHY_BASE,DMC620_PHY_READ_DELAY)      = 0x00000002; //0x08
+//  MEM_RW(PHY_BASE,DMC620_PHY_CAPTURE_MASK)    = 0x0000001f; //0x0C
+//  MEM_RW(PHY_BASE,DMC620_PHY_T_CONTROL_DELAY) = 0x00000000; //0x14
+//  MEM_RW(PHY_BASE,DMC620_PHY_WR_LATENCY)      = 0x01000000; //0x18   
+//  MEM_RW(PHY_BASE,DMC620_PHY_RDDATA_EN)       = 0x00001a00; //0x1C
+//  MEM_RW(PHY_BASE,DMC620_PHY_RD_LATENCY)      = 0x00000016; //0x20
+//  MEM_RW(PHY_BASE,DMC620_PHY_CLP_ACK)         = 0x00641300; //0x30
+//  MEM_RW(PHY_BASE,0x04C)                      = 0x00000002; //0x4c PHY500_DFI_WR_PREMBL (0x58 DMC620_PHY_WR_PREMBL)
+//  MEM_RW(PHY_BASE,DMC620_PHY_DELAY_SEL)       = 0x0000000A; //0x820
+////  MEM_RW(PHY_BASE,DMC620_PHY_REF_EN)          = 0x00000000; //0x824
+//  MEM_RW(PHY_BASE,DMC620_PHY_T_CTRL_UPD_MIN)  = 0x00000000; //0x828
+//  
+////  while ((MEM_RW(DMC_BASE, 0x4)&0x1) != 1 );  // STAT - wait until normal
+//
+////
diff --git a/module/snps_umctl/src/Makefile b/module/snps_umctl/src/Makefile
new file mode 100644
index 00000000..c642b910
--- /dev/null
+++ b/module/snps_umctl/src/Makefile
@@ -0,0 +1,11 @@
+#
+# Arm SCP/MCP Software
+# Copyright (c) 2020, Arm Limited and Contributors. All rights reserved.
+#
+# SPDX-License-Identifier: BSD-3-Clause
+#
+
+BS_LIB_NAME := mod_snps_umctl
+BS_LIB_SOURCES += mod_snps_umctl.c
+
+include $(BS_DIR)/lib.mk
diff --git a/module/snps_umctl/src/mod_snps_umctl.c b/module/snps_umctl/src/mod_snps_umctl.c
new file mode 100644
index 00000000..d4a316b1
--- /dev/null
+++ b/module/snps_umctl/src/mod_snps_umctl.c
@@ -0,0 +1,279 @@
+/*
+ * Arm SCP/MCP Software
+ * Copyright (c) 2020, Arm Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Description:
+ *     Synopsis UMCTL2 LPDDR4 and LPDDR5 memory controller driver
+ *     to be used with TotalCompute.
+ */
+
+#include <stdint.h>
+#include <fmw_cmsis.h>
+#include <fwk_assert.h>
+#include <fwk_id.h>
+#include <fwk_interrupt.h>
+#include <fwk_macros.h>
+#include <fwk_module.h>
+#include <fwk_module_idx.h>
+#include <fwk_notification.h>
+#include <fwk_log.h>
+
+#include <mod_snps_umctl.h>
+#include <mod_clock.h>
+
+#include <clock_soc.h>
+
+#define DMC_INIT
+#define LPDDR5
+
+#include <test_defs.h>
+#include <snps_defines.h>
+#include <dmc620_registers.h>
+
+#include <fw_tzc400.h>
+#include <scp_css_mmap.h>
+
+
+
+#ifdef LPDDR5
+#ifndef DMC_STRIPE_DEC
+#define DMC_STRIPE_DEC 0
+#define DMC_ADDR_SHUTTER_31_00 0
+#define DMC_ADDR_SHUTTER_HIGH 0
+#endif
+#ifndef DWC_DDRCTL_INIT_REGS_FUN
+#define DWC_DDRCTL_INIT_REGS_FUN "DWC_ddrctl_lpddr5_init_regs.h"
+#endif
+#ifndef DWC_DDRCTL_INIT_MEM_FUN
+#define DWC_DDRCTL_INIT_MEM_FUN "DWC_ddrctl_lpddr5_init_mem.h"
+#endif
+#ifndef DMC_BASE_ADDR
+#define DMC_BASE_ADDR     0xc1000000
+#endif
+// Note: This option chooses PHY independant training for SDRAM initialization
+#define DMC_DISABLE_DRAM_INIT
+
+#else // LPDDR5
+
+#ifndef UMCTL2_INIT_REGS_FUN
+#define UMCTL2_INIT_REGS_FUN "umctl2_lpddr4_3200_init_regs.h"
+#endif
+#ifndef UMCTL2_INIT_MEM_FUN
+#define UMCTL2_INIT_MEM_FUN "umctl2_lpddr4_3200_init_mem.h"
+#endif
+#ifndef DMC_BASE_ADDR
+#define DMC_BASE_ADDR     0x21000000
+#define SNPS_VIP_FW
+#endif
+
+#endif // LPDDR5
+
+#ifndef DMC_OFFSET
+#define DMC_OFFSET        0x100000
+#endif
+#ifndef DMC_PHY_BASE_ADDR
+#define DMC_PHY_BASE_ADDR 0x9FB60000
+#endif
+#ifndef DMC_PHY_OFFSET
+#define DMC_PHY_OFFSET    0x10000
+#endif
+
+#define POWER_PERIPH_BASE         ((uint32_t)0x50000000)
+#define PIK_SCP_BASE              (POWER_PERIPH_BASE + 0x0)
+#define PIK_SYSTEM_BASE           (POWER_PERIPH_BASE + 0x40000)
+#define PIK_CLUS_0_BASE           (POWER_PERIPH_BASE + 0x60000)
+
+#define MEM_RW(base,offset) *((volatile unsigned int *)(base + offset))
+
+#ifdef LPDDR5
+
+void DWC_ddrctl_lpddr5_init_regs (unsigned int index) {
+    unsigned int DMC_BASE = DMC_BASE_ADDR + DMC_OFFSET*index;
+
+    if ((MEM_RW(DMC_BASE,0x010000)) == 0x03040001 || (MEM_RW(DMC_BASE,0x010000)) == 0x03040000) {
+        FWK_LOG_INFO("DWC_DDRCTL INITIALIZATION for DMC%0d\n",index);
+        #include DWC_DDRCTL_INIT_REGS_FUN
+    } else if ((MEM_RW(DMC_BASE,0x010000)) == 0x0F101B0F) {
+        FWK_LOG_INFO("OH NO, WE SHOULDN'T END UP HERE %0d\n",index);
+    }
+}
+
+void DWC_ddrctl_lpddr5_init_mem (unsigned int index) {
+    unsigned int PHY_BASE = DMC_PHY_BASE_ADDR + DMC_PHY_OFFSET*index;
+    unsigned int DMC_BASE = DMC_BASE_ADDR + DMC_OFFSET*index;
+    #include DWC_DDRCTL_INIT_MEM_FUN
+}
+
+#else // LPDDR5
+
+void umctl_init_regs (unsigned int index) {
+    unsigned int DMC_BASE = DMC_BASE_ADDR + DMC_OFFSET*index;
+    //  DDR4 || LPDDR4
+    if ((MEM_RW(DMC_BASE,0)) == 0x03040001 || (MEM_RW(DMC_BASE,0)) == 0x03040000) {
+        FWK_LOG_INFO("SNPS UMCTL2 %0d\n",index);
+        #include UMCTL2_INIT_REGS_FUN
+    } else if ((MEM_RW(DMC_BASE,0)) == 0x0F101B0F) {
+        FWK_LOG_INFO("OH NO, WE SHOULDN'T END UP HERE %0d\n",index);
+  }
+}
+
+void umctl_init_mem (unsigned int index) {
+    unsigned int PHY_BASE = DMC_PHY_BASE_ADDR + DMC_PHY_OFFSET*index;
+    unsigned int DMC_BASE = DMC_BASE_ADDR + DMC_OFFSET*index;
+    #include UMCTL2_INIT_MEM_FUN
+}
+
+#endif
+
+/* TZC400 programming for sideloading TF-A fip in DRAM */
+#define EXTERNAL_DEV_BASE         ((uint32_t)0xA0000000)
+
+#define TZC400_0_BASE             (EXTERNAL_DEV_BASE + 0x25000000)
+#define TZC400_1_BASE             (EXTERNAL_DEV_BASE + 0x26000000)
+#define TZC400_2_BASE             (EXTERNAL_DEV_BASE + 0x27000000)
+#define TZC400_3_BASE             (EXTERNAL_DEV_BASE + 0x28000000)
+
+
+void fw_tzc400_init(unsigned int TZC400_BASE)
+{
+  volatile TZC400_TypeDef * TZC400 = (volatile TZC400_TypeDef *)TZC400_BASE;
+  TZC400->REGION[0].REGION_ATTRIBUTES = 0xC0000000; //Secure reads and writes enabled for Region 0
+  TZC400->REGION[0].REGION_ID_ACCESS = 0xFFFFFFFF;  //Non-secure reads and writes permitted for NSAIDR 0-15
+  TZC400->ACTION = 0x1;         //TZCINT is set Low and a DECERR response is issued in case of region permission failure
+  TZC400->GATE_KEEPER = 0xF;            //Gates of all of the filters are requested to be opened
+}
+
+/* MPU programming */
+#define SCS_BASE            (0xE000E000UL)                          /*!< System Control Space Base Address  */
+#define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit             */
+#define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit             */
+
+void setup_mpu(void)
+{
+  MPU->RNR = 0x00;
+  MPU->RBAR = 0x00000000;
+  MPU->RASR = 0x0300003f;
+  MPU->CTRL = 0x03;
+}
+
+static void snps_umctl2_configure_controller()
+{
+#ifdef DMC_INIT
+    MEM_RW(PIK_SCP_BASE, 0x1000) = 0x00000008;
+    while((MEM_RW(PIK_SCP_BASE, 0x1008) & 0x0000000f) != 0x00000008);
+
+    MEM_RW(PIK_CLUS_0_BASE, 0x810) = 0x00000003; // CLUSTER_PCLK_CLKDIV: 4 !!! 0x50000000 + 0x810 + 0x60000
+
+    // Setup MPU
+    setup_mpu();
+
+
+    FWK_LOG_INFO("DMC init\n");
+#ifdef LPDDR5
+    DWC_ddrctl_lpddr5_init_regs(0);
+    DWC_ddrctl_lpddr5_init_regs(1);
+    DWC_ddrctl_lpddr5_init_regs(2);
+    DWC_ddrctl_lpddr5_init_regs(3);
+#else
+    umctl_init_regs(0);
+    umctl_init_regs(1);
+    umctl_init_regs(2);
+    umctl_init_regs(3);
+#endif
+    MEM_RW(0xA8044000,0x104)=0xfb;
+    FWK_LOG_INFO("DMC init finished\n");
+
+    // Release the reset for axi and dfi interfaces by writing to the System PIK register
+    MEM_RW(SCP_PIK_SYSTEM_BASE, 0x0b14) = 0x00000001; // !!! 0x50000000 + 0xb14 + 0x40000
+    while((MEM_RW(SCP_PIK_SYSTEM_BASE, 0x0b10) & 0x00000001) == 0x00000000);
+
+    // Initialize the PHY and the Memory using DMC
+    FWK_LOG_INFO("PHY init\n");
+#ifdef LPDDR5
+    DWC_ddrctl_lpddr5_init_mem(0);
+    DWC_ddrctl_lpddr5_init_mem(1);
+    DWC_ddrctl_lpddr5_init_mem(2);
+    DWC_ddrctl_lpddr5_init_mem(3);
+#else
+    umctl_init_mem(0);
+    umctl_init_mem(1);
+    umctl_init_mem(2);
+    umctl_init_mem(3);
+#endif
+    FWK_LOG_INFO("PHY init finished\n");
+
+    //Initialize TZC400
+    fw_tzc400_init(TZC400_0_BASE);
+    FWK_LOG_INFO("TZC init0\n");
+    fw_tzc400_init(TZC400_1_BASE);
+    FWK_LOG_INFO("TZC init1\n");
+    fw_tzc400_init(TZC400_2_BASE);
+    FWK_LOG_INFO("TZC init2\n");
+    fw_tzc400_init(TZC400_3_BASE);
+    FWK_LOG_INFO("TZC init3\n");
+    FWK_LOG_INFO("TZC400 initialised\n");
+
+    if ( (MEM_RW(0xA8044000, 0x1C) & 0x1) == 0) { // if BD_INIT_DONE not set INIT DMC and PHY
+        MEM_RW(0xA8044000,0x1C) = 0x02;
+        MEM_RW(0xA8044000,0x104)= 0xfa;
+        MEM_RW(0xA8044000,0x1C) = (MEM_RW(0xA8044000, 0x1C) | 0x1); // write BD_INIT_DONE
+        while (MEM_RW(0xA8044000, 0x1C) & 0x1); // go into loop until reset
+    }
+#endif
+
+}
+
+/* Framework API */
+static int mod_snps_umctl_process_notification(
+               const struct fwk_event *event,
+               struct fwk_event *resp_event)
+{
+    snps_umctl2_configure_controller();
+    return FWK_SUCCESS;
+}
+
+static int mod_snps_umctl_start(fwk_id_t id)
+{
+    fwk_id_t clock_id = FWK_ID_ELEMENT_INIT(FWK_MODULE_IDX_CLOCK,
+                                            CLOCK_IDX_INTERCONNECT);
+
+    return fwk_notification_subscribe(
+                mod_clock_notification_id_state_changed,
+                clock_id,
+                id);
+}
+
+static int mod_snps_umctl_bind(fwk_id_t id, unsigned int round)
+{
+    /* Nothing to do in the first round of calls. */
+    if (round == 1)
+        return FWK_SUCCESS;
+
+    /* Nothing to do in case of elements. */
+    if (fwk_module_is_valid_element_id(id))
+        return FWK_SUCCESS;
+
+    return FWK_SUCCESS;
+}
+
+static int snps_umctl_init(fwk_id_t module_id, unsigned int unused,
+    const void *unused2)
+{
+    return FWK_SUCCESS;
+}
+
+const struct fwk_module module_snps_umctl = {
+    .name = "SNPS_UMCTL",
+    .type = FWK_MODULE_TYPE_DRIVER,
+    .init = snps_umctl_init,
+    .bind = mod_snps_umctl_bind,
+    .start = mod_snps_umctl_start,
+    .process_notification = mod_snps_umctl_process_notification,
+    .api_count = 0,
+    .event_count = 0,
+};
+
+/* No elements, no module configuration data */
+struct fwk_module_config config_snps_umctl = { 0 };
-- 
2.25.1

